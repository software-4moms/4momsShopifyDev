(function (require$$2) {
	'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);

	define(["./core", "./selector", "./traversing", "./callbacks", "./deferred", "./deferred/exceptionHook", "./core/ready", "./data", "./queue", "./queue/delay", "./attributes", "./event", "./event/alias", "./event/focusin", "./manipulation", "./manipulation/_evalUrl", "./wrap", "./css", "./css/hiddenVisibleSelectors", "./serialize", "./ajax", "./ajax/xhr", "./ajax/script", "./ajax/jsonp", "./ajax/load", "./event/ajax", "./effects", "./effects/animatedSelector", "./offset", "./dimensions", "./deprecated", "./exports/amd", "./exports/global"], function (jQuery) {

	  return jQuery;
	});

	/*!
		Zoom 1.7.21
		license: MIT
		http://www.jacklmoore.com/zoom
	*/
	(function (o) {
	  var t = {
	    url: !1,
	    callback: !1,
	    target: !1,
	    duration: 120,
	    on: "mouseover",
	    touch: !0,
	    onZoomIn: !1,
	    onZoomOut: !1,
	    magnify: 1
	  };
	  o.zoom = function (t, n, e, i) {
	    var u,
	      c,
	      a,
	      r,
	      m,
	      l,
	      s,
	      f = o(t),
	      h = f.css("position"),
	      d = o(n);
	    return t.style.position = /(absolute|fixed)/.test(h) ? h : "relative", t.style.overflow = "hidden", e.style.width = e.style.height = "", o(e).addClass("zoomImg").css({
	      position: "absolute",
	      top: 0,
	      left: 0,
	      opacity: 0,
	      width: e.width * i,
	      height: e.height * i,
	      border: "none",
	      maxWidth: "none",
	      maxHeight: "none"
	    }).appendTo(t), {
	      init: function () {
	        c = f.outerWidth(), u = f.outerHeight(), n === t ? (r = c, a = u) : (r = d.outerWidth(), a = d.outerHeight()), m = (e.width - c) / r, l = (e.height - u) / a, s = d.offset();
	      },
	      move: function (o) {
	        var t = o.pageX - s.left,
	          n = o.pageY - s.top;
	        n = Math.max(Math.min(n, a), 0), t = Math.max(Math.min(t, r), 0), e.style.left = t * -m + "px", e.style.top = n * -l + "px";
	      }
	    };
	  }, o.fn.zoom = function (n) {
	    return this.each(function () {
	      var e = o.extend({}, t, n || {}),
	        i = e.target && o(e.target)[0] || this,
	        u = this,
	        c = o(u),
	        a = document.createElement("img"),
	        r = o(a),
	        m = "mousemove.zoom",
	        l = !1,
	        s = !1;
	      if (!e.url) {
	        var f = u.querySelector("img");
	        if (f && (e.url = f.getAttribute("data-src") || f.currentSrc || f.src), !e.url) return;
	      }
	      c.one("zoom.destroy", function (o, t) {
	        c.off(".zoom"), i.style.position = o, i.style.overflow = t, a.onload = null, r.remove();
	      }.bind(this, i.style.position, i.style.overflow)), a.onload = function () {
	        function t(t) {
	          f.init(), f.move(t), r.stop().fadeTo(o.support.opacity ? e.duration : 0, 1, o.isFunction(e.onZoomIn) ? e.onZoomIn.call(a) : !1);
	        }
	        function n() {
	          r.stop().fadeTo(e.duration, 0, o.isFunction(e.onZoomOut) ? e.onZoomOut.call(a) : !1);
	        }
	        var f = o.zoom(i, u, a, e.magnify);
	        "grab" === e.on ? c.on("mousedown.zoom", function (e) {
	          1 === e.which && (o(document).one("mouseup.zoom", function () {
	            n(), o(document).off(m, f.move);
	          }), t(e), o(document).on(m, f.move), e.preventDefault());
	        }) : "click" === e.on ? c.on("click.zoom", function (e) {
	          return l ? void 0 : (l = !0, t(e), o(document).on(m, f.move), o(document).one("click.zoom", function () {
	            n(), l = !1, o(document).off(m, f.move);
	          }), !1);
	        }) : "toggle" === e.on ? c.on("click.zoom", function (o) {
	          l ? n() : t(o), l = !l;
	        }) : "mouseover" === e.on && (f.init(), c.on("mouseenter.zoom", t).on("mouseleave.zoom", n).on(m, f.move)), e.touch && c.on("touchstart.zoom", function (o) {
	          o.preventDefault(), s ? (s = !1, n()) : (s = !0, t(o.originalEvent.touches[0] || o.originalEvent.changedTouches[0]));
	        }).on("touchmove.zoom", function (o) {
	          o.preventDefault(), f.move(o.originalEvent.touches[0] || o.originalEvent.changedTouches[0]);
	        }).on("touchend.zoom", function (o) {
	          o.preventDefault(), s && (s = !1, n());
	        }), o.isFunction(e.callback) && e.callback.call(a);
	      }, a.setAttribute("role", "presentation"), a.alt = "", a.src = e.url;
	    });
	  }, o.fn.zoom.defaults = t;
	})(window.jQuery);

	/**
	 * jQuery Unveil
	 * A very lightweight jQuery plugin to lazy load images
	 * http://luis-almeida.github.com/unveil
	 *
	 * Licensed under the MIT license.
	 * Copyright 2013 LuÃ­s Almeida
	 * https://github.com/luis-almeida
	 */
	(function ($) {
	  $.fn.unveil = function (threshold, callback) {
	    var $w = $(window),
	      th = threshold || 0,
	      retina = window.devicePixelRatio > 1,
	      attrib = retina ? "data-src-retina" : "data-src",
	      images = this,
	      loaded;
	    this.one("unveil", function () {
	      var source = this.getAttribute(attrib);
	      source = source || this.getAttribute("data-src");
	      if (source) {
	        this.setAttribute("src", source);
	        if (typeof callback === "function") callback.call(this);
	      }
	    });
	    function unveil() {
	      var inview = images.filter(function () {
	        var $e = $(this),
	          wt = $w.scrollTop(),
	          wb = wt + $w.height(),
	          et = $e.offset().top,
	          eb = et + $e.height();
	        return eb >= wt - th && et <= wb + th;
	      });
	      loaded = inview.trigger("unveil");
	      images = images.not(loaded);
	    }
	    $w.on("scroll.unveil resize.unveil lookup.unveil", unveil);
	    unveil();
	    return this;
	  };
	})(window.jQuery || window.Zepto);

	/*----------------------------------------
	 * objectFitPolyfill 2.3.5
	 *
	 * Made by Constance Chen
	 * Released under the ISC license
	 *
	 * https://github.com/constancecchen/object-fit-polyfill
	 *--------------------------------------*/

	(function () {

	  // if the page is being rendered on the server, don't continue
	  if (typeof window === 'undefined') return;

	  // Workaround for Edge 16-18, which only implemented object-fit for <img> tags
	  var edgeMatch = window.navigator.userAgent.match(/Edge\/(\d{2})\./);
	  var edgeVersion = edgeMatch ? parseInt(edgeMatch[1], 10) : null;
	  var edgePartialSupport = edgeVersion ? edgeVersion >= 16 && edgeVersion <= 18 : false;

	  // If the browser does support object-fit, we don't need to continue
	  var hasSupport = 'objectFit' in document.documentElement.style !== false;
	  if (hasSupport && !edgePartialSupport) {
	    window.objectFitPolyfill = function () {
	      return false;
	    };
	    return;
	  }

	  /**
	   * Check the container's parent element to make sure it will
	   * correctly handle and clip absolutely positioned children
	   *
	   * @param {node} $container - parent element
	   */
	  var checkParentContainer = function ($container) {
	    var styles = window.getComputedStyle($container, null);
	    var position = styles.getPropertyValue('position');
	    var overflow = styles.getPropertyValue('overflow');
	    var display = styles.getPropertyValue('display');
	    if (!position || position === 'static') {
	      $container.style.position = 'relative';
	    }
	    if (overflow !== 'hidden') {
	      $container.style.overflow = 'hidden';
	    }
	    // Guesstimating that people want the parent to act like full width/height wrapper here.
	    // Mostly attempts to target <picture> elements, which default to inline.
	    if (!display || display === 'inline') {
	      $container.style.display = 'block';
	    }
	    if ($container.clientHeight === 0) {
	      $container.style.height = '100%';
	    }

	    // Add a CSS class hook, in case people need to override styles for any reason.
	    if ($container.className.indexOf('object-fit-polyfill') === -1) {
	      $container.className = $container.className + ' object-fit-polyfill';
	    }
	  };

	  /**
	   * Check for pre-set max-width/height, min-width/height,
	   * positioning, or margins, which can mess up image calculations
	   *
	   * @param {node} $media - img/video element
	   */
	  var checkMediaProperties = function ($media) {
	    var styles = window.getComputedStyle($media, null);
	    var constraints = {
	      'max-width': 'none',
	      'max-height': 'none',
	      'min-width': '0px',
	      'min-height': '0px',
	      top: 'auto',
	      right: 'auto',
	      bottom: 'auto',
	      left: 'auto',
	      'margin-top': '0px',
	      'margin-right': '0px',
	      'margin-bottom': '0px',
	      'margin-left': '0px'
	    };
	    for (var property in constraints) {
	      var constraint = styles.getPropertyValue(property);
	      if (constraint !== constraints[property]) {
	        $media.style[property] = constraints[property];
	      }
	    }
	  };

	  /**
	   * Calculate & set object-position
	   *
	   * @param {string} axis - either "x" or "y"
	   * @param {node} $media - img or video element
	   * @param {string} objectPosition - e.g. "50% 50%", "top left"
	   */
	  var setPosition = function (axis, $media, objectPosition) {
	    var position, other, start, end, side;
	    objectPosition = objectPosition.split(' ');
	    if (objectPosition.length < 2) {
	      objectPosition[1] = objectPosition[0];
	    }

	    /* istanbul ignore else */
	    if (axis === 'x') {
	      position = objectPosition[0];
	      other = objectPosition[1];
	      start = 'left';
	      end = 'right';
	      side = $media.clientWidth;
	    } else if (axis === 'y') {
	      position = objectPosition[1];
	      other = objectPosition[0];
	      start = 'top';
	      end = 'bottom';
	      side = $media.clientHeight;
	    } else {
	      return; // Neither x or y axis specified
	    }
	    if (position === start || other === start) {
	      $media.style[start] = '0';
	      return;
	    }
	    if (position === end || other === end) {
	      $media.style[end] = '0';
	      return;
	    }
	    if (position === 'center' || position === '50%') {
	      $media.style[start] = '50%';
	      $media.style['margin-' + start] = side / -2 + 'px';
	      return;
	    }

	    // Percentage values (e.g., 30% 10%)
	    if (position.indexOf('%') >= 0) {
	      position = parseInt(position, 10);
	      if (position < 50) {
	        $media.style[start] = position + '%';
	        $media.style['margin-' + start] = side * (position / -100) + 'px';
	      } else {
	        position = 100 - position;
	        $media.style[end] = position + '%';
	        $media.style['margin-' + end] = side * (position / -100) + 'px';
	      }
	      return;
	    }
	    // Length-based values (e.g. 10px / 10em)
	    else {
	      $media.style[start] = position;
	    }
	  };

	  /**
	   * Calculate & set object-fit
	   *
	   * @param {node} $media - img/video/picture element
	   */
	  var objectFit = function ($media) {
	    // IE 10- data polyfill
	    var fit = $media.dataset ? $media.dataset.objectFit : $media.getAttribute('data-object-fit');
	    var position = $media.dataset ? $media.dataset.objectPosition : $media.getAttribute('data-object-position');

	    // Default fallbacks
	    fit = fit || 'cover';
	    position = position || '50% 50%';

	    // If necessary, make the parent container work with absolutely positioned elements
	    var $container = $media.parentNode;
	    checkParentContainer($container);

	    // Check for any pre-set CSS which could mess up image calculations
	    checkMediaProperties($media);

	    // Reset any pre-set width/height CSS and handle fit positioning
	    $media.style.position = 'absolute';
	    $media.style.width = 'auto';
	    $media.style.height = 'auto';

	    // `scale-down` chooses either `none` or `contain`, whichever is smaller
	    if (fit === 'scale-down') {
	      if ($media.clientWidth < $container.clientWidth && $media.clientHeight < $container.clientHeight) {
	        fit = 'none';
	      } else {
	        fit = 'contain';
	      }
	    }

	    // `none` (width/height auto) and `fill` (100%) and are straightforward
	    if (fit === 'none') {
	      setPosition('x', $media, position);
	      setPosition('y', $media, position);
	      return;
	    }
	    if (fit === 'fill') {
	      $media.style.width = '100%';
	      $media.style.height = '100%';
	      setPosition('x', $media, position);
	      setPosition('y', $media, position);
	      return;
	    }

	    // `cover` and `contain` must figure out which side needs covering, and add CSS positioning & centering
	    $media.style.height = '100%';
	    if (fit === 'cover' && $media.clientWidth > $container.clientWidth || fit === 'contain' && $media.clientWidth < $container.clientWidth) {
	      $media.style.top = '0';
	      $media.style.marginTop = '0';
	      setPosition('x', $media, position);
	    } else {
	      $media.style.width = '100%';
	      $media.style.height = 'auto';
	      $media.style.left = '0';
	      $media.style.marginLeft = '0';
	      setPosition('y', $media, position);
	    }
	  };

	  /**
	   * Initialize plugin
	   *
	   * @param {node} media - Optional specific DOM node(s) to be polyfilled
	   */
	  var objectFitPolyfill = function (media) {
	    if (typeof media === 'undefined' || media instanceof Event) {
	      // If left blank, or a default event, all media on the page will be polyfilled.
	      media = document.querySelectorAll('[data-object-fit]');
	    } else if (media && media.nodeName) {
	      // If it's a single node, wrap it in an array so it works.
	      media = [media];
	    } else if (typeof media === 'object' && media.length && media[0].nodeName) {
	      // If it's an array of DOM nodes (e.g. a jQuery selector), it's fine as-is.
	      media = media;
	    } else {
	      // Otherwise, if it's invalid or an incorrect type, return false to let people know.
	      return false;
	    }
	    for (var i = 0; i < media.length; i++) {
	      if (!media[i].nodeName) continue;
	      var mediaType = media[i].nodeName.toLowerCase();
	      if (mediaType === 'img') {
	        if (edgePartialSupport) continue; // Edge supports object-fit for images (but nothing else), so no need to polyfill

	        if (media[i].complete) {
	          objectFit(media[i]);
	        } else {
	          media[i].addEventListener('load', function () {
	            objectFit(this);
	          });
	        }
	      } else if (mediaType === 'video') {
	        if (media[i].readyState > 0) {
	          objectFit(media[i]);
	        } else {
	          media[i].addEventListener('loadedmetadata', function () {
	            objectFit(this);
	          });
	        }
	      } else {
	        objectFit(media[i]);
	      }
	    }
	    return true;
	  };
	  if (document.readyState === 'loading') {
	    // Loading hasn't finished yet
	    document.addEventListener('DOMContentLoaded', objectFitPolyfill);
	  } else {
	    // `DOMContentLoaded` has already fired
	    objectFitPolyfill();
	  }
	  window.addEventListener('resize', objectFitPolyfill);
	  window.objectFitPolyfill = objectFitPolyfill;
	})();

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var lazysizes = {exports: {}};

	lazysizes.exports;
	(function (module) {
	  (function (window, factory) {
	    var lazySizes = factory(window, window.document, Date);
	    window.lazySizes = lazySizes;
	    if (module.exports) {
	      module.exports = lazySizes;
	    }
	  })(typeof window != 'undefined' ? window : {},
	  /**
	   * import("./types/global")
	   * @typedef { import("./types/lazysizes-config").LazySizesConfigPartial } LazySizesConfigPartial
	   */
	  function l(window, document, Date) {

	    /*jshint eqnull:true */
	    var lazysizes,
	      /**
	       * @type { LazySizesConfigPartial }
	       */
	      lazySizesCfg;
	    (function () {
	      var prop;
	      var lazySizesDefaults = {
	        lazyClass: 'lazyload',
	        loadedClass: 'lazyloaded',
	        loadingClass: 'lazyloading',
	        preloadClass: 'lazypreload',
	        errorClass: 'lazyerror',
	        //strictClass: 'lazystrict',
	        autosizesClass: 'lazyautosizes',
	        fastLoadedClass: 'ls-is-cached',
	        iframeLoadMode: 0,
	        srcAttr: 'data-src',
	        srcsetAttr: 'data-srcset',
	        sizesAttr: 'data-sizes',
	        //preloadAfterLoad: false,
	        minSize: 40,
	        customMedia: {},
	        init: true,
	        expFactor: 1.5,
	        hFac: 0.8,
	        loadMode: 2,
	        loadHidden: true,
	        ricTimeout: 0,
	        throttleDelay: 125
	      };
	      lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};
	      for (prop in lazySizesDefaults) {
	        if (!(prop in lazySizesCfg)) {
	          lazySizesCfg[prop] = lazySizesDefaults[prop];
	        }
	      }
	    })();
	    if (!document || !document.getElementsByClassName) {
	      return {
	        init: function () {},
	        /**
	         * @type { LazySizesConfigPartial }
	         */
	        cfg: lazySizesCfg,
	        /**
	         * @type { true }
	         */
	        noSupport: true
	      };
	    }
	    var docElem = document.documentElement;
	    var supportPicture = window.HTMLPictureElement;
	    var _addEventListener = 'addEventListener';
	    var _getAttribute = 'getAttribute';

	    /**
	     * Update to bind to window because 'this' becomes null during SSR
	     * builds.
	     */
	    var addEventListener = window[_addEventListener].bind(window);
	    var setTimeout = window.setTimeout;
	    var requestAnimationFrame = window.requestAnimationFrame || setTimeout;
	    var requestIdleCallback = window.requestIdleCallback;
	    var regPicture = /^picture$/i;
	    var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];
	    var regClassCache = {};
	    var forEach = Array.prototype.forEach;

	    /**
	     * @param ele {Element}
	     * @param cls {string}
	     */
	    var hasClass = function (ele, cls) {
	      if (!regClassCache[cls]) {
	        regClassCache[cls] = new RegExp('(\\s|^)' + cls + '(\\s|$)');
	      }
	      return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];
	    };

	    /**
	     * @param ele {Element}
	     * @param cls {string}
	     */
	    var addClass = function (ele, cls) {
	      if (!hasClass(ele, cls)) {
	        ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);
	      }
	    };

	    /**
	     * @param ele {Element}
	     * @param cls {string}
	     */
	    var removeClass = function (ele, cls) {
	      var reg;
	      if (reg = hasClass(ele, cls)) {
	        ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));
	      }
	    };
	    var addRemoveLoadEvents = function (dom, fn, add) {
	      var action = add ? _addEventListener : 'removeEventListener';
	      if (add) {
	        addRemoveLoadEvents(dom, fn);
	      }
	      loadEvents.forEach(function (evt) {
	        dom[action](evt, fn);
	      });
	    };

	    /**
	     * @param elem { Element }
	     * @param name { string }
	     * @param detail { any }
	     * @param noBubbles { boolean }
	     * @param noCancelable { boolean }
	     * @returns { CustomEvent }
	     */
	    var triggerEvent = function (elem, name, detail, noBubbles, noCancelable) {
	      var event = document.createEvent('Event');
	      if (!detail) {
	        detail = {};
	      }
	      detail.instance = lazysizes;
	      event.initEvent(name, !noBubbles, !noCancelable);
	      event.detail = detail;
	      elem.dispatchEvent(event);
	      return event;
	    };
	    var updatePolyfill = function (el, full) {
	      var polyfill;
	      if (!supportPicture && (polyfill = window.picturefill || lazySizesCfg.pf)) {
	        if (full && full.src && !el[_getAttribute]('srcset')) {
	          el.setAttribute('srcset', full.src);
	        }
	        polyfill({
	          reevaluate: true,
	          elements: [el]
	        });
	      } else if (full && full.src) {
	        el.src = full.src;
	      }
	    };
	    var getCSS = function (elem, style) {
	      return (getComputedStyle(elem, null) || {})[style];
	    };

	    /**
	     *
	     * @param elem { Element }
	     * @param parent { Element }
	     * @param [width] {number}
	     * @returns {number}
	     */
	    var getWidth = function (elem, parent, width) {
	      width = width || elem.offsetWidth;
	      while (width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth) {
	        width = parent.offsetWidth;
	        parent = parent.parentNode;
	      }
	      return width;
	    };
	    var rAF = function () {
	      var running, waiting;
	      var firstFns = [];
	      var secondFns = [];
	      var fns = firstFns;
	      var run = function () {
	        var runFns = fns;
	        fns = firstFns.length ? secondFns : firstFns;
	        running = true;
	        waiting = false;
	        while (runFns.length) {
	          runFns.shift()();
	        }
	        running = false;
	      };
	      var rafBatch = function (fn, queue) {
	        if (running && !queue) {
	          fn.apply(this, arguments);
	        } else {
	          fns.push(fn);
	          if (!waiting) {
	            waiting = true;
	            (document.hidden ? setTimeout : requestAnimationFrame)(run);
	          }
	        }
	      };
	      rafBatch._lsFlush = run;
	      return rafBatch;
	    }();
	    var rAFIt = function (fn, simple) {
	      return simple ? function () {
	        rAF(fn);
	      } : function () {
	        var that = this;
	        var args = arguments;
	        rAF(function () {
	          fn.apply(that, args);
	        });
	      };
	    };
	    var throttle = function (fn) {
	      var running;
	      var lastTime = 0;
	      var gDelay = lazySizesCfg.throttleDelay;
	      var rICTimeout = lazySizesCfg.ricTimeout;
	      var run = function () {
	        running = false;
	        lastTime = Date.now();
	        fn();
	      };
	      var idleCallback = requestIdleCallback && rICTimeout > 49 ? function () {
	        requestIdleCallback(run, {
	          timeout: rICTimeout
	        });
	        if (rICTimeout !== lazySizesCfg.ricTimeout) {
	          rICTimeout = lazySizesCfg.ricTimeout;
	        }
	      } : rAFIt(function () {
	        setTimeout(run);
	      }, true);
	      return function (isPriority) {
	        var delay;
	        if (isPriority = isPriority === true) {
	          rICTimeout = 33;
	        }
	        if (running) {
	          return;
	        }
	        running = true;
	        delay = gDelay - (Date.now() - lastTime);
	        if (delay < 0) {
	          delay = 0;
	        }
	        if (isPriority || delay < 9) {
	          idleCallback();
	        } else {
	          setTimeout(idleCallback, delay);
	        }
	      };
	    };

	    //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html
	    var debounce = function (func) {
	      var timeout, timestamp;
	      var wait = 99;
	      var run = function () {
	        timeout = null;
	        func();
	      };
	      var later = function () {
	        var last = Date.now() - timestamp;
	        if (last < wait) {
	          setTimeout(later, wait - last);
	        } else {
	          (requestIdleCallback || run)(run);
	        }
	      };
	      return function () {
	        timestamp = Date.now();
	        if (!timeout) {
	          timeout = setTimeout(later, wait);
	        }
	      };
	    };
	    var loader = function () {
	      var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;
	      var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;
	      var regImg = /^img$/i;
	      var regIframe = /^iframe$/i;
	      var supportScroll = 'onscroll' in window && !/(gle|ing)bot/.test(navigator.userAgent);
	      var shrinkExpand = 0;
	      var currentExpand = 0;
	      var isLoading = 0;
	      var lowRuns = -1;
	      var resetPreloading = function (e) {
	        isLoading--;
	        if (!e || isLoading < 0 || !e.target) {
	          isLoading = 0;
	        }
	      };
	      var isVisible = function (elem) {
	        if (isBodyHidden == null) {
	          isBodyHidden = getCSS(document.body, 'visibility') == 'hidden';
	        }
	        return isBodyHidden || !(getCSS(elem.parentNode, 'visibility') == 'hidden' && getCSS(elem, 'visibility') == 'hidden');
	      };
	      var isNestedVisible = function (elem, elemExpand) {
	        var outerRect;
	        var parent = elem;
	        var visible = isVisible(elem);
	        eLtop -= elemExpand;
	        eLbottom += elemExpand;
	        eLleft -= elemExpand;
	        eLright += elemExpand;
	        while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {
	          visible = (getCSS(parent, 'opacity') || 1) > 0;
	          if (visible && getCSS(parent, 'overflow') != 'visible') {
	            outerRect = parent.getBoundingClientRect();
	            visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;
	          }
	        }
	        return visible;
	      };
	      var checkElements = function () {
	        var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal, defaultExpand, preloadExpand, hFac;
	        var lazyloadElems = lazysizes.elements;
	        if ((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
	          i = 0;
	          lowRuns++;
	          for (; i < eLlen; i++) {
	            if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
	              continue;
	            }
	            if (!supportScroll || lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i])) {
	              unveilElement(lazyloadElems[i]);
	              continue;
	            }
	            if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {
	              elemExpand = currentExpand;
	            }
	            if (!defaultExpand) {
	              defaultExpand = !lazySizesCfg.expand || lazySizesCfg.expand < 1 ? docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 : lazySizesCfg.expand;
	              lazysizes._defEx = defaultExpand;
	              preloadExpand = defaultExpand * lazySizesCfg.expFactor;
	              hFac = lazySizesCfg.hFac;
	              isBodyHidden = null;
	              if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {
	                currentExpand = preloadExpand;
	                lowRuns = 0;
	              } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
	                currentExpand = defaultExpand;
	              } else {
	                currentExpand = shrinkExpand;
	              }
	            }
	            if (beforeExpandVal !== elemExpand) {
	              eLvW = innerWidth + elemExpand * hFac;
	              elvH = innerHeight + elemExpand;
	              elemNegativeExpand = elemExpand * -1;
	              beforeExpandVal = elemExpand;
	            }
	            rect = lazyloadElems[i].getBoundingClientRect();
	            if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {
	              unveilElement(lazyloadElems[i]);
	              loadedSomething = true;
	              if (isLoading > 9) {
	                break;
	              }
	            } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesCfg.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != 'auto'))) {
	              autoLoadElem = preloadElems[0] || lazyloadElems[i];
	            }
	          }
	          if (autoLoadElem && !loadedSomething) {
	            unveilElement(autoLoadElem);
	          }
	        }
	      };
	      var throttledCheckElements = throttle(checkElements);
	      var switchLoadingClass = function (e) {
	        var elem = e.target;
	        if (elem._lazyCache) {
	          delete elem._lazyCache;
	          return;
	        }
	        resetPreloading(e);
	        addClass(elem, lazySizesCfg.loadedClass);
	        removeClass(elem, lazySizesCfg.loadingClass);
	        addRemoveLoadEvents(elem, rafSwitchLoadingClass);
	        triggerEvent(elem, 'lazyloaded');
	      };
	      var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
	      var rafSwitchLoadingClass = function (e) {
	        rafedSwitchLoadingClass({
	          target: e.target
	        });
	      };
	      var changeIframeSrc = function (elem, src) {
	        var loadMode = elem.getAttribute('data-load-mode') || lazySizesCfg.iframeLoadMode;

	        // loadMode can be also a string!
	        if (loadMode == 0) {
	          elem.contentWindow.location.replace(src);
	        } else if (loadMode == 1) {
	          elem.src = src;
	        }
	      };
	      var handleSources = function (source) {
	        var customMedia;
	        var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);
	        if (customMedia = lazySizesCfg.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) {
	          source.setAttribute('media', customMedia);
	        }
	        if (sourceSrcset) {
	          source.setAttribute('srcset', sourceSrcset);
	        }
	      };
	      var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {
	        var src, srcset, parent, isPicture, event, firesLoad;
	        if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {
	          if (sizes) {
	            if (isAuto) {
	              addClass(elem, lazySizesCfg.autosizesClass);
	            } else {
	              elem.setAttribute('sizes', sizes);
	            }
	          }
	          srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);
	          src = elem[_getAttribute](lazySizesCfg.srcAttr);
	          if (isImg) {
	            parent = elem.parentNode;
	            isPicture = parent && regPicture.test(parent.nodeName || '');
	          }
	          firesLoad = detail.firesLoad || 'src' in elem && (srcset || src || isPicture);
	          event = {
	            target: elem
	          };
	          addClass(elem, lazySizesCfg.loadingClass);
	          if (firesLoad) {
	            clearTimeout(resetPreloadingTimer);
	            resetPreloadingTimer = setTimeout(resetPreloading, 2500);
	            addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
	          }
	          if (isPicture) {
	            forEach.call(parent.getElementsByTagName('source'), handleSources);
	          }
	          if (srcset) {
	            elem.setAttribute('srcset', srcset);
	          } else if (src && !isPicture) {
	            if (regIframe.test(elem.nodeName)) {
	              changeIframeSrc(elem, src);
	            } else {
	              elem.src = src;
	            }
	          }
	          if (isImg && (srcset || isPicture)) {
	            updatePolyfill(elem, {
	              src: src
	            });
	          }
	        }
	        if (elem._lazyRace) {
	          delete elem._lazyRace;
	        }
	        removeClass(elem, lazySizesCfg.lazyClass);
	        rAF(function () {
	          // Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)
	          var isLoaded = elem.complete && elem.naturalWidth > 1;
	          if (!firesLoad || isLoaded) {
	            if (isLoaded) {
	              addClass(elem, lazySizesCfg.fastLoadedClass);
	            }
	            switchLoadingClass(event);
	            elem._lazyCache = true;
	            setTimeout(function () {
	              if ('_lazyCache' in elem) {
	                delete elem._lazyCache;
	              }
	            }, 9);
	          }
	          if (elem.loading == 'lazy') {
	            isLoading--;
	          }
	        }, true);
	      });

	      /**
	       *
	       * @param elem { Element }
	       */
	      var unveilElement = function (elem) {
	        if (elem._lazyRace) {
	          return;
	        }
	        var detail;
	        var isImg = regImg.test(elem.nodeName);

	        //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")
	        var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]('sizes'));
	        var isAuto = sizes == 'auto';
	        if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)) {
	          return;
	        }
	        detail = triggerEvent(elem, 'lazyunveilread').detail;
	        if (isAuto) {
	          autoSizer.updateElem(elem, true, elem.offsetWidth);
	        }
	        elem._lazyRace = true;
	        isLoading++;
	        lazyUnveil(elem, detail, isAuto, sizes, isImg);
	      };
	      var afterScroll = debounce(function () {
	        lazySizesCfg.loadMode = 3;
	        throttledCheckElements();
	      });
	      var altLoadmodeScrollListner = function () {
	        if (lazySizesCfg.loadMode == 3) {
	          lazySizesCfg.loadMode = 2;
	        }
	        afterScroll();
	      };
	      var onload = function () {
	        if (isCompleted) {
	          return;
	        }
	        if (Date.now() - started < 999) {
	          setTimeout(onload, 999);
	          return;
	        }
	        isCompleted = true;
	        lazySizesCfg.loadMode = 3;
	        throttledCheckElements();
	        addEventListener('scroll', altLoadmodeScrollListner, true);
	      };
	      return {
	        _: function () {
	          started = Date.now();
	          lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);
	          preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + ' ' + lazySizesCfg.preloadClass);
	          addEventListener('scroll', throttledCheckElements, true);
	          addEventListener('resize', throttledCheckElements, true);
	          addEventListener('pageshow', function (e) {
	            if (e.persisted) {
	              var loadingElements = document.querySelectorAll('.' + lazySizesCfg.loadingClass);
	              if (loadingElements.length && loadingElements.forEach) {
	                requestAnimationFrame(function () {
	                  loadingElements.forEach(function (img) {
	                    if (img.complete) {
	                      unveilElement(img);
	                    }
	                  });
	                });
	              }
	            }
	          });
	          if (window.MutationObserver) {
	            new MutationObserver(throttledCheckElements).observe(docElem, {
	              childList: true,
	              subtree: true,
	              attributes: true
	            });
	          } else {
	            docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);
	            docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);
	            setInterval(throttledCheckElements, 999);
	          }
	          addEventListener('hashchange', throttledCheckElements, true);

	          //, 'fullscreenchange'
	          ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend'].forEach(function (name) {
	            document[_addEventListener](name, throttledCheckElements, true);
	          });
	          if (/d$|^c/.test(document.readyState)) {
	            onload();
	          } else {
	            addEventListener('load', onload);
	            document[_addEventListener]('DOMContentLoaded', throttledCheckElements);
	            setTimeout(onload, 20000);
	          }
	          if (lazysizes.elements.length) {
	            checkElements();
	            rAF._lsFlush();
	          } else {
	            throttledCheckElements();
	          }
	        },
	        checkElems: throttledCheckElements,
	        unveil: unveilElement,
	        _aLSL: altLoadmodeScrollListner
	      };
	    }();
	    var autoSizer = function () {
	      var autosizesElems;
	      var sizeElement = rAFIt(function (elem, parent, event, width) {
	        var sources, i, len;
	        elem._lazysizesWidth = width;
	        width += 'px';
	        elem.setAttribute('sizes', width);
	        if (regPicture.test(parent.nodeName || '')) {
	          sources = parent.getElementsByTagName('source');
	          for (i = 0, len = sources.length; i < len; i++) {
	            sources[i].setAttribute('sizes', width);
	          }
	        }
	        if (!event.detail.dataAttr) {
	          updatePolyfill(elem, event.detail);
	        }
	      });
	      /**
	       *
	       * @param elem {Element}
	       * @param dataAttr
	       * @param [width] { number }
	       */
	      var getSizeElement = function (elem, dataAttr, width) {
	        var event;
	        var parent = elem.parentNode;
	        if (parent) {
	          width = getWidth(elem, parent, width);
	          event = triggerEvent(elem, 'lazybeforesizes', {
	            width: width,
	            dataAttr: !!dataAttr
	          });
	          if (!event.defaultPrevented) {
	            width = event.detail.width;
	            if (width && width !== elem._lazysizesWidth) {
	              sizeElement(elem, parent, event, width);
	            }
	          }
	        }
	      };
	      var updateElementsSizes = function () {
	        var i;
	        var len = autosizesElems.length;
	        if (len) {
	          i = 0;
	          for (; i < len; i++) {
	            getSizeElement(autosizesElems[i]);
	          }
	        }
	      };
	      var debouncedUpdateElementsSizes = debounce(updateElementsSizes);
	      return {
	        _: function () {
	          autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);
	          addEventListener('resize', debouncedUpdateElementsSizes);
	        },
	        checkElems: debouncedUpdateElementsSizes,
	        updateElem: getSizeElement
	      };
	    }();
	    var init = function () {
	      if (!init.i && document.getElementsByClassName) {
	        init.i = true;
	        autoSizer._();
	        loader._();
	      }
	    };
	    setTimeout(function () {
	      if (lazySizesCfg.init) {
	        init();
	      }
	    });
	    lazysizes = {
	      /**
	       * @type { LazySizesConfigPartial }
	       */
	      cfg: lazySizesCfg,
	      autoSizer: autoSizer,
	      loader: loader,
	      init: init,
	      uP: updatePolyfill,
	      aC: addClass,
	      rC: removeClass,
	      hC: hasClass,
	      fire: triggerEvent,
	      gW: getWidth,
	      rAF: rAF
	    };
	    return lazysizes;
	  });
	})(lazysizes);
	lazysizes.exports;

	var collapse = {exports: {}};

	var baseComponent = {exports: {}};

	var data$1 = {exports: {}};

	/*!
	  * Bootstrap data.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	data$1.exports;
	var hasRequiredData;
	function requireData() {
	  if (hasRequiredData) return data$1.exports;
	  hasRequiredData = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory() ;
	    })(commonjsGlobal$1, function () {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap dom/data.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const elementMap = new Map();
	      const data = {
	        set(element, key, instance) {
	          if (!elementMap.has(element)) {
	            elementMap.set(element, new Map());
	          }
	          const instanceMap = elementMap.get(element);

	          // make it clear we only want one instance per element
	          // can be removed later when multiple key/instances are fine to be used
	          if (!instanceMap.has(key) && instanceMap.size !== 0) {
	            // eslint-disable-next-line no-console
	            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
	            return;
	          }
	          instanceMap.set(key, instance);
	        },
	        get(element, key) {
	          if (elementMap.has(element)) {
	            return elementMap.get(element).get(key) || null;
	          }
	          return null;
	        },
	        remove(element, key) {
	          if (!elementMap.has(element)) {
	            return;
	          }
	          const instanceMap = elementMap.get(element);
	          instanceMap.delete(key);

	          // free up element references if there are no instances left for an element
	          if (instanceMap.size === 0) {
	            elementMap.delete(element);
	          }
	        }
	      };
	      return data;
	    });
	  })(data$1, data$1.exports);
	  return data$1.exports;
	}

	var eventHandler = {exports: {}};

	var util$1 = {exports: {}};

	/*!
	  * Bootstrap index.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	util$1.exports;
	var hasRequiredUtil$1;
	function requireUtil$1() {
	  if (hasRequiredUtil$1) return util$1.exports;
	  hasRequiredUtil$1 = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      factory(exports) ;
	    })(commonjsGlobal$1, function (exports) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/index.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */
	      const MAX_UID = 1000000;
	      const MILLISECONDS_MULTIPLIER = 1000;
	      const TRANSITION_END = 'transitionend';

	      /**
	       * Properly escape IDs selectors to handle weird IDs
	       * @param {string} selector
	       * @returns {string}
	       */
	      const parseSelector = selector => {
	        if (selector && window.CSS && window.CSS.escape) {
	          // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
	          selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
	        }
	        return selector;
	      };

	      // Shout-out Angus Croll (https://goo.gl/pxwQGp)
	      const toType = object => {
	        if (object === null || object === undefined) {
	          return `${object}`;
	        }
	        return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
	      };

	      /**
	       * Public Util API
	       */

	      const getUID = prefix => {
	        do {
	          prefix += Math.floor(Math.random() * MAX_UID);
	        } while (document.getElementById(prefix));
	        return prefix;
	      };
	      const getTransitionDurationFromElement = element => {
	        if (!element) {
	          return 0;
	        }

	        // Get transition-duration of the element
	        let {
	          transitionDuration,
	          transitionDelay
	        } = window.getComputedStyle(element);
	        const floatTransitionDuration = Number.parseFloat(transitionDuration);
	        const floatTransitionDelay = Number.parseFloat(transitionDelay);

	        // Return 0 if element or transition duration is not found
	        if (!floatTransitionDuration && !floatTransitionDelay) {
	          return 0;
	        }

	        // If multiple durations are defined, take the first
	        transitionDuration = transitionDuration.split(',')[0];
	        transitionDelay = transitionDelay.split(',')[0];
	        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
	      };
	      const triggerTransitionEnd = element => {
	        element.dispatchEvent(new Event(TRANSITION_END));
	      };
	      const isElement = object => {
	        if (!object || typeof object !== 'object') {
	          return false;
	        }
	        if (typeof object.jquery !== 'undefined') {
	          object = object[0];
	        }
	        return typeof object.nodeType !== 'undefined';
	      };
	      const getElement = object => {
	        // it's a jQuery object or a node element
	        if (isElement(object)) {
	          return object.jquery ? object[0] : object;
	        }
	        if (typeof object === 'string' && object.length > 0) {
	          return document.querySelector(parseSelector(object));
	        }
	        return null;
	      };
	      const isVisible = element => {
	        if (!isElement(element) || element.getClientRects().length === 0) {
	          return false;
	        }
	        const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
	        // Handle `details` element as its content may falsie appear visible when it is closed
	        const closedDetails = element.closest('details:not([open])');
	        if (!closedDetails) {
	          return elementIsVisible;
	        }
	        if (closedDetails !== element) {
	          const summary = element.closest('summary');
	          if (summary && summary.parentNode !== closedDetails) {
	            return false;
	          }
	          if (summary === null) {
	            return false;
	          }
	        }
	        return elementIsVisible;
	      };
	      const isDisabled = element => {
	        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
	          return true;
	        }
	        if (element.classList.contains('disabled')) {
	          return true;
	        }
	        if (typeof element.disabled !== 'undefined') {
	          return element.disabled;
	        }
	        return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
	      };
	      const findShadowRoot = element => {
	        if (!document.documentElement.attachShadow) {
	          return null;
	        }

	        // Can find the shadow root otherwise it'll return the document
	        if (typeof element.getRootNode === 'function') {
	          const root = element.getRootNode();
	          return root instanceof ShadowRoot ? root : null;
	        }
	        if (element instanceof ShadowRoot) {
	          return element;
	        }

	        // when we don't find a shadow root
	        if (!element.parentNode) {
	          return null;
	        }
	        return findShadowRoot(element.parentNode);
	      };
	      const noop = () => {};

	      /**
	       * Trick to restart an element's animation
	       *
	       * @param {HTMLElement} element
	       * @return void
	       *
	       * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
	       */
	      const reflow = element => {
	        element.offsetHeight; // eslint-disable-line no-unused-expressions
	      };
	      const getjQuery = () => {
	        if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
	          return window.jQuery;
	        }
	        return null;
	      };
	      const DOMContentLoadedCallbacks = [];
	      const onDOMContentLoaded = callback => {
	        if (document.readyState === 'loading') {
	          // add listener on the first call when the document is in loading state
	          if (!DOMContentLoadedCallbacks.length) {
	            document.addEventListener('DOMContentLoaded', () => {
	              for (const callback of DOMContentLoadedCallbacks) {
	                callback();
	              }
	            });
	          }
	          DOMContentLoadedCallbacks.push(callback);
	        } else {
	          callback();
	        }
	      };
	      const isRTL = () => document.documentElement.dir === 'rtl';
	      const defineJQueryPlugin = plugin => {
	        onDOMContentLoaded(() => {
	          const $ = getjQuery();
	          /* istanbul ignore if */
	          if ($) {
	            const name = plugin.NAME;
	            const JQUERY_NO_CONFLICT = $.fn[name];
	            $.fn[name] = plugin.jQueryInterface;
	            $.fn[name].Constructor = plugin;
	            $.fn[name].noConflict = () => {
	              $.fn[name] = JQUERY_NO_CONFLICT;
	              return plugin.jQueryInterface;
	            };
	          }
	        });
	      };
	      const execute = function (possibleCallback) {
	        let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	        let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : possibleCallback;
	        return typeof possibleCallback === 'function' ? possibleCallback(...args) : defaultValue;
	      };
	      const executeAfterTransition = function (callback, transitionElement) {
	        let waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	        if (!waitForTransition) {
	          execute(callback);
	          return;
	        }
	        const durationPadding = 5;
	        const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
	        let called = false;
	        const handler = _ref => {
	          let {
	            target
	          } = _ref;
	          if (target !== transitionElement) {
	            return;
	          }
	          called = true;
	          transitionElement.removeEventListener(TRANSITION_END, handler);
	          execute(callback);
	        };
	        transitionElement.addEventListener(TRANSITION_END, handler);
	        setTimeout(() => {
	          if (!called) {
	            triggerTransitionEnd(transitionElement);
	          }
	        }, emulatedDuration);
	      };

	      /**
	       * Return the previous/next element of a list.
	       *
	       * @param {array} list    The list of elements
	       * @param activeElement   The active element
	       * @param shouldGetNext   Choose to get next or previous element
	       * @param isCycleAllowed
	       * @return {Element|elem} The proper element
	       */
	      const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
	        const listLength = list.length;
	        let index = list.indexOf(activeElement);

	        // if the element does not exist in the list return an element
	        // depending on the direction and if cycle is allowed
	        if (index === -1) {
	          return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
	        }
	        index += shouldGetNext ? 1 : -1;
	        if (isCycleAllowed) {
	          index = (index + listLength) % listLength;
	        }
	        return list[Math.max(0, Math.min(index, listLength - 1))];
	      };
	      exports.defineJQueryPlugin = defineJQueryPlugin;
	      exports.execute = execute;
	      exports.executeAfterTransition = executeAfterTransition;
	      exports.findShadowRoot = findShadowRoot;
	      exports.getElement = getElement;
	      exports.getNextActiveElement = getNextActiveElement;
	      exports.getTransitionDurationFromElement = getTransitionDurationFromElement;
	      exports.getUID = getUID;
	      exports.getjQuery = getjQuery;
	      exports.isDisabled = isDisabled;
	      exports.isElement = isElement;
	      exports.isRTL = isRTL;
	      exports.isVisible = isVisible;
	      exports.noop = noop;
	      exports.onDOMContentLoaded = onDOMContentLoaded;
	      exports.parseSelector = parseSelector;
	      exports.reflow = reflow;
	      exports.toType = toType;
	      exports.triggerTransitionEnd = triggerTransitionEnd;
	      Object.defineProperty(exports, Symbol.toStringTag, {
	        value: 'Module'
	      });
	    });
	  })(util$1, util$1.exports);
	  return util$1.exports;
	}

	/*!
	  * Bootstrap event-handler.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	eventHandler.exports;
	var hasRequiredEventHandler;
	function requireEventHandler() {
	  if (hasRequiredEventHandler) return eventHandler.exports;
	  hasRequiredEventHandler = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireUtil$1()) ;
	    })(commonjsGlobal$1, function (index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap dom/event-handler.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
	      const stripNameRegex = /\..*/;
	      const stripUidRegex = /::\d+$/;
	      const eventRegistry = {}; // Events storage
	      let uidEvent = 1;
	      const customEvents = {
	        mouseenter: 'mouseover',
	        mouseleave: 'mouseout'
	      };
	      const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

	      /**
	       * Private methods
	       */

	      function makeEventUid(element, uid) {
	        return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
	      }
	      function getElementEvents(element) {
	        const uid = makeEventUid(element);
	        element.uidEvent = uid;
	        eventRegistry[uid] = eventRegistry[uid] || {};
	        return eventRegistry[uid];
	      }
	      function bootstrapHandler(element, fn) {
	        return function handler(event) {
	          hydrateObj(event, {
	            delegateTarget: element
	          });
	          if (handler.oneOff) {
	            EventHandler.off(element, event.type, fn);
	          }
	          return fn.apply(element, [event]);
	        };
	      }
	      function bootstrapDelegationHandler(element, selector, fn) {
	        return function handler(event) {
	          const domElements = element.querySelectorAll(selector);
	          for (let {
	            target
	          } = event; target && target !== this; target = target.parentNode) {
	            for (const domElement of domElements) {
	              if (domElement !== target) {
	                continue;
	              }
	              hydrateObj(event, {
	                delegateTarget: target
	              });
	              if (handler.oneOff) {
	                EventHandler.off(element, event.type, selector, fn);
	              }
	              return fn.apply(target, [event]);
	            }
	          }
	        };
	      }
	      function findHandler(events, callable) {
	        let delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	        return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
	      }
	      function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
	        const isDelegated = typeof handler === 'string';
	        // TODO: tooltip passes `false` instead of selector, so we need to check
	        const callable = isDelegated ? delegationFunction : handler || delegationFunction;
	        let typeEvent = getTypeEvent(originalTypeEvent);
	        if (!nativeEvents.has(typeEvent)) {
	          typeEvent = originalTypeEvent;
	        }
	        return [isDelegated, callable, typeEvent];
	      }
	      function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
	        if (typeof originalTypeEvent !== 'string' || !element) {
	          return;
	        }
	        let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);

	        // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
	        // this prevents the handler from being dispatched the same way as mouseover or mouseout does
	        if (originalTypeEvent in customEvents) {
	          const wrapFunction = fn => {
	            return function (event) {
	              if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
	                return fn.call(this, event);
	              }
	            };
	          };
	          callable = wrapFunction(callable);
	        }
	        const events = getElementEvents(element);
	        const handlers = events[typeEvent] || (events[typeEvent] = {});
	        const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
	        if (previousFunction) {
	          previousFunction.oneOff = previousFunction.oneOff && oneOff;
	          return;
	        }
	        const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
	        const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
	        fn.delegationSelector = isDelegated ? handler : null;
	        fn.callable = callable;
	        fn.oneOff = oneOff;
	        fn.uidEvent = uid;
	        handlers[uid] = fn;
	        element.addEventListener(typeEvent, fn, isDelegated);
	      }
	      function removeHandler(element, events, typeEvent, handler, delegationSelector) {
	        const fn = findHandler(events[typeEvent], handler, delegationSelector);
	        if (!fn) {
	          return;
	        }
	        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
	        delete events[typeEvent][fn.uidEvent];
	      }
	      function removeNamespacedHandlers(element, events, typeEvent, namespace) {
	        const storeElementEvent = events[typeEvent] || {};
	        for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
	          if (handlerKey.includes(namespace)) {
	            removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
	          }
	        }
	      }
	      function getTypeEvent(event) {
	        // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
	        event = event.replace(stripNameRegex, '');
	        return customEvents[event] || event;
	      }
	      const EventHandler = {
	        on(element, event, handler, delegationFunction) {
	          addHandler(element, event, handler, delegationFunction, false);
	        },
	        one(element, event, handler, delegationFunction) {
	          addHandler(element, event, handler, delegationFunction, true);
	        },
	        off(element, originalTypeEvent, handler, delegationFunction) {
	          if (typeof originalTypeEvent !== 'string' || !element) {
	            return;
	          }
	          const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
	          const inNamespace = typeEvent !== originalTypeEvent;
	          const events = getElementEvents(element);
	          const storeElementEvent = events[typeEvent] || {};
	          const isNamespace = originalTypeEvent.startsWith('.');
	          if (typeof callable !== 'undefined') {
	            // Simplest case: handler is passed, remove that listener ONLY.
	            if (!Object.keys(storeElementEvent).length) {
	              return;
	            }
	            removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
	            return;
	          }
	          if (isNamespace) {
	            for (const elementEvent of Object.keys(events)) {
	              removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
	            }
	          }
	          for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
	            const handlerKey = keyHandlers.replace(stripUidRegex, '');
	            if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
	              removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
	            }
	          }
	        },
	        trigger(element, event, args) {
	          if (typeof event !== 'string' || !element) {
	            return null;
	          }
	          const $ = index_js.getjQuery();
	          const typeEvent = getTypeEvent(event);
	          const inNamespace = event !== typeEvent;
	          let jQueryEvent = null;
	          let bubbles = true;
	          let nativeDispatch = true;
	          let defaultPrevented = false;
	          if (inNamespace && $) {
	            jQueryEvent = $.Event(event, args);
	            $(element).trigger(jQueryEvent);
	            bubbles = !jQueryEvent.isPropagationStopped();
	            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
	            defaultPrevented = jQueryEvent.isDefaultPrevented();
	          }
	          const evt = hydrateObj(new Event(event, {
	            bubbles,
	            cancelable: true
	          }), args);
	          if (defaultPrevented) {
	            evt.preventDefault();
	          }
	          if (nativeDispatch) {
	            element.dispatchEvent(evt);
	          }
	          if (evt.defaultPrevented && jQueryEvent) {
	            jQueryEvent.preventDefault();
	          }
	          return evt;
	        }
	      };
	      function hydrateObj(obj) {
	        let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        for (const [key, value] of Object.entries(meta)) {
	          try {
	            obj[key] = value;
	          } catch (_unused) {
	            Object.defineProperty(obj, key, {
	              configurable: true,
	              get() {
	                return value;
	              }
	            });
	          }
	        }
	        return obj;
	      }
	      return EventHandler;
	    });
	  })(eventHandler, eventHandler.exports);
	  return eventHandler.exports;
	}

	var config = {exports: {}};

	var manipulator = {exports: {}};

	/*!
	  * Bootstrap manipulator.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	manipulator.exports;
	var hasRequiredManipulator;
	function requireManipulator() {
	  if (hasRequiredManipulator) return manipulator.exports;
	  hasRequiredManipulator = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory() ;
	    })(commonjsGlobal$1, function () {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap dom/manipulator.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */
	      function normalizeData(value) {
	        if (value === 'true') {
	          return true;
	        }
	        if (value === 'false') {
	          return false;
	        }
	        if (value === Number(value).toString()) {
	          return Number(value);
	        }
	        if (value === '' || value === 'null') {
	          return null;
	        }
	        if (typeof value !== 'string') {
	          return value;
	        }
	        try {
	          return JSON.parse(decodeURIComponent(value));
	        } catch (_unused) {
	          return value;
	        }
	      }
	      function normalizeDataKey(key) {
	        return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
	      }
	      const Manipulator = {
	        setDataAttribute(element, key, value) {
	          element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
	        },
	        removeDataAttribute(element, key) {
	          element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
	        },
	        getDataAttributes(element) {
	          if (!element) {
	            return {};
	          }
	          const attributes = {};
	          const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
	          for (const key of bsKeys) {
	            let pureKey = key.replace(/^bs/, '');
	            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
	            attributes[pureKey] = normalizeData(element.dataset[key]);
	          }
	          return attributes;
	        },
	        getDataAttribute(element, key) {
	          return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
	        }
	      };
	      return Manipulator;
	    });
	  })(manipulator, manipulator.exports);
	  return manipulator.exports;
	}

	/*!
	  * Bootstrap config.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	config.exports;
	var hasRequiredConfig;
	function requireConfig() {
	  if (hasRequiredConfig) return config.exports;
	  hasRequiredConfig = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireManipulator(), requireUtil$1()) ;
	    })(commonjsGlobal$1, function (Manipulator, index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/config.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Class definition
	       */
	      class Config {
	        // Getters
	        static get Default() {
	          return {};
	        }
	        static get DefaultType() {
	          return {};
	        }
	        static get NAME() {
	          throw new Error('You have to implement the static method "NAME", for each component!');
	        }
	        _getConfig(config) {
	          config = this._mergeConfigObj(config);
	          config = this._configAfterMerge(config);
	          this._typeCheckConfig(config);
	          return config;
	        }
	        _configAfterMerge(config) {
	          return config;
	        }
	        _mergeConfigObj(config, element) {
	          const jsonConfig = index_js.isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

	          return {
	            ...this.constructor.Default,
	            ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
	            ...(index_js.isElement(element) ? Manipulator.getDataAttributes(element) : {}),
	            ...(typeof config === 'object' ? config : {})
	          };
	        }
	        _typeCheckConfig(config) {
	          let configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;
	          for (const [property, expectedTypes] of Object.entries(configTypes)) {
	            const value = config[property];
	            const valueType = index_js.isElement(value) ? 'element' : index_js.toType(value);
	            if (!new RegExp(expectedTypes).test(valueType)) {
	              throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
	            }
	          }
	        }
	      }
	      return Config;
	    });
	  })(config, config.exports);
	  return config.exports;
	}

	/*!
	  * Bootstrap base-component.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	baseComponent.exports;
	var hasRequiredBaseComponent;
	function requireBaseComponent() {
	  if (hasRequiredBaseComponent) return baseComponent.exports;
	  hasRequiredBaseComponent = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireData(), requireEventHandler(), requireConfig(), requireUtil$1()) ;
	    })(commonjsGlobal$1, function (Data, EventHandler, Config, index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap base-component.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const VERSION = '5.3.3';

	      /**
	       * Class definition
	       */

	      class BaseComponent extends Config {
	        constructor(element, config) {
	          super();
	          element = index_js.getElement(element);
	          if (!element) {
	            return;
	          }
	          this._element = element;
	          this._config = this._getConfig(config);
	          Data.set(this._element, this.constructor.DATA_KEY, this);
	        }

	        // Public
	        dispose() {
	          Data.remove(this._element, this.constructor.DATA_KEY);
	          EventHandler.off(this._element, this.constructor.EVENT_KEY);
	          for (const propertyName of Object.getOwnPropertyNames(this)) {
	            this[propertyName] = null;
	          }
	        }
	        _queueCallback(callback, element) {
	          let isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	          index_js.executeAfterTransition(callback, element, isAnimated);
	        }
	        _getConfig(config) {
	          config = this._mergeConfigObj(config, this._element);
	          config = this._configAfterMerge(config);
	          this._typeCheckConfig(config);
	          return config;
	        }

	        // Static
	        static getInstance(element) {
	          return Data.get(index_js.getElement(element), this.DATA_KEY);
	        }
	        static getOrCreateInstance(element) {
	          let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	          return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
	        }
	        static get VERSION() {
	          return VERSION;
	        }
	        static get DATA_KEY() {
	          return `bs.${this.NAME}`;
	        }
	        static get EVENT_KEY() {
	          return `.${this.DATA_KEY}`;
	        }
	        static eventName(name) {
	          return `${name}${this.EVENT_KEY}`;
	        }
	      }
	      return BaseComponent;
	    });
	  })(baseComponent, baseComponent.exports);
	  return baseComponent.exports;
	}

	var selectorEngine = {exports: {}};

	/*!
	  * Bootstrap selector-engine.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	selectorEngine.exports;
	var hasRequiredSelectorEngine;
	function requireSelectorEngine() {
	  if (hasRequiredSelectorEngine) return selectorEngine.exports;
	  hasRequiredSelectorEngine = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireUtil$1()) ;
	    })(commonjsGlobal$1, function (index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap dom/selector-engine.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */
	      const getSelector = element => {
	        let selector = element.getAttribute('data-bs-target');
	        if (!selector || selector === '#') {
	          let hrefAttribute = element.getAttribute('href');

	          // The only valid content that could double as a selector are IDs or classes,
	          // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
	          // `document.querySelector` will rightfully complain it is invalid.
	          // See https://github.com/twbs/bootstrap/issues/32273
	          if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
	            return null;
	          }

	          // Just in case some CMS puts out a full URL with the anchor appended
	          if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
	            hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
	          }
	          selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
	        }
	        return selector ? selector.split(',').map(sel => index_js.parseSelector(sel)).join(',') : null;
	      };
	      const SelectorEngine = {
	        find(selector) {
	          let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
	          return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
	        },
	        findOne(selector) {
	          let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
	          return Element.prototype.querySelector.call(element, selector);
	        },
	        children(element, selector) {
	          return [].concat(...element.children).filter(child => child.matches(selector));
	        },
	        parents(element, selector) {
	          const parents = [];
	          let ancestor = element.parentNode.closest(selector);
	          while (ancestor) {
	            parents.push(ancestor);
	            ancestor = ancestor.parentNode.closest(selector);
	          }
	          return parents;
	        },
	        prev(element, selector) {
	          let previous = element.previousElementSibling;
	          while (previous) {
	            if (previous.matches(selector)) {
	              return [previous];
	            }
	            previous = previous.previousElementSibling;
	          }
	          return [];
	        },
	        // TODO: this is now unused; remove later along with prev()
	        next(element, selector) {
	          let next = element.nextElementSibling;
	          while (next) {
	            if (next.matches(selector)) {
	              return [next];
	            }
	            next = next.nextElementSibling;
	          }
	          return [];
	        },
	        focusableChildren(element) {
	          const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
	          return this.find(focusables, element).filter(el => !index_js.isDisabled(el) && index_js.isVisible(el));
	        },
	        getSelectorFromElement(element) {
	          const selector = getSelector(element);
	          if (selector) {
	            return SelectorEngine.findOne(selector) ? selector : null;
	          }
	          return null;
	        },
	        getElementFromSelector(element) {
	          const selector = getSelector(element);
	          return selector ? SelectorEngine.findOne(selector) : null;
	        },
	        getMultipleElementsFromSelector(element) {
	          const selector = getSelector(element);
	          return selector ? SelectorEngine.find(selector) : [];
	        }
	      };
	      return SelectorEngine;
	    });
	  })(selectorEngine, selectorEngine.exports);
	  return selectorEngine.exports;
	}

	/*!
	  * Bootstrap collapse.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	collapse.exports;
	(function (module, exports) {
	  (function (global, factory) {
	    module.exports = factory(requireBaseComponent(), requireEventHandler(), requireSelectorEngine(), requireUtil$1()) ;
	  })(commonjsGlobal$1, function (BaseComponent, EventHandler, SelectorEngine, index_js) {

	    /**
	     * --------------------------------------------------------------------------
	     * Bootstrap collapse.js
	     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	     * --------------------------------------------------------------------------
	     */

	    /**
	     * Constants
	     */
	    const NAME = 'collapse';
	    const DATA_KEY = 'bs.collapse';
	    const EVENT_KEY = `.${DATA_KEY}`;
	    const DATA_API_KEY = '.data-api';
	    const EVENT_SHOW = `show${EVENT_KEY}`;
	    const EVENT_SHOWN = `shown${EVENT_KEY}`;
	    const EVENT_HIDE = `hide${EVENT_KEY}`;
	    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
	    const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
	    const CLASS_NAME_SHOW = 'show';
	    const CLASS_NAME_COLLAPSE = 'collapse';
	    const CLASS_NAME_COLLAPSING = 'collapsing';
	    const CLASS_NAME_COLLAPSED = 'collapsed';
	    const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
	    const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
	    const WIDTH = 'width';
	    const HEIGHT = 'height';
	    const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
	    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="collapse"]';
	    const Default = {
	      parent: null,
	      toggle: true
	    };
	    const DefaultType = {
	      parent: '(null|element)',
	      toggle: 'boolean'
	    };

	    /**
	     * Class definition
	     */

	    class Collapse extends BaseComponent {
	      constructor(element, config) {
	        super(element, config);
	        this._isTransitioning = false;
	        this._triggerArray = [];
	        const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE);
	        for (const elem of toggleList) {
	          const selector = SelectorEngine.getSelectorFromElement(elem);
	          const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
	          if (selector !== null && filterElement.length) {
	            this._triggerArray.push(elem);
	          }
	        }
	        this._initializeChildren();
	        if (!this._config.parent) {
	          this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
	        }
	        if (this._config.toggle) {
	          this.toggle();
	        }
	      }

	      // Getters
	      static get Default() {
	        return Default;
	      }
	      static get DefaultType() {
	        return DefaultType;
	      }
	      static get NAME() {
	        return NAME;
	      }

	      // Public
	      toggle() {
	        if (this._isShown()) {
	          this.hide();
	        } else {
	          this.show();
	        }
	      }
	      show() {
	        if (this._isTransitioning || this._isShown()) {
	          return;
	        }
	        let activeChildren = [];

	        // find active children
	        if (this._config.parent) {
	          activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
	            toggle: false
	          }));
	        }
	        if (activeChildren.length && activeChildren[0]._isTransitioning) {
	          return;
	        }
	        const startEvent = EventHandler.trigger(this._element, EVENT_SHOW);
	        if (startEvent.defaultPrevented) {
	          return;
	        }
	        for (const activeInstance of activeChildren) {
	          activeInstance.hide();
	        }
	        const dimension = this._getDimension();
	        this._element.classList.remove(CLASS_NAME_COLLAPSE);
	        this._element.classList.add(CLASS_NAME_COLLAPSING);
	        this._element.style[dimension] = 0;
	        this._addAriaAndCollapsedClass(this._triggerArray, true);
	        this._isTransitioning = true;
	        const complete = () => {
	          this._isTransitioning = false;
	          this._element.classList.remove(CLASS_NAME_COLLAPSING);
	          this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);
	          this._element.style[dimension] = '';
	          EventHandler.trigger(this._element, EVENT_SHOWN);
	        };
	        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
	        const scrollSize = `scroll${capitalizedDimension}`;
	        this._queueCallback(complete, this._element, true);
	        this._element.style[dimension] = `${this._element[scrollSize]}px`;
	      }
	      hide() {
	        if (this._isTransitioning || !this._isShown()) {
	          return;
	        }
	        const startEvent = EventHandler.trigger(this._element, EVENT_HIDE);
	        if (startEvent.defaultPrevented) {
	          return;
	        }
	        const dimension = this._getDimension();
	        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
	        index_js.reflow(this._element);
	        this._element.classList.add(CLASS_NAME_COLLAPSING);
	        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);
	        for (const trigger of this._triggerArray) {
	          const element = SelectorEngine.getElementFromSelector(trigger);
	          if (element && !this._isShown(element)) {
	            this._addAriaAndCollapsedClass([trigger], false);
	          }
	        }
	        this._isTransitioning = true;
	        const complete = () => {
	          this._isTransitioning = false;
	          this._element.classList.remove(CLASS_NAME_COLLAPSING);
	          this._element.classList.add(CLASS_NAME_COLLAPSE);
	          EventHandler.trigger(this._element, EVENT_HIDDEN);
	        };
	        this._element.style[dimension] = '';
	        this._queueCallback(complete, this._element, true);
	      }
	      _isShown() {
	        let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;
	        return element.classList.contains(CLASS_NAME_SHOW);
	      }

	      // Private
	      _configAfterMerge(config) {
	        config.toggle = Boolean(config.toggle); // Coerce string values
	        config.parent = index_js.getElement(config.parent);
	        return config;
	      }
	      _getDimension() {
	        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
	      }
	      _initializeChildren() {
	        if (!this._config.parent) {
	          return;
	        }
	        const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE);
	        for (const element of children) {
	          const selected = SelectorEngine.getElementFromSelector(element);
	          if (selected) {
	            this._addAriaAndCollapsedClass([element], this._isShown(selected));
	          }
	        }
	      }
	      _getFirstLevelChildren(selector) {
	        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
	        // remove children if greater depth
	        return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
	      }
	      _addAriaAndCollapsedClass(triggerArray, isOpen) {
	        if (!triggerArray.length) {
	          return;
	        }
	        for (const element of triggerArray) {
	          element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
	          element.setAttribute('aria-expanded', isOpen);
	        }
	      }

	      // Static
	      static jQueryInterface(config) {
	        const _config = {};
	        if (typeof config === 'string' && /show|hide/.test(config)) {
	          _config.toggle = false;
	        }
	        return this.each(function () {
	          const data = Collapse.getOrCreateInstance(this, _config);
	          if (typeof config === 'string') {
	            if (typeof data[config] === 'undefined') {
	              throw new TypeError(`No method named "${config}"`);
	            }
	            data[config]();
	          }
	        });
	      }
	    }

	    /**
	     * Data API implementation
	     */

	    EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
	      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
	      if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
	        event.preventDefault();
	      }
	      for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
	        Collapse.getOrCreateInstance(element, {
	          toggle: false
	        }).toggle();
	      }
	    });

	    /**
	     * jQuery
	     */

	    index_js.defineJQueryPlugin(Collapse);
	    return Collapse;
	  });
	})(collapse, collapse.exports);
	collapse.exports;

	var modal = {exports: {}};

	var backdrop = {exports: {}};

	/*!
	  * Bootstrap backdrop.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	backdrop.exports;
	var hasRequiredBackdrop;
	function requireBackdrop() {
	  if (hasRequiredBackdrop) return backdrop.exports;
	  hasRequiredBackdrop = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireEventHandler(), requireConfig(), requireUtil$1()) ;
	    })(commonjsGlobal$1, function (EventHandler, Config, index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/backdrop.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const NAME = 'backdrop';
	      const CLASS_NAME_FADE = 'fade';
	      const CLASS_NAME_SHOW = 'show';
	      const EVENT_MOUSEDOWN = `mousedown.bs.${NAME}`;
	      const Default = {
	        className: 'modal-backdrop',
	        clickCallback: null,
	        isAnimated: false,
	        isVisible: true,
	        // if false, we use the backdrop helper without adding any element to the dom
	        rootElement: 'body' // give the choice to place backdrop under different elements
	      };
	      const DefaultType = {
	        className: 'string',
	        clickCallback: '(function|null)',
	        isAnimated: 'boolean',
	        isVisible: 'boolean',
	        rootElement: '(element|string)'
	      };

	      /**
	       * Class definition
	       */

	      class Backdrop extends Config {
	        constructor(config) {
	          super();
	          this._config = this._getConfig(config);
	          this._isAppended = false;
	          this._element = null;
	        }

	        // Getters
	        static get Default() {
	          return Default;
	        }
	        static get DefaultType() {
	          return DefaultType;
	        }
	        static get NAME() {
	          return NAME;
	        }

	        // Public
	        show(callback) {
	          if (!this._config.isVisible) {
	            index_js.execute(callback);
	            return;
	          }
	          this._append();
	          const element = this._getElement();
	          if (this._config.isAnimated) {
	            index_js.reflow(element);
	          }
	          element.classList.add(CLASS_NAME_SHOW);
	          this._emulateAnimation(() => {
	            index_js.execute(callback);
	          });
	        }
	        hide(callback) {
	          if (!this._config.isVisible) {
	            index_js.execute(callback);
	            return;
	          }
	          this._getElement().classList.remove(CLASS_NAME_SHOW);
	          this._emulateAnimation(() => {
	            this.dispose();
	            index_js.execute(callback);
	          });
	        }
	        dispose() {
	          if (!this._isAppended) {
	            return;
	          }
	          EventHandler.off(this._element, EVENT_MOUSEDOWN);
	          this._element.remove();
	          this._isAppended = false;
	        }

	        // Private
	        _getElement() {
	          if (!this._element) {
	            const backdrop = document.createElement('div');
	            backdrop.className = this._config.className;
	            if (this._config.isAnimated) {
	              backdrop.classList.add(CLASS_NAME_FADE);
	            }
	            this._element = backdrop;
	          }
	          return this._element;
	        }
	        _configAfterMerge(config) {
	          // use getElement() with the default "body" to get a fresh Element on each instantiation
	          config.rootElement = index_js.getElement(config.rootElement);
	          return config;
	        }
	        _append() {
	          if (this._isAppended) {
	            return;
	          }
	          const element = this._getElement();
	          this._config.rootElement.append(element);
	          EventHandler.on(element, EVENT_MOUSEDOWN, () => {
	            index_js.execute(this._config.clickCallback);
	          });
	          this._isAppended = true;
	        }
	        _emulateAnimation(callback) {
	          index_js.executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
	        }
	      }
	      return Backdrop;
	    });
	  })(backdrop, backdrop.exports);
	  return backdrop.exports;
	}

	var componentFunctions = {exports: {}};

	/*!
	  * Bootstrap component-functions.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	componentFunctions.exports;
	var hasRequiredComponentFunctions;
	function requireComponentFunctions() {
	  if (hasRequiredComponentFunctions) return componentFunctions.exports;
	  hasRequiredComponentFunctions = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      factory(exports, requireEventHandler(), requireSelectorEngine(), requireUtil$1()) ;
	    })(commonjsGlobal$1, function (exports, EventHandler, SelectorEngine, index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/component-functions.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */
	      const enableDismissTrigger = function (component) {
	        let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';
	        const clickEvent = `click.dismiss${component.EVENT_KEY}`;
	        const name = component.NAME;
	        EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
	          if (['A', 'AREA'].includes(this.tagName)) {
	            event.preventDefault();
	          }
	          if (index_js.isDisabled(this)) {
	            return;
	          }
	          const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
	          const instance = component.getOrCreateInstance(target);

	          // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
	          instance[method]();
	        });
	      };
	      exports.enableDismissTrigger = enableDismissTrigger;
	      Object.defineProperty(exports, Symbol.toStringTag, {
	        value: 'Module'
	      });
	    });
	  })(componentFunctions, componentFunctions.exports);
	  return componentFunctions.exports;
	}

	var focustrap = {exports: {}};

	/*!
	  * Bootstrap focustrap.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	focustrap.exports;
	var hasRequiredFocustrap;
	function requireFocustrap() {
	  if (hasRequiredFocustrap) return focustrap.exports;
	  hasRequiredFocustrap = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireEventHandler(), requireSelectorEngine(), requireConfig()) ;
	    })(commonjsGlobal$1, function (EventHandler, SelectorEngine, Config) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/focustrap.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const NAME = 'focustrap';
	      const DATA_KEY = 'bs.focustrap';
	      const EVENT_KEY = `.${DATA_KEY}`;
	      const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
	      const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY}`;
	      const TAB_KEY = 'Tab';
	      const TAB_NAV_FORWARD = 'forward';
	      const TAB_NAV_BACKWARD = 'backward';
	      const Default = {
	        autofocus: true,
	        trapElement: null // The element to trap focus inside of
	      };
	      const DefaultType = {
	        autofocus: 'boolean',
	        trapElement: 'element'
	      };

	      /**
	       * Class definition
	       */

	      class FocusTrap extends Config {
	        constructor(config) {
	          super();
	          this._config = this._getConfig(config);
	          this._isActive = false;
	          this._lastTabNavDirection = null;
	        }

	        // Getters
	        static get Default() {
	          return Default;
	        }
	        static get DefaultType() {
	          return DefaultType;
	        }
	        static get NAME() {
	          return NAME;
	        }

	        // Public
	        activate() {
	          if (this._isActive) {
	            return;
	          }
	          if (this._config.autofocus) {
	            this._config.trapElement.focus();
	          }
	          EventHandler.off(document, EVENT_KEY); // guard against infinite focus loop
	          EventHandler.on(document, EVENT_FOCUSIN, event => this._handleFocusin(event));
	          EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
	          this._isActive = true;
	        }
	        deactivate() {
	          if (!this._isActive) {
	            return;
	          }
	          this._isActive = false;
	          EventHandler.off(document, EVENT_KEY);
	        }

	        // Private
	        _handleFocusin(event) {
	          const {
	            trapElement
	          } = this._config;
	          if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
	            return;
	          }
	          const elements = SelectorEngine.focusableChildren(trapElement);
	          if (elements.length === 0) {
	            trapElement.focus();
	          } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
	            elements[elements.length - 1].focus();
	          } else {
	            elements[0].focus();
	          }
	        }
	        _handleKeydown(event) {
	          if (event.key !== TAB_KEY) {
	            return;
	          }
	          this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
	        }
	      }
	      return FocusTrap;
	    });
	  })(focustrap, focustrap.exports);
	  return focustrap.exports;
	}

	var scrollbar = {exports: {}};

	/*!
	  * Bootstrap scrollbar.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	scrollbar.exports;
	var hasRequiredScrollbar;
	function requireScrollbar() {
	  if (hasRequiredScrollbar) return scrollbar.exports;
	  hasRequiredScrollbar = 1;
	  (function (module, exports) {
	    (function (global, factory) {
	      module.exports = factory(requireManipulator(), requireSelectorEngine(), requireUtil$1()) ;
	    })(commonjsGlobal$1, function (Manipulator, SelectorEngine, index_js) {

	      /**
	       * --------------------------------------------------------------------------
	       * Bootstrap util/scrollBar.js
	       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	       * --------------------------------------------------------------------------
	       */

	      /**
	       * Constants
	       */
	      const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
	      const SELECTOR_STICKY_CONTENT = '.sticky-top';
	      const PROPERTY_PADDING = 'padding-right';
	      const PROPERTY_MARGIN = 'margin-right';

	      /**
	       * Class definition
	       */

	      class ScrollBarHelper {
	        constructor() {
	          this._element = document.body;
	        }

	        // Public
	        getWidth() {
	          // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
	          const documentWidth = document.documentElement.clientWidth;
	          return Math.abs(window.innerWidth - documentWidth);
	        }
	        hide() {
	          const width = this.getWidth();
	          this._disableOverFlow();
	          // give padding to element to balance the hidden scrollbar width
	          this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
	          // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
	          this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
	          this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
	        }
	        reset() {
	          this._resetElementAttributes(this._element, 'overflow');
	          this._resetElementAttributes(this._element, PROPERTY_PADDING);
	          this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
	          this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
	        }
	        isOverflowing() {
	          return this.getWidth() > 0;
	        }

	        // Private
	        _disableOverFlow() {
	          this._saveInitialAttribute(this._element, 'overflow');
	          this._element.style.overflow = 'hidden';
	        }
	        _setElementAttributes(selector, styleProperty, callback) {
	          const scrollbarWidth = this.getWidth();
	          const manipulationCallBack = element => {
	            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
	              return;
	            }
	            this._saveInitialAttribute(element, styleProperty);
	            const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
	            element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
	          };
	          this._applyManipulationCallback(selector, manipulationCallBack);
	        }
	        _saveInitialAttribute(element, styleProperty) {
	          const actualValue = element.style.getPropertyValue(styleProperty);
	          if (actualValue) {
	            Manipulator.setDataAttribute(element, styleProperty, actualValue);
	          }
	        }
	        _resetElementAttributes(selector, styleProperty) {
	          const manipulationCallBack = element => {
	            const value = Manipulator.getDataAttribute(element, styleProperty);
	            // We only want to remove the property if the value is `null`; the value can also be zero
	            if (value === null) {
	              element.style.removeProperty(styleProperty);
	              return;
	            }
	            Manipulator.removeDataAttribute(element, styleProperty);
	            element.style.setProperty(styleProperty, value);
	          };
	          this._applyManipulationCallback(selector, manipulationCallBack);
	        }
	        _applyManipulationCallback(selector, callBack) {
	          if (index_js.isElement(selector)) {
	            callBack(selector);
	            return;
	          }
	          for (const sel of SelectorEngine.find(selector, this._element)) {
	            callBack(sel);
	          }
	        }
	      }
	      return ScrollBarHelper;
	    });
	  })(scrollbar, scrollbar.exports);
	  return scrollbar.exports;
	}

	/*!
	  * Bootstrap modal.js v5.3.3 (https://getbootstrap.com/)
	  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	  */
	modal.exports;
	(function (module, exports) {
	  (function (global, factory) {
	    module.exports = factory(requireBaseComponent(), requireEventHandler(), requireSelectorEngine(), requireBackdrop(), requireComponentFunctions(), requireFocustrap(), requireUtil$1(), requireScrollbar()) ;
	  })(commonjsGlobal$1, function (BaseComponent, EventHandler, SelectorEngine, Backdrop, componentFunctions_js, FocusTrap, index_js, ScrollBarHelper) {

	    /**
	     * --------------------------------------------------------------------------
	     * Bootstrap modal.js
	     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
	     * --------------------------------------------------------------------------
	     */

	    /**
	     * Constants
	     */
	    const NAME = 'modal';
	    const DATA_KEY = 'bs.modal';
	    const EVENT_KEY = `.${DATA_KEY}`;
	    const DATA_API_KEY = '.data-api';
	    const ESCAPE_KEY = 'Escape';
	    const EVENT_HIDE = `hide${EVENT_KEY}`;
	    const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY}`;
	    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
	    const EVENT_SHOW = `show${EVENT_KEY}`;
	    const EVENT_SHOWN = `shown${EVENT_KEY}`;
	    const EVENT_RESIZE = `resize${EVENT_KEY}`;
	    const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;
	    const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY}`;
	    const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;
	    const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
	    const CLASS_NAME_OPEN = 'modal-open';
	    const CLASS_NAME_FADE = 'fade';
	    const CLASS_NAME_SHOW = 'show';
	    const CLASS_NAME_STATIC = 'modal-static';
	    const OPEN_SELECTOR = '.modal.show';
	    const SELECTOR_DIALOG = '.modal-dialog';
	    const SELECTOR_MODAL_BODY = '.modal-body';
	    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="modal"]';
	    const Default = {
	      backdrop: true,
	      focus: true,
	      keyboard: true
	    };
	    const DefaultType = {
	      backdrop: '(boolean|string)',
	      focus: 'boolean',
	      keyboard: 'boolean'
	    };

	    /**
	     * Class definition
	     */

	    class Modal extends BaseComponent {
	      constructor(element, config) {
	        super(element, config);
	        this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
	        this._backdrop = this._initializeBackDrop();
	        this._focustrap = this._initializeFocusTrap();
	        this._isShown = false;
	        this._isTransitioning = false;
	        this._scrollBar = new ScrollBarHelper();
	        this._addEventListeners();
	      }

	      // Getters
	      static get Default() {
	        return Default;
	      }
	      static get DefaultType() {
	        return DefaultType;
	      }
	      static get NAME() {
	        return NAME;
	      }

	      // Public
	      toggle(relatedTarget) {
	        return this._isShown ? this.hide() : this.show(relatedTarget);
	      }
	      show(relatedTarget) {
	        if (this._isShown || this._isTransitioning) {
	          return;
	        }
	        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW, {
	          relatedTarget
	        });
	        if (showEvent.defaultPrevented) {
	          return;
	        }
	        this._isShown = true;
	        this._isTransitioning = true;
	        this._scrollBar.hide();
	        document.body.classList.add(CLASS_NAME_OPEN);
	        this._adjustDialog();
	        this._backdrop.show(() => this._showElement(relatedTarget));
	      }
	      hide() {
	        if (!this._isShown || this._isTransitioning) {
	          return;
	        }
	        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
	        if (hideEvent.defaultPrevented) {
	          return;
	        }
	        this._isShown = false;
	        this._isTransitioning = true;
	        this._focustrap.deactivate();
	        this._element.classList.remove(CLASS_NAME_SHOW);
	        this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
	      }
	      dispose() {
	        EventHandler.off(window, EVENT_KEY);
	        EventHandler.off(this._dialog, EVENT_KEY);
	        this._backdrop.dispose();
	        this._focustrap.deactivate();
	        super.dispose();
	      }
	      handleUpdate() {
	        this._adjustDialog();
	      }

	      // Private
	      _initializeBackDrop() {
	        return new Backdrop({
	          isVisible: Boolean(this._config.backdrop),
	          // 'static' option will be translated to true, and booleans will keep their value,
	          isAnimated: this._isAnimated()
	        });
	      }
	      _initializeFocusTrap() {
	        return new FocusTrap({
	          trapElement: this._element
	        });
	      }
	      _showElement(relatedTarget) {
	        // try to append dynamic modal
	        if (!document.body.contains(this._element)) {
	          document.body.append(this._element);
	        }
	        this._element.style.display = 'block';
	        this._element.removeAttribute('aria-hidden');
	        this._element.setAttribute('aria-modal', true);
	        this._element.setAttribute('role', 'dialog');
	        this._element.scrollTop = 0;
	        const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
	        if (modalBody) {
	          modalBody.scrollTop = 0;
	        }
	        index_js.reflow(this._element);
	        this._element.classList.add(CLASS_NAME_SHOW);
	        const transitionComplete = () => {
	          if (this._config.focus) {
	            this._focustrap.activate();
	          }
	          this._isTransitioning = false;
	          EventHandler.trigger(this._element, EVENT_SHOWN, {
	            relatedTarget
	          });
	        };
	        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
	      }
	      _addEventListeners() {
	        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
	          if (event.key !== ESCAPE_KEY) {
	            return;
	          }
	          if (this._config.keyboard) {
	            this.hide();
	            return;
	          }
	          this._triggerBackdropTransition();
	        });
	        EventHandler.on(window, EVENT_RESIZE, () => {
	          if (this._isShown && !this._isTransitioning) {
	            this._adjustDialog();
	          }
	        });
	        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
	          // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
	          EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
	            if (this._element !== event.target || this._element !== event2.target) {
	              return;
	            }
	            if (this._config.backdrop === 'static') {
	              this._triggerBackdropTransition();
	              return;
	            }
	            if (this._config.backdrop) {
	              this.hide();
	            }
	          });
	        });
	      }
	      _hideModal() {
	        this._element.style.display = 'none';
	        this._element.setAttribute('aria-hidden', true);
	        this._element.removeAttribute('aria-modal');
	        this._element.removeAttribute('role');
	        this._isTransitioning = false;
	        this._backdrop.hide(() => {
	          document.body.classList.remove(CLASS_NAME_OPEN);
	          this._resetAdjustments();
	          this._scrollBar.reset();
	          EventHandler.trigger(this._element, EVENT_HIDDEN);
	        });
	      }
	      _isAnimated() {
	        return this._element.classList.contains(CLASS_NAME_FADE);
	      }
	      _triggerBackdropTransition() {
	        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
	        if (hideEvent.defaultPrevented) {
	          return;
	        }
	        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
	        const initialOverflowY = this._element.style.overflowY;
	        // return if the following background transition hasn't yet completed
	        if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
	          return;
	        }
	        if (!isModalOverflowing) {
	          this._element.style.overflowY = 'hidden';
	        }
	        this._element.classList.add(CLASS_NAME_STATIC);
	        this._queueCallback(() => {
	          this._element.classList.remove(CLASS_NAME_STATIC);
	          this._queueCallback(() => {
	            this._element.style.overflowY = initialOverflowY;
	          }, this._dialog);
	        }, this._dialog);
	        this._element.focus();
	      }

	      /**
	       * The following methods are used to handle overflowing modals
	       */

	      _adjustDialog() {
	        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
	        const scrollbarWidth = this._scrollBar.getWidth();
	        const isBodyOverflowing = scrollbarWidth > 0;
	        if (isBodyOverflowing && !isModalOverflowing) {
	          const property = index_js.isRTL() ? 'paddingLeft' : 'paddingRight';
	          this._element.style[property] = `${scrollbarWidth}px`;
	        }
	        if (!isBodyOverflowing && isModalOverflowing) {
	          const property = index_js.isRTL() ? 'paddingRight' : 'paddingLeft';
	          this._element.style[property] = `${scrollbarWidth}px`;
	        }
	      }
	      _resetAdjustments() {
	        this._element.style.paddingLeft = '';
	        this._element.style.paddingRight = '';
	      }

	      // Static
	      static jQueryInterface(config, relatedTarget) {
	        return this.each(function () {
	          const data = Modal.getOrCreateInstance(this, config);
	          if (typeof config !== 'string') {
	            return;
	          }
	          if (typeof data[config] === 'undefined') {
	            throw new TypeError(`No method named "${config}"`);
	          }
	          data[config](relatedTarget);
	        });
	      }
	    }

	    /**
	     * Data API implementation
	     */

	    EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
	      const target = SelectorEngine.getElementFromSelector(this);
	      if (['A', 'AREA'].includes(this.tagName)) {
	        event.preventDefault();
	      }
	      EventHandler.one(target, EVENT_SHOW, showEvent => {
	        if (showEvent.defaultPrevented) {
	          // only register focus restorer if modal will actually get shown
	          return;
	        }
	        EventHandler.one(target, EVENT_HIDDEN, () => {
	          if (index_js.isVisible(this)) {
	            this.focus();
	          }
	        });
	      });

	      // avoid conflict when clicking modal toggler while another one is open
	      const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
	      if (alreadyOpen) {
	        Modal.getInstance(alreadyOpen).hide();
	      }
	      const data = Modal.getOrCreateInstance(target);
	      data.toggle(this);
	    });
	    componentFunctions_js.enableDismissTrigger(Modal);

	    /**
	     * jQuery
	     */

	    index_js.defineJQueryPlugin(Modal);
	    return Modal;
	  });
	})(modal, modal.exports);
	modal.exports;

	var jquery = {exports: {}};

	/*!
	 * jQuery JavaScript Library v3.2.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2017-03-20T18:59Z
	 */
	jquery.exports;
	(function (module) {
	  (function (global, factory) {

	    {
	      // For CommonJS and CommonJS-like environments where a proper `window`
	      // is present, execute the factory and get jQuery.
	      // For environments that do not have a `window` with a `document`
	      // (such as Node.js), expose a factory as module.exports.
	      // This accentuates the need for the creation of a real `window`.
	      // e.g. var jQuery = require("jquery")(window);
	      // See ticket #14549 for more info.
	      module.exports = global.document ? factory(global, true) : function (w) {
	        if (!w.document) {
	          throw new Error("jQuery requires a window with a document");
	        }
	        return factory(w);
	      };
	    }

	    // Pass this if window is not defined yet
	  })(typeof window !== "undefined" ? window : commonjsGlobal$1, function (window, noGlobal) {

	    var arr = [];
	    var document = window.document;
	    var getProto = Object.getPrototypeOf;
	    var slice = arr.slice;
	    var concat = arr.concat;
	    var push = arr.push;
	    var indexOf = arr.indexOf;
	    var class2type = {};
	    var toString = class2type.toString;
	    var hasOwn = class2type.hasOwnProperty;
	    var fnToString = hasOwn.toString;
	    var ObjectFunctionString = fnToString.call(Object);
	    var support = {};
	    function DOMEval(code, doc) {
	      doc = doc || document;
	      var script = doc.createElement("script");
	      script.text = code;
	      doc.head.appendChild(script).parentNode.removeChild(script);
	    }
	    /* global Symbol */
	    // Defining this global in .eslintrc.json would create a danger of using the global
	    // unguarded in another place, it seems safer to define global only for this module

	    var version = "3.2.1",
	      // Define a local copy of jQuery
	      jQuery = function (selector, context) {
	        // The jQuery object is actually just the init constructor 'enhanced'
	        // Need init if jQuery is called (just allow error to be thrown if not included)
	        return new jQuery.fn.init(selector, context);
	      },
	      // Support: Android <=4.0 only
	      // Make sure we trim BOM and NBSP
	      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	      // Matches dashed string for camelizing
	      rmsPrefix = /^-ms-/,
	      rdashAlpha = /-([a-z])/g,
	      // Used by jQuery.camelCase as callback to replace()
	      fcamelCase = function (all, letter) {
	        return letter.toUpperCase();
	      };
	    jQuery.fn = jQuery.prototype = {
	      // The current version of jQuery being used
	      jquery: version,
	      constructor: jQuery,
	      // The default length of a jQuery object is 0
	      length: 0,
	      toArray: function () {
	        return slice.call(this);
	      },
	      // Get the Nth element in the matched element set OR
	      // Get the whole matched element set as a clean array
	      get: function (num) {
	        // Return all the elements in a clean array
	        if (num == null) {
	          return slice.call(this);
	        }

	        // Return just the one element from the set
	        return num < 0 ? this[num + this.length] : this[num];
	      },
	      // Take an array of elements and push it onto the stack
	      // (returning the new matched element set)
	      pushStack: function (elems) {
	        // Build a new jQuery matched element set
	        var ret = jQuery.merge(this.constructor(), elems);

	        // Add the old object onto the stack (as a reference)
	        ret.prevObject = this;

	        // Return the newly-formed element set
	        return ret;
	      },
	      // Execute a callback for every element in the matched set.
	      each: function (callback) {
	        return jQuery.each(this, callback);
	      },
	      map: function (callback) {
	        return this.pushStack(jQuery.map(this, function (elem, i) {
	          return callback.call(elem, i, elem);
	        }));
	      },
	      slice: function () {
	        return this.pushStack(slice.apply(this, arguments));
	      },
	      first: function () {
	        return this.eq(0);
	      },
	      last: function () {
	        return this.eq(-1);
	      },
	      eq: function (i) {
	        var len = this.length,
	          j = +i + (i < 0 ? len : 0);
	        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
	      },
	      end: function () {
	        return this.prevObject || this.constructor();
	      },
	      // For internal use only.
	      // Behaves like an Array's method, not like a jQuery method.
	      push: push,
	      sort: arr.sort,
	      splice: arr.splice
	    };
	    jQuery.extend = jQuery.fn.extend = function () {
	      var options,
	        name,
	        src,
	        copy,
	        copyIsArray,
	        clone,
	        target = arguments[0] || {},
	        i = 1,
	        length = arguments.length,
	        deep = false;

	      // Handle a deep copy situation
	      if (typeof target === "boolean") {
	        deep = target;

	        // Skip the boolean and the target
	        target = arguments[i] || {};
	        i++;
	      }

	      // Handle case when target is a string or something (possible in deep copy)
	      if (typeof target !== "object" && !jQuery.isFunction(target)) {
	        target = {};
	      }

	      // Extend jQuery itself if only one argument is passed
	      if (i === length) {
	        target = this;
	        i--;
	      }
	      for (; i < length; i++) {
	        // Only deal with non-null/undefined values
	        if ((options = arguments[i]) != null) {
	          // Extend the base object
	          for (name in options) {
	            src = target[name];
	            copy = options[name];

	            // Prevent never-ending loop
	            if (target === copy) {
	              continue;
	            }

	            // Recurse if we're merging plain objects or arrays
	            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
	              if (copyIsArray) {
	                copyIsArray = false;
	                clone = src && Array.isArray(src) ? src : [];
	              } else {
	                clone = src && jQuery.isPlainObject(src) ? src : {};
	              }

	              // Never move original objects, clone them
	              target[name] = jQuery.extend(deep, clone, copy);

	              // Don't bring in undefined values
	            } else if (copy !== undefined) {
	              target[name] = copy;
	            }
	          }
	        }
	      }

	      // Return the modified object
	      return target;
	    };
	    jQuery.extend({
	      // Unique for each copy of jQuery on the page
	      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
	      // Assume jQuery is ready without the ready module
	      isReady: true,
	      error: function (msg) {
	        throw new Error(msg);
	      },
	      noop: function () {},
	      isFunction: function (obj) {
	        return jQuery.type(obj) === "function";
	      },
	      isWindow: function (obj) {
	        return obj != null && obj === obj.window;
	      },
	      isNumeric: function (obj) {
	        // As of jQuery 3.0, isNumeric is limited to
	        // strings and numbers (primitives or objects)
	        // that can be coerced to finite numbers (gh-2662)
	        var type = jQuery.type(obj);
	        return (type === "number" || type === "string") &&
	        // parseFloat NaNs numeric-cast false positives ("")
	        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	        // subtraction forces infinities to NaN
	        !isNaN(obj - parseFloat(obj));
	      },
	      isPlainObject: function (obj) {
	        var proto, Ctor;

	        // Detect obvious negatives
	        // Use toString instead of jQuery.type to catch host objects
	        if (!obj || toString.call(obj) !== "[object Object]") {
	          return false;
	        }
	        proto = getProto(obj);

	        // Objects with no prototype (e.g., `Object.create( null )`) are plain
	        if (!proto) {
	          return true;
	        }

	        // Objects with prototype are plain iff they were constructed by a global Object function
	        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
	        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
	      },
	      isEmptyObject: function (obj) {
	        /* eslint-disable no-unused-vars */
	        // See https://github.com/eslint/eslint/issues/6125
	        var name;
	        for (name in obj) {
	          return false;
	        }
	        return true;
	      },
	      type: function (obj) {
	        if (obj == null) {
	          return obj + "";
	        }

	        // Support: Android <=2.3 only (functionish RegExp)
	        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
	      },
	      // Evaluates a script in a global context
	      globalEval: function (code) {
	        DOMEval(code);
	      },
	      // Convert dashed to camelCase; used by the css and data modules
	      // Support: IE <=9 - 11, Edge 12 - 13
	      // Microsoft forgot to hump their vendor prefix (#9572)
	      camelCase: function (string) {
	        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
	      },
	      each: function (obj, callback) {
	        var length,
	          i = 0;
	        if (isArrayLike(obj)) {
	          length = obj.length;
	          for (; i < length; i++) {
	            if (callback.call(obj[i], i, obj[i]) === false) {
	              break;
	            }
	          }
	        } else {
	          for (i in obj) {
	            if (callback.call(obj[i], i, obj[i]) === false) {
	              break;
	            }
	          }
	        }
	        return obj;
	      },
	      // Support: Android <=4.0 only
	      trim: function (text) {
	        return text == null ? "" : (text + "").replace(rtrim, "");
	      },
	      // results is for internal usage only
	      makeArray: function (arr, results) {
	        var ret = results || [];
	        if (arr != null) {
	          if (isArrayLike(Object(arr))) {
	            jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
	          } else {
	            push.call(ret, arr);
	          }
	        }
	        return ret;
	      },
	      inArray: function (elem, arr, i) {
	        return arr == null ? -1 : indexOf.call(arr, elem, i);
	      },
	      // Support: Android <=4.0 only, PhantomJS 1 only
	      // push.apply(_, arraylike) throws on ancient WebKit
	      merge: function (first, second) {
	        var len = +second.length,
	          j = 0,
	          i = first.length;
	        for (; j < len; j++) {
	          first[i++] = second[j];
	        }
	        first.length = i;
	        return first;
	      },
	      grep: function (elems, callback, invert) {
	        var callbackInverse,
	          matches = [],
	          i = 0,
	          length = elems.length,
	          callbackExpect = !invert;

	        // Go through the array, only saving the items
	        // that pass the validator function
	        for (; i < length; i++) {
	          callbackInverse = !callback(elems[i], i);
	          if (callbackInverse !== callbackExpect) {
	            matches.push(elems[i]);
	          }
	        }
	        return matches;
	      },
	      // arg is for internal usage only
	      map: function (elems, callback, arg) {
	        var length,
	          value,
	          i = 0,
	          ret = [];

	        // Go through the array, translating each of the items to their new values
	        if (isArrayLike(elems)) {
	          length = elems.length;
	          for (; i < length; i++) {
	            value = callback(elems[i], i, arg);
	            if (value != null) {
	              ret.push(value);
	            }
	          }

	          // Go through every key on the object,
	        } else {
	          for (i in elems) {
	            value = callback(elems[i], i, arg);
	            if (value != null) {
	              ret.push(value);
	            }
	          }
	        }

	        // Flatten any nested arrays
	        return concat.apply([], ret);
	      },
	      // A global GUID counter for objects
	      guid: 1,
	      // Bind a function to a context, optionally partially applying any
	      // arguments.
	      proxy: function (fn, context) {
	        var tmp, args, proxy;
	        if (typeof context === "string") {
	          tmp = fn[context];
	          context = fn;
	          fn = tmp;
	        }

	        // Quick check to determine if target is callable, in the spec
	        // this throws a TypeError, but we will just return undefined.
	        if (!jQuery.isFunction(fn)) {
	          return undefined;
	        }

	        // Simulated bind
	        args = slice.call(arguments, 2);
	        proxy = function () {
	          return fn.apply(context || this, args.concat(slice.call(arguments)));
	        };

	        // Set the guid of unique handler to the same of original handler, so it can be removed
	        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	        return proxy;
	      },
	      now: Date.now,
	      // jQuery.support is not used in Core but other projects attach their
	      // properties to it so it needs to exist.
	      support: support
	    });
	    if (typeof Symbol === "function") {
	      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	    }

	    // Populate the class2type map
	    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
	      class2type["[object " + name + "]"] = name.toLowerCase();
	    });
	    function isArrayLike(obj) {
	      // Support: real iOS 8.2 only (not reproducible in simulator)
	      // `in` check used to prevent JIT error (gh-2145)
	      // hasOwn isn't used here due to false negatives
	      // regarding Nodelist length in IE
	      var length = !!obj && "length" in obj && obj.length,
	        type = jQuery.type(obj);
	      if (type === "function" || jQuery.isWindow(obj)) {
	        return false;
	      }
	      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	    }
	    var Sizzle =
	    /*!
	     * Sizzle CSS Selector Engine v2.3.3
	     * https://sizzlejs.com/
	     *
	     * Copyright jQuery Foundation and other contributors
	     * Released under the MIT license
	     * http://jquery.org/license
	     *
	     * Date: 2016-08-08
	     */
	    function (window) {
	      var i,
	        support,
	        Expr,
	        getText,
	        isXML,
	        tokenize,
	        compile,
	        select,
	        outermostContext,
	        sortInput,
	        hasDuplicate,
	        // Local document vars
	        setDocument,
	        document,
	        docElem,
	        documentIsHTML,
	        rbuggyQSA,
	        rbuggyMatches,
	        matches,
	        contains,
	        // Instance-specific data
	        expando = "sizzle" + 1 * new Date(),
	        preferredDoc = window.document,
	        dirruns = 0,
	        done = 0,
	        classCache = createCache(),
	        tokenCache = createCache(),
	        compilerCache = createCache(),
	        sortOrder = function (a, b) {
	          if (a === b) {
	            hasDuplicate = true;
	          }
	          return 0;
	        },
	        // Instance methods
	        hasOwn = {}.hasOwnProperty,
	        arr = [],
	        pop = arr.pop,
	        push_native = arr.push,
	        push = arr.push,
	        slice = arr.slice,
	        // Use a stripped-down indexOf as it's faster than native
	        // https://jsperf.com/thor-indexof-vs-for/5
	        indexOf = function (list, elem) {
	          var i = 0,
	            len = list.length;
	          for (; i < len; i++) {
	            if (list[i] === elem) {
	              return i;
	            }
	          }
	          return -1;
	        },
	        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	        // Regular expressions

	        // http://www.w3.org/TR/css3-selectors/#whitespace
	        whitespace = "[\\x20\\t\\r\\n\\f]",
	        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
	        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
	        // Operator (capture 2)
	        "*([*^$|!~]?=)" + whitespace +
	        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
	        pseudos = ":(" + identifier + ")(?:\\((" +
	        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	        // 1. quoted (capture 3; capture 4 or capture 5)
	        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	        // 2. simple (capture 6)
	        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	        // 3. anything else (capture 2)
	        ".*" + ")\\)|)",
	        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	        rwhitespace = new RegExp(whitespace + "+", "g"),
	        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
	        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
	        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
	        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
	        rpseudo = new RegExp(pseudos),
	        ridentifier = new RegExp("^" + identifier + "$"),
	        matchExpr = {
	          "ID": new RegExp("^#(" + identifier + ")"),
	          "CLASS": new RegExp("^\\.(" + identifier + ")"),
	          "TAG": new RegExp("^(" + identifier + "|[*])"),
	          "ATTR": new RegExp("^" + attributes),
	          "PSEUDO": new RegExp("^" + pseudos),
	          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
	          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
	          // For use in libraries implementing .is()
	          // We use this for POS matching in `select`
	          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
	        },
	        rinputs = /^(?:input|select|textarea|button)$/i,
	        rheader = /^h\d$/i,
	        rnative = /^[^{]+\{\s*\[native \w/,
	        // Easily-parseable/retrievable ID or TAG or CLASS selectors
	        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	        rsibling = /[+~]/,
	        // CSS escapes
	        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
	        funescape = function (_, escaped, escapedWhitespace) {
	          var high = "0x" + escaped - 0x10000;
	          // NaN means non-codepoint
	          // Support: Firefox<24
	          // Workaround erroneous numeric interpretation of +"0x"
	          return high !== high || escapedWhitespace ? escaped : high < 0 ?
	          // BMP codepoint
	          String.fromCharCode(high + 0x10000) :
	          // Supplemental Plane codepoint (surrogate pair)
	          String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
	        },
	        // CSS string/identifier serialization
	        // https://drafts.csswg.org/cssom/#common-serializing-idioms
	        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	        fcssescape = function (ch, asCodePoint) {
	          if (asCodePoint) {
	            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
	            if (ch === "\0") {
	              return "\uFFFD";
	            }

	            // Control characters and (dependent upon position) numbers get escaped as code points
	            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
	          }

	          // Other potentially-special ASCII characters get backslash-escaped
	          return "\\" + ch;
	        },
	        // Used for iframes
	        // See setDocument()
	        // Removing the function wrapper causes a "Permission Denied"
	        // error in IE
	        unloadHandler = function () {
	          setDocument();
	        },
	        disabledAncestor = addCombinator(function (elem) {
	          return elem.disabled === true && ("form" in elem || "label" in elem);
	        }, {
	          dir: "parentNode",
	          next: "legend"
	        });

	      // Optimize for push.apply( _, NodeList )
	      try {
	        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
	        // Support: Android<4.0
	        // Detect silently failing push.apply
	        arr[preferredDoc.childNodes.length].nodeType;
	      } catch (e) {
	        push = {
	          apply: arr.length ?
	          // Leverage slice if possible
	          function (target, els) {
	            push_native.apply(target, slice.call(els));
	          } :
	          // Support: IE<9
	          // Otherwise append directly
	          function (target, els) {
	            var j = target.length,
	              i = 0;
	            // Can't trust NodeList.length
	            while (target[j++] = els[i++]) {}
	            target.length = j - 1;
	          }
	        };
	      }
	      function Sizzle(selector, context, results, seed) {
	        var m,
	          i,
	          elem,
	          nid,
	          match,
	          groups,
	          newSelector,
	          newContext = context && context.ownerDocument,
	          // nodeType defaults to 9, since context defaults to document
	          nodeType = context ? context.nodeType : 9;
	        results = results || [];

	        // Return early from calls with invalid selector or context
	        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
	          return results;
	        }

	        // Try to shortcut find operations (as opposed to filters) in HTML documents
	        if (!seed) {
	          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
	            setDocument(context);
	          }
	          context = context || document;
	          if (documentIsHTML) {
	            // If the selector is sufficiently simple, try using a "get*By*" DOM method
	            // (excepting DocumentFragment context, where the methods don't exist)
	            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
	              // ID selector
	              if (m = match[1]) {
	                // Document context
	                if (nodeType === 9) {
	                  if (elem = context.getElementById(m)) {
	                    // Support: IE, Opera, Webkit
	                    // TODO: identify versions
	                    // getElementById can match elements by name instead of ID
	                    if (elem.id === m) {
	                      results.push(elem);
	                      return results;
	                    }
	                  } else {
	                    return results;
	                  }

	                  // Element context
	                } else {
	                  // Support: IE, Opera, Webkit
	                  // TODO: identify versions
	                  // getElementById can match elements by name instead of ID
	                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
	                    results.push(elem);
	                    return results;
	                  }
	                }

	                // Type selector
	              } else if (match[2]) {
	                push.apply(results, context.getElementsByTagName(selector));
	                return results;

	                // Class selector
	              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
	                push.apply(results, context.getElementsByClassName(m));
	                return results;
	              }
	            }

	            // Take advantage of querySelectorAll
	            if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
	              if (nodeType !== 1) {
	                newContext = context;
	                newSelector = selector;

	                // qSA looks outside Element context, which is not what we want
	                // Thanks to Andrew Dupont for this workaround technique
	                // Support: IE <=8
	                // Exclude object elements
	              } else if (context.nodeName.toLowerCase() !== "object") {
	                // Capture the context ID, setting it first if necessary
	                if (nid = context.getAttribute("id")) {
	                  nid = nid.replace(rcssescape, fcssescape);
	                } else {
	                  context.setAttribute("id", nid = expando);
	                }

	                // Prefix every selector in the list
	                groups = tokenize(selector);
	                i = groups.length;
	                while (i--) {
	                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
	                }
	                newSelector = groups.join(",");

	                // Expand context for sibling selectors
	                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
	              }
	              if (newSelector) {
	                try {
	                  push.apply(results, newContext.querySelectorAll(newSelector));
	                  return results;
	                } catch (qsaError) {} finally {
	                  if (nid === expando) {
	                    context.removeAttribute("id");
	                  }
	                }
	              }
	            }
	          }
	        }

	        // All others
	        return select(selector.replace(rtrim, "$1"), context, results, seed);
	      }

	      /**
	       * Create key-value caches of limited size
	       * @returns {function(string, object)} Returns the Object data after storing it on itself with
	       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	       *	deleting the oldest entry
	       */
	      function createCache() {
	        var keys = [];
	        function cache(key, value) {
	          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	          if (keys.push(key + " ") > Expr.cacheLength) {
	            // Only keep the most recent entries
	            delete cache[keys.shift()];
	          }
	          return cache[key + " "] = value;
	        }
	        return cache;
	      }

	      /**
	       * Mark a function for special use by Sizzle
	       * @param {Function} fn The function to mark
	       */
	      function markFunction(fn) {
	        fn[expando] = true;
	        return fn;
	      }

	      /**
	       * Support testing using an element
	       * @param {Function} fn Passed the created element and returns a boolean result
	       */
	      function assert(fn) {
	        var el = document.createElement("fieldset");
	        try {
	          return !!fn(el);
	        } catch (e) {
	          return false;
	        } finally {
	          // Remove from its parent by default
	          if (el.parentNode) {
	            el.parentNode.removeChild(el);
	          }
	          // release memory in IE
	          el = null;
	        }
	      }

	      /**
	       * Adds the same handler for all of the specified attrs
	       * @param {String} attrs Pipe-separated list of attributes
	       * @param {Function} handler The method that will be applied
	       */
	      function addHandle(attrs, handler) {
	        var arr = attrs.split("|"),
	          i = arr.length;
	        while (i--) {
	          Expr.attrHandle[arr[i]] = handler;
	        }
	      }

	      /**
	       * Checks document order of two siblings
	       * @param {Element} a
	       * @param {Element} b
	       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	       */
	      function siblingCheck(a, b) {
	        var cur = b && a,
	          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

	        // Use IE sourceIndex if available on both nodes
	        if (diff) {
	          return diff;
	        }

	        // Check if b follows a
	        if (cur) {
	          while (cur = cur.nextSibling) {
	            if (cur === b) {
	              return -1;
	            }
	          }
	        }
	        return a ? 1 : -1;
	      }

	      /**
	       * Returns a function to use in pseudos for input types
	       * @param {String} type
	       */
	      function createInputPseudo(type) {
	        return function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return name === "input" && elem.type === type;
	        };
	      }

	      /**
	       * Returns a function to use in pseudos for buttons
	       * @param {String} type
	       */
	      function createButtonPseudo(type) {
	        return function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return (name === "input" || name === "button") && elem.type === type;
	        };
	      }

	      /**
	       * Returns a function to use in pseudos for :enabled/:disabled
	       * @param {Boolean} disabled true for :disabled; false for :enabled
	       */
	      function createDisabledPseudo(disabled) {
	        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	        return function (elem) {
	          // Only certain elements can match :enabled or :disabled
	          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
	          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
	          if ("form" in elem) {
	            // Check for inherited disabledness on relevant non-disabled elements:
	            // * listed form-associated elements in a disabled fieldset
	            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
	            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
	            // * option elements in a disabled optgroup
	            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
	            // All such elements have a "form" property.
	            if (elem.parentNode && elem.disabled === false) {
	              // Option elements defer to a parent optgroup if present
	              if ("label" in elem) {
	                if ("label" in elem.parentNode) {
	                  return elem.parentNode.disabled === disabled;
	                } else {
	                  return elem.disabled === disabled;
	                }
	              }

	              // Support: IE 6 - 11
	              // Use the isDisabled shortcut property to check for disabled fieldset ancestors
	              return elem.isDisabled === disabled ||
	              // Where there is no isDisabled, check manually
	              /* jshint -W018 */
	              elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
	            }
	            return elem.disabled === disabled;

	            // Try to winnow out elements that can't be disabled before trusting the disabled property.
	            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
	            // even exist on them, let alone have a boolean value.
	          } else if ("label" in elem) {
	            return elem.disabled === disabled;
	          }

	          // Remaining elements are neither :enabled nor :disabled
	          return false;
	        };
	      }

	      /**
	       * Returns a function to use in pseudos for positionals
	       * @param {Function} fn
	       */
	      function createPositionalPseudo(fn) {
	        return markFunction(function (argument) {
	          argument = +argument;
	          return markFunction(function (seed, matches) {
	            var j,
	              matchIndexes = fn([], seed.length, argument),
	              i = matchIndexes.length;

	            // Match elements found at the specified indexes
	            while (i--) {
	              if (seed[j = matchIndexes[i]]) {
	                seed[j] = !(matches[j] = seed[j]);
	              }
	            }
	          });
	        });
	      }

	      /**
	       * Checks a node for validity as a Sizzle context
	       * @param {Element|Object=} context
	       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	       */
	      function testContext(context) {
	        return context && typeof context.getElementsByTagName !== "undefined" && context;
	      }

	      // Expose support vars for convenience
	      support = Sizzle.support = {};

	      /**
	       * Detects XML nodes
	       * @param {Element|Object} elem An element or a document
	       * @returns {Boolean} True iff elem is a non-HTML XML node
	       */
	      isXML = Sizzle.isXML = function (elem) {
	        // documentElement is verified for cases where it doesn't yet exist
	        // (such as loading iframes in IE - #4833)
	        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	        return documentElement ? documentElement.nodeName !== "HTML" : false;
	      };

	      /**
	       * Sets document-related variables once based on the current document
	       * @param {Element|Object} [doc] An element or document object to use to set the document
	       * @returns {Object} Returns the current document
	       */
	      setDocument = Sizzle.setDocument = function (node) {
	        var hasCompare,
	          subWindow,
	          doc = node ? node.ownerDocument || node : preferredDoc;

	        // Return early if doc is invalid or already selected
	        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
	          return document;
	        }

	        // Update global variables
	        document = doc;
	        docElem = document.documentElement;
	        documentIsHTML = !isXML(document);

	        // Support: IE 9-11, Edge
	        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
	          // Support: IE 11, Edge
	          if (subWindow.addEventListener) {
	            subWindow.addEventListener("unload", unloadHandler, false);

	            // Support: IE 9 - 10 only
	          } else if (subWindow.attachEvent) {
	            subWindow.attachEvent("onunload", unloadHandler);
	          }
	        }

	        /* Attributes
	        ---------------------------------------------------------------------- */

	        // Support: IE<8
	        // Verify that getAttribute really returns attributes and not properties
	        // (excepting IE8 booleans)
	        support.attributes = assert(function (el) {
	          el.className = "i";
	          return !el.getAttribute("className");
	        });

	        /* getElement(s)By*
	        ---------------------------------------------------------------------- */

	        // Check if getElementsByTagName("*") returns only elements
	        support.getElementsByTagName = assert(function (el) {
	          el.appendChild(document.createComment(""));
	          return !el.getElementsByTagName("*").length;
	        });

	        // Support: IE<9
	        support.getElementsByClassName = rnative.test(document.getElementsByClassName);

	        // Support: IE<10
	        // Check if getElementById returns elements by name
	        // The broken getElementById methods don't pick up programmatically-set names,
	        // so use a roundabout getElementsByName test
	        support.getById = assert(function (el) {
	          docElem.appendChild(el).id = expando;
	          return !document.getElementsByName || !document.getElementsByName(expando).length;
	        });

	        // ID filter and find
	        if (support.getById) {
	          Expr.filter["ID"] = function (id) {
	            var attrId = id.replace(runescape, funescape);
	            return function (elem) {
	              return elem.getAttribute("id") === attrId;
	            };
	          };
	          Expr.find["ID"] = function (id, context) {
	            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	              var elem = context.getElementById(id);
	              return elem ? [elem] : [];
	            }
	          };
	        } else {
	          Expr.filter["ID"] = function (id) {
	            var attrId = id.replace(runescape, funescape);
	            return function (elem) {
	              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
	              return node && node.value === attrId;
	            };
	          };

	          // Support: IE 6 - 7 only
	          // getElementById is not reliable as a find shortcut
	          Expr.find["ID"] = function (id, context) {
	            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
	              var node,
	                i,
	                elems,
	                elem = context.getElementById(id);
	              if (elem) {
	                // Verify the id attribute
	                node = elem.getAttributeNode("id");
	                if (node && node.value === id) {
	                  return [elem];
	                }

	                // Fall back on getElementsByName
	                elems = context.getElementsByName(id);
	                i = 0;
	                while (elem = elems[i++]) {
	                  node = elem.getAttributeNode("id");
	                  if (node && node.value === id) {
	                    return [elem];
	                  }
	                }
	              }
	              return [];
	            }
	          };
	        }

	        // Tag
	        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
	          if (typeof context.getElementsByTagName !== "undefined") {
	            return context.getElementsByTagName(tag);

	            // DocumentFragment nodes don't have gEBTN
	          } else if (support.qsa) {
	            return context.querySelectorAll(tag);
	          }
	        } : function (tag, context) {
	          var elem,
	            tmp = [],
	            i = 0,
	            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
	            results = context.getElementsByTagName(tag);

	          // Filter out possible comments
	          if (tag === "*") {
	            while (elem = results[i++]) {
	              if (elem.nodeType === 1) {
	                tmp.push(elem);
	              }
	            }
	            return tmp;
	          }
	          return results;
	        };

	        // Class
	        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
	          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
	            return context.getElementsByClassName(className);
	          }
	        };

	        /* QSA/matchesSelector
	        ---------------------------------------------------------------------- */

	        // QSA and matchesSelector support

	        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	        rbuggyMatches = [];

	        // qSa(:focus) reports false when true (Chrome 21)
	        // We allow this because of a bug in IE8/9 that throws an error
	        // whenever `document.activeElement` is accessed on an iframe
	        // So, we allow :focus to pass through QSA all the time to avoid the IE error
	        // See https://bugs.jquery.com/ticket/13378
	        rbuggyQSA = [];
	        if (support.qsa = rnative.test(document.querySelectorAll)) {
	          // Build QSA regex
	          // Regex strategy adopted from Diego Perini
	          assert(function (el) {
	            // Select is set to empty string on purpose
	            // This is to test IE's treatment of not explicitly
	            // setting a boolean content attribute,
	            // since its presence should be enough
	            // https://bugs.jquery.com/ticket/12359
	            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

	            // Support: IE8, Opera 11-12.16
	            // Nothing should be selected when empty strings follow ^= or $= or *=
	            // The test attribute must be unknown in Opera but "safe" for WinRT
	            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
	            if (el.querySelectorAll("[msallowcapture^='']").length) {
	              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
	            }

	            // Support: IE8
	            // Boolean attributes and "value" are not treated correctly
	            if (!el.querySelectorAll("[selected]").length) {
	              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
	            }

	            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
	            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
	              rbuggyQSA.push("~=");
	            }

	            // Webkit/Opera - :checked should return selected option elements
	            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	            // IE8 throws error here and will not see later tests
	            if (!el.querySelectorAll(":checked").length) {
	              rbuggyQSA.push(":checked");
	            }

	            // Support: Safari 8+, iOS 8+
	            // https://bugs.webkit.org/show_bug.cgi?id=136851
	            // In-page `selector#id sibling-combinator selector` fails
	            if (!el.querySelectorAll("a#" + expando + "+*").length) {
	              rbuggyQSA.push(".#.+[+~]");
	            }
	          });
	          assert(function (el) {
	            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";

	            // Support: Windows 8 Native Apps
	            // The type and name attributes are restricted during .innerHTML assignment
	            var input = document.createElement("input");
	            input.setAttribute("type", "hidden");
	            el.appendChild(input).setAttribute("name", "D");

	            // Support: IE8
	            // Enforce case-sensitivity of name attribute
	            if (el.querySelectorAll("[name=d]").length) {
	              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
	            }

	            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	            // IE8 throws error here and will not see later tests
	            if (el.querySelectorAll(":enabled").length !== 2) {
	              rbuggyQSA.push(":enabled", ":disabled");
	            }

	            // Support: IE9-11+
	            // IE's :disabled selector does not pick up the children of disabled fieldsets
	            docElem.appendChild(el).disabled = true;
	            if (el.querySelectorAll(":disabled").length !== 2) {
	              rbuggyQSA.push(":enabled", ":disabled");
	            }

	            // Opera 10-11 does not throw on post-comma invalid pseudos
	            el.querySelectorAll("*,:x");
	            rbuggyQSA.push(",.*:");
	          });
	        }
	        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
	          assert(function (el) {
	            // Check to see if it's possible to do matchesSelector
	            // on a disconnected node (IE 9)
	            support.disconnectedMatch = matches.call(el, "*");

	            // This should fail with an exception
	            // Gecko does not error, returns false instead
	            matches.call(el, "[s!='']:x");
	            rbuggyMatches.push("!=", pseudos);
	          });
	        }
	        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
	        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

	        /* Contains
	        ---------------------------------------------------------------------- */
	        hasCompare = rnative.test(docElem.compareDocumentPosition);

	        // Element contains another
	        // Purposefully self-exclusive
	        // As in, an element does not contain itself
	        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
	          var adown = a.nodeType === 9 ? a.documentElement : a,
	            bup = b && b.parentNode;
	          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
	        } : function (a, b) {
	          if (b) {
	            while (b = b.parentNode) {
	              if (b === a) {
	                return true;
	              }
	            }
	          }
	          return false;
	        };

	        /* Sorting
	        ---------------------------------------------------------------------- */

	        // Document order sorting
	        sortOrder = hasCompare ? function (a, b) {
	          // Flag for duplicate removal
	          if (a === b) {
	            hasDuplicate = true;
	            return 0;
	          }

	          // Sort on method existence if only one input has compareDocumentPosition
	          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
	          if (compare) {
	            return compare;
	          }

	          // Calculate position if both inputs belong to the same document
	          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :
	          // Otherwise we know they are disconnected
	          1;

	          // Disconnected nodes
	          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
	            // Choose the first element that is related to our preferred document
	            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
	              return -1;
	            }
	            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
	              return 1;
	            }

	            // Maintain original order
	            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
	          }
	          return compare & 4 ? -1 : 1;
	        } : function (a, b) {
	          // Exit early if the nodes are identical
	          if (a === b) {
	            hasDuplicate = true;
	            return 0;
	          }
	          var cur,
	            i = 0,
	            aup = a.parentNode,
	            bup = b.parentNode,
	            ap = [a],
	            bp = [b];

	          // Parentless nodes are either documents or disconnected
	          if (!aup || !bup) {
	            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

	            // If the nodes are siblings, we can do a quick check
	          } else if (aup === bup) {
	            return siblingCheck(a, b);
	          }

	          // Otherwise we need full lists of their ancestors for comparison
	          cur = a;
	          while (cur = cur.parentNode) {
	            ap.unshift(cur);
	          }
	          cur = b;
	          while (cur = cur.parentNode) {
	            bp.unshift(cur);
	          }

	          // Walk down the tree looking for a discrepancy
	          while (ap[i] === bp[i]) {
	            i++;
	          }
	          return i ?
	          // Do a sibling check if the nodes have a common ancestor
	          siblingCheck(ap[i], bp[i]) :
	          // Otherwise nodes in our document sort first
	          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
	        };
	        return document;
	      };
	      Sizzle.matches = function (expr, elements) {
	        return Sizzle(expr, null, null, elements);
	      };
	      Sizzle.matchesSelector = function (elem, expr) {
	        // Set document vars if needed
	        if ((elem.ownerDocument || elem) !== document) {
	          setDocument(elem);
	        }

	        // Make sure that attribute selectors are quoted
	        expr = expr.replace(rattributeQuotes, "='$1']");
	        if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
	          try {
	            var ret = matches.call(elem, expr);

	            // IE 9's matchesSelector returns false on disconnected nodes
	            if (ret || support.disconnectedMatch ||
	            // As well, disconnected nodes are said to be in a document
	            // fragment in IE 9
	            elem.document && elem.document.nodeType !== 11) {
	              return ret;
	            }
	          } catch (e) {}
	        }
	        return Sizzle(expr, document, null, [elem]).length > 0;
	      };
	      Sizzle.contains = function (context, elem) {
	        // Set document vars if needed
	        if ((context.ownerDocument || context) !== document) {
	          setDocument(context);
	        }
	        return contains(context, elem);
	      };
	      Sizzle.attr = function (elem, name) {
	        // Set document vars if needed
	        if ((elem.ownerDocument || elem) !== document) {
	          setDocument(elem);
	        }
	        var fn = Expr.attrHandle[name.toLowerCase()],
	          // Don't get fooled by Object.prototype properties (jQuery #13807)
	          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
	        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	      };
	      Sizzle.escape = function (sel) {
	        return (sel + "").replace(rcssescape, fcssescape);
	      };
	      Sizzle.error = function (msg) {
	        throw new Error("Syntax error, unrecognized expression: " + msg);
	      };

	      /**
	       * Document sorting and removing duplicates
	       * @param {ArrayLike} results
	       */
	      Sizzle.uniqueSort = function (results) {
	        var elem,
	          duplicates = [],
	          j = 0,
	          i = 0;

	        // Unless we *know* we can detect duplicates, assume their presence
	        hasDuplicate = !support.detectDuplicates;
	        sortInput = !support.sortStable && results.slice(0);
	        results.sort(sortOrder);
	        if (hasDuplicate) {
	          while (elem = results[i++]) {
	            if (elem === results[i]) {
	              j = duplicates.push(i);
	            }
	          }
	          while (j--) {
	            results.splice(duplicates[j], 1);
	          }
	        }

	        // Clear input after sorting to release objects
	        // See https://github.com/jquery/sizzle/pull/225
	        sortInput = null;
	        return results;
	      };

	      /**
	       * Utility function for retrieving the text value of an array of DOM nodes
	       * @param {Array|Element} elem
	       */
	      getText = Sizzle.getText = function (elem) {
	        var node,
	          ret = "",
	          i = 0,
	          nodeType = elem.nodeType;
	        if (!nodeType) {
	          // If no nodeType, this is expected to be an array
	          while (node = elem[i++]) {
	            // Do not traverse comment nodes
	            ret += getText(node);
	          }
	        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
	          // Use textContent for elements
	          // innerText usage removed for consistency of new lines (jQuery #11153)
	          if (typeof elem.textContent === "string") {
	            return elem.textContent;
	          } else {
	            // Traverse its children
	            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	              ret += getText(elem);
	            }
	          }
	        } else if (nodeType === 3 || nodeType === 4) {
	          return elem.nodeValue;
	        }
	        // Do not include comment or processing instruction nodes

	        return ret;
	      };
	      Expr = Sizzle.selectors = {
	        // Can be adjusted by the user
	        cacheLength: 50,
	        createPseudo: markFunction,
	        match: matchExpr,
	        attrHandle: {},
	        find: {},
	        relative: {
	          ">": {
	            dir: "parentNode",
	            first: true
	          },
	          " ": {
	            dir: "parentNode"
	          },
	          "+": {
	            dir: "previousSibling",
	            first: true
	          },
	          "~": {
	            dir: "previousSibling"
	          }
	        },
	        preFilter: {
	          "ATTR": function (match) {
	            match[1] = match[1].replace(runescape, funescape);

	            // Move the given value to match[3] whether quoted or unquoted
	            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
	            if (match[2] === "~=") {
	              match[3] = " " + match[3] + " ";
	            }
	            return match.slice(0, 4);
	          },
	          "CHILD": function (match) {
	            /* matches from matchExpr["CHILD"]
	            	1 type (only|nth|...)
	            	2 what (child|of-type)
	            	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	            	4 xn-component of xn+y argument ([+-]?\d*n|)
	            	5 sign of xn-component
	            	6 x of xn-component
	            	7 sign of y-component
	            	8 y of y-component
	            */
	            match[1] = match[1].toLowerCase();
	            if (match[1].slice(0, 3) === "nth") {
	              // nth-* requires argument
	              if (!match[3]) {
	                Sizzle.error(match[0]);
	              }

	              // numeric x and y parameters for Expr.filter.CHILD
	              // remember that false/true cast respectively to 0/1
	              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
	              match[5] = +(match[7] + match[8] || match[3] === "odd");

	              // other types prohibit arguments
	            } else if (match[3]) {
	              Sizzle.error(match[0]);
	            }
	            return match;
	          },
	          "PSEUDO": function (match) {
	            var excess,
	              unquoted = !match[6] && match[2];
	            if (matchExpr["CHILD"].test(match[0])) {
	              return null;
	            }

	            // Accept quoted arguments as-is
	            if (match[3]) {
	              match[2] = match[4] || match[5] || "";

	              // Strip excess characters from unquoted arguments
	            } else if (unquoted && rpseudo.test(unquoted) && (
	            // Get excess from tokenize (recursively)
	            excess = tokenize(unquoted, true)) && (
	            // advance to the next closing parenthesis
	            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
	              // excess is a negative index
	              match[0] = match[0].slice(0, excess);
	              match[2] = unquoted.slice(0, excess);
	            }

	            // Return only captures needed by the pseudo filter method (type and argument)
	            return match.slice(0, 3);
	          }
	        },
	        filter: {
	          "TAG": function (nodeNameSelector) {
	            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
	            return nodeNameSelector === "*" ? function () {
	              return true;
	            } : function (elem) {
	              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	            };
	          },
	          "CLASS": function (className) {
	            var pattern = classCache[className + " "];
	            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
	              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
	            });
	          },
	          "ATTR": function (name, operator, check) {
	            return function (elem) {
	              var result = Sizzle.attr(elem, name);
	              if (result == null) {
	                return operator === "!=";
	              }
	              if (!operator) {
	                return true;
	              }
	              result += "";
	              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
	            };
	          },
	          "CHILD": function (type, what, argument, first, last) {
	            var simple = type.slice(0, 3) !== "nth",
	              forward = type.slice(-4) !== "last",
	              ofType = what === "of-type";
	            return first === 1 && last === 0 ?
	            // Shortcut for :nth-*(n)
	            function (elem) {
	              return !!elem.parentNode;
	            } : function (elem, context, xml) {
	              var cache,
	                uniqueCache,
	                outerCache,
	                node,
	                nodeIndex,
	                start,
	                dir = simple !== forward ? "nextSibling" : "previousSibling",
	                parent = elem.parentNode,
	                name = ofType && elem.nodeName.toLowerCase(),
	                useCache = !xml && !ofType,
	                diff = false;
	              if (parent) {
	                // :(first|last|only)-(child|of-type)
	                if (simple) {
	                  while (dir) {
	                    node = elem;
	                    while (node = node[dir]) {
	                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	                        return false;
	                      }
	                    }
	                    // Reverse direction for :only-* (if we haven't yet done so)
	                    start = dir = type === "only" && !start && "nextSibling";
	                  }
	                  return true;
	                }
	                start = [forward ? parent.firstChild : parent.lastChild];

	                // non-xml :nth-child(...) stores cache data on `parent`
	                if (forward && useCache) {
	                  // Seek `elem` from a previously-cached index

	                  // ...in a gzip-friendly way
	                  node = parent;
	                  outerCache = node[expando] || (node[expando] = {});

	                  // Support: IE <9 only
	                  // Defend against cloned attroperties (jQuery gh-1709)
	                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                  cache = uniqueCache[type] || [];
	                  nodeIndex = cache[0] === dirruns && cache[1];
	                  diff = nodeIndex && cache[2];
	                  node = nodeIndex && parent.childNodes[nodeIndex];
	                  while (node = ++nodeIndex && node && node[dir] || (
	                  // Fallback to seeking `elem` from the start
	                  diff = nodeIndex = 0) || start.pop()) {
	                    // When found, cache indexes on `parent` and break
	                    if (node.nodeType === 1 && ++diff && node === elem) {
	                      uniqueCache[type] = [dirruns, nodeIndex, diff];
	                      break;
	                    }
	                  }
	                } else {
	                  // Use previously-cached element index if available
	                  if (useCache) {
	                    // ...in a gzip-friendly way
	                    node = elem;
	                    outerCache = node[expando] || (node[expando] = {});

	                    // Support: IE <9 only
	                    // Defend against cloned attroperties (jQuery gh-1709)
	                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                    cache = uniqueCache[type] || [];
	                    nodeIndex = cache[0] === dirruns && cache[1];
	                    diff = nodeIndex;
	                  }

	                  // xml :nth-child(...)
	                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)
	                  if (diff === false) {
	                    // Use the same loop as above to seek `elem` from the start
	                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	                        // Cache the index of each encountered element
	                        if (useCache) {
	                          outerCache = node[expando] || (node[expando] = {});

	                          // Support: IE <9 only
	                          // Defend against cloned attroperties (jQuery gh-1709)
	                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	                          uniqueCache[type] = [dirruns, diff];
	                        }
	                        if (node === elem) {
	                          break;
	                        }
	                      }
	                    }
	                  }
	                }

	                // Incorporate the offset, then check against cycle size
	                diff -= last;
	                return diff === first || diff % first === 0 && diff / first >= 0;
	              }
	            };
	          },
	          "PSEUDO": function (pseudo, argument) {
	            // pseudo-class names are case-insensitive
	            // http://www.w3.org/TR/selectors/#pseudo-classes
	            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	            // Remember that setFilters inherits from pseudos
	            var args,
	              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

	            // The user may use createPseudo to indicate that
	            // arguments are needed to create the filter function
	            // just as Sizzle does
	            if (fn[expando]) {
	              return fn(argument);
	            }

	            // But maintain support for old signatures
	            if (fn.length > 1) {
	              args = [pseudo, pseudo, "", argument];
	              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
	                var idx,
	                  matched = fn(seed, argument),
	                  i = matched.length;
	                while (i--) {
	                  idx = indexOf(seed, matched[i]);
	                  seed[idx] = !(matches[idx] = matched[i]);
	                }
	              }) : function (elem) {
	                return fn(elem, 0, args);
	              };
	            }
	            return fn;
	          }
	        },
	        pseudos: {
	          // Potentially complex pseudos
	          "not": markFunction(function (selector) {
	            // Trim the selector passed to compile
	            // to avoid treating leading and trailing
	            // spaces as combinators
	            var input = [],
	              results = [],
	              matcher = compile(selector.replace(rtrim, "$1"));
	            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
	              var elem,
	                unmatched = matcher(seed, null, xml, []),
	                i = seed.length;

	              // Match elements unmatched by `matcher`
	              while (i--) {
	                if (elem = unmatched[i]) {
	                  seed[i] = !(matches[i] = elem);
	                }
	              }
	            }) : function (elem, context, xml) {
	              input[0] = elem;
	              matcher(input, null, xml, results);
	              // Don't keep the element (issue #299)
	              input[0] = null;
	              return !results.pop();
	            };
	          }),
	          "has": markFunction(function (selector) {
	            return function (elem) {
	              return Sizzle(selector, elem).length > 0;
	            };
	          }),
	          "contains": markFunction(function (text) {
	            text = text.replace(runescape, funescape);
	            return function (elem) {
	              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
	            };
	          }),
	          // "Whether an element is represented by a :lang() selector
	          // is based solely on the element's language value
	          // being equal to the identifier C,
	          // or beginning with the identifier C immediately followed by "-".
	          // The matching of C against the element's language value is performed case-insensitively.
	          // The identifier C does not have to be a valid language name."
	          // http://www.w3.org/TR/selectors/#lang-pseudo
	          "lang": markFunction(function (lang) {
	            // lang value must be a valid identifier
	            if (!ridentifier.test(lang || "")) {
	              Sizzle.error("unsupported lang: " + lang);
	            }
	            lang = lang.replace(runescape, funescape).toLowerCase();
	            return function (elem) {
	              var elemLang;
	              do {
	                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
	                  elemLang = elemLang.toLowerCase();
	                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
	                }
	              } while ((elem = elem.parentNode) && elem.nodeType === 1);
	              return false;
	            };
	          }),
	          // Miscellaneous
	          "target": function (elem) {
	            var hash = window.location && window.location.hash;
	            return hash && hash.slice(1) === elem.id;
	          },
	          "root": function (elem) {
	            return elem === docElem;
	          },
	          "focus": function (elem) {
	            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	          },
	          // Boolean properties
	          "enabled": createDisabledPseudo(false),
	          "disabled": createDisabledPseudo(true),
	          "checked": function (elem) {
	            // In CSS3, :checked should return both checked and selected elements
	            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	            var nodeName = elem.nodeName.toLowerCase();
	            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
	          },
	          "selected": function (elem) {
	            // Accessing this property makes selected-by-default
	            // options in Safari work properly
	            if (elem.parentNode) {
	              elem.parentNode.selectedIndex;
	            }
	            return elem.selected === true;
	          },
	          // Contents
	          "empty": function (elem) {
	            // http://www.w3.org/TR/selectors/#empty-pseudo
	            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	            //   but not by others (comment: 8; processing instruction: 7; etc.)
	            // nodeType < 6 works because attributes (2) do not appear as children
	            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	              if (elem.nodeType < 6) {
	                return false;
	              }
	            }
	            return true;
	          },
	          "parent": function (elem) {
	            return !Expr.pseudos["empty"](elem);
	          },
	          // Element/input types
	          "header": function (elem) {
	            return rheader.test(elem.nodeName);
	          },
	          "input": function (elem) {
	            return rinputs.test(elem.nodeName);
	          },
	          "button": function (elem) {
	            var name = elem.nodeName.toLowerCase();
	            return name === "input" && elem.type === "button" || name === "button";
	          },
	          "text": function (elem) {
	            var attr;
	            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (
	            // Support: IE<8
	            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	            (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
	          },
	          // Position-in-collection
	          "first": createPositionalPseudo(function () {
	            return [0];
	          }),
	          "last": createPositionalPseudo(function (matchIndexes, length) {
	            return [length - 1];
	          }),
	          "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
	            return [argument < 0 ? argument + length : argument];
	          }),
	          "even": createPositionalPseudo(function (matchIndexes, length) {
	            var i = 0;
	            for (; i < length; i += 2) {
	              matchIndexes.push(i);
	            }
	            return matchIndexes;
	          }),
	          "odd": createPositionalPseudo(function (matchIndexes, length) {
	            var i = 1;
	            for (; i < length; i += 2) {
	              matchIndexes.push(i);
	            }
	            return matchIndexes;
	          }),
	          "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
	            var i = argument < 0 ? argument + length : argument;
	            for (; --i >= 0;) {
	              matchIndexes.push(i);
	            }
	            return matchIndexes;
	          }),
	          "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
	            var i = argument < 0 ? argument + length : argument;
	            for (; ++i < length;) {
	              matchIndexes.push(i);
	            }
	            return matchIndexes;
	          })
	        }
	      };
	      Expr.pseudos["nth"] = Expr.pseudos["eq"];

	      // Add button/input type pseudos
	      for (i in {
	        radio: true,
	        checkbox: true,
	        file: true,
	        password: true,
	        image: true
	      }) {
	        Expr.pseudos[i] = createInputPseudo(i);
	      }
	      for (i in {
	        submit: true,
	        reset: true
	      }) {
	        Expr.pseudos[i] = createButtonPseudo(i);
	      }

	      // Easy API for creating new setFilters
	      function setFilters() {}
	      setFilters.prototype = Expr.filters = Expr.pseudos;
	      Expr.setFilters = new setFilters();
	      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	        var matched,
	          match,
	          tokens,
	          type,
	          soFar,
	          groups,
	          preFilters,
	          cached = tokenCache[selector + " "];
	        if (cached) {
	          return parseOnly ? 0 : cached.slice(0);
	        }
	        soFar = selector;
	        groups = [];
	        preFilters = Expr.preFilter;
	        while (soFar) {
	          // Comma and first run
	          if (!matched || (match = rcomma.exec(soFar))) {
	            if (match) {
	              // Don't consume trailing commas as valid
	              soFar = soFar.slice(match[0].length) || soFar;
	            }
	            groups.push(tokens = []);
	          }
	          matched = false;

	          // Combinators
	          if (match = rcombinators.exec(soFar)) {
	            matched = match.shift();
	            tokens.push({
	              value: matched,
	              // Cast descendant combinators to space
	              type: match[0].replace(rtrim, " ")
	            });
	            soFar = soFar.slice(matched.length);
	          }

	          // Filters
	          for (type in Expr.filter) {
	            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
	              matched = match.shift();
	              tokens.push({
	                value: matched,
	                type: type,
	                matches: match
	              });
	              soFar = soFar.slice(matched.length);
	            }
	          }
	          if (!matched) {
	            break;
	          }
	        }

	        // Return the length of the invalid excess
	        // if we're just parsing
	        // Otherwise, throw an error or return tokens
	        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
	        // Cache the tokens
	        tokenCache(selector, groups).slice(0);
	      };
	      function toSelector(tokens) {
	        var i = 0,
	          len = tokens.length,
	          selector = "";
	        for (; i < len; i++) {
	          selector += tokens[i].value;
	        }
	        return selector;
	      }
	      function addCombinator(matcher, combinator, base) {
	        var dir = combinator.dir,
	          skip = combinator.next,
	          key = skip || dir,
	          checkNonElements = base && key === "parentNode",
	          doneName = done++;
	        return combinator.first ?
	        // Check against closest ancestor/preceding element
	        function (elem, context, xml) {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              return matcher(elem, context, xml);
	            }
	          }
	          return false;
	        } :
	        // Check against all ancestor/preceding elements
	        function (elem, context, xml) {
	          var oldCache,
	            uniqueCache,
	            outerCache,
	            newCache = [dirruns, doneName];

	          // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
	          if (xml) {
	            while (elem = elem[dir]) {
	              if (elem.nodeType === 1 || checkNonElements) {
	                if (matcher(elem, context, xml)) {
	                  return true;
	                }
	              }
	            }
	          } else {
	            while (elem = elem[dir]) {
	              if (elem.nodeType === 1 || checkNonElements) {
	                outerCache = elem[expando] || (elem[expando] = {});

	                // Support: IE <9 only
	                // Defend against cloned attroperties (jQuery gh-1709)
	                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
	                if (skip && skip === elem.nodeName.toLowerCase()) {
	                  elem = elem[dir] || elem;
	                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
	                  // Assign to newCache so results back-propagate to previous elements
	                  return newCache[2] = oldCache[2];
	                } else {
	                  // Reuse newcache so results back-propagate to previous elements
	                  uniqueCache[key] = newCache;

	                  // A match means we're done; a fail means we have to keep checking
	                  if (newCache[2] = matcher(elem, context, xml)) {
	                    return true;
	                  }
	                }
	              }
	            }
	          }
	          return false;
	        };
	      }
	      function elementMatcher(matchers) {
	        return matchers.length > 1 ? function (elem, context, xml) {
	          var i = matchers.length;
	          while (i--) {
	            if (!matchers[i](elem, context, xml)) {
	              return false;
	            }
	          }
	          return true;
	        } : matchers[0];
	      }
	      function multipleContexts(selector, contexts, results) {
	        var i = 0,
	          len = contexts.length;
	        for (; i < len; i++) {
	          Sizzle(selector, contexts[i], results);
	        }
	        return results;
	      }
	      function condense(unmatched, map, filter, context, xml) {
	        var elem,
	          newUnmatched = [],
	          i = 0,
	          len = unmatched.length,
	          mapped = map != null;
	        for (; i < len; i++) {
	          if (elem = unmatched[i]) {
	            if (!filter || filter(elem, context, xml)) {
	              newUnmatched.push(elem);
	              if (mapped) {
	                map.push(i);
	              }
	            }
	          }
	        }
	        return newUnmatched;
	      }
	      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	        if (postFilter && !postFilter[expando]) {
	          postFilter = setMatcher(postFilter);
	        }
	        if (postFinder && !postFinder[expando]) {
	          postFinder = setMatcher(postFinder, postSelector);
	        }
	        return markFunction(function (seed, results, context, xml) {
	          var temp,
	            i,
	            elem,
	            preMap = [],
	            postMap = [],
	            preexisting = results.length,
	            // Get initial elements from seed or context
	            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
	            // Prefilter to get matcher input, preserving a map for seed-results synchronization
	            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
	            matcherOut = matcher ?
	            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	            postFinder || (seed ? preFilter : preexisting || postFilter) ?
	            // ...intermediate processing is necessary
	            [] :
	            // ...otherwise use results directly
	            results : matcherIn;

	          // Find primary matches
	          if (matcher) {
	            matcher(matcherIn, matcherOut, context, xml);
	          }

	          // Apply postFilter
	          if (postFilter) {
	            temp = condense(matcherOut, postMap);
	            postFilter(temp, [], context, xml);

	            // Un-match failing elements by moving them back to matcherIn
	            i = temp.length;
	            while (i--) {
	              if (elem = temp[i]) {
	                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
	              }
	            }
	          }
	          if (seed) {
	            if (postFinder || preFilter) {
	              if (postFinder) {
	                // Get the final matcherOut by condensing this intermediate into postFinder contexts
	                temp = [];
	                i = matcherOut.length;
	                while (i--) {
	                  if (elem = matcherOut[i]) {
	                    // Restore matcherIn since elem is not yet a final match
	                    temp.push(matcherIn[i] = elem);
	                  }
	                }
	                postFinder(null, matcherOut = [], temp, xml);
	              }

	              // Move matched elements from seed to results to keep them synchronized
	              i = matcherOut.length;
	              while (i--) {
	                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
	                  seed[temp] = !(results[temp] = elem);
	                }
	              }
	            }

	            // Add elements to results, through postFinder if defined
	          } else {
	            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
	            if (postFinder) {
	              postFinder(null, results, matcherOut, xml);
	            } else {
	              push.apply(results, matcherOut);
	            }
	          }
	        });
	      }
	      function matcherFromTokens(tokens) {
	        var checkContext,
	          matcher,
	          j,
	          len = tokens.length,
	          leadingRelative = Expr.relative[tokens[0].type],
	          implicitRelative = leadingRelative || Expr.relative[" "],
	          i = leadingRelative ? 1 : 0,
	          // The foundational matcher ensures that elements are reachable from top-level context(s)
	          matchContext = addCombinator(function (elem) {
	            return elem === checkContext;
	          }, implicitRelative, true),
	          matchAnyContext = addCombinator(function (elem) {
	            return indexOf(checkContext, elem) > -1;
	          }, implicitRelative, true),
	          matchers = [function (elem, context, xml) {
	            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
	            // Avoid hanging onto element (issue #299)
	            checkContext = null;
	            return ret;
	          }];
	        for (; i < len; i++) {
	          if (matcher = Expr.relative[tokens[i].type]) {
	            matchers = [addCombinator(elementMatcher(matchers), matcher)];
	          } else {
	            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

	            // Return special upon seeing a positional matcher
	            if (matcher[expando]) {
	              // Find the next relative operator (if any) for proper handling
	              j = ++i;
	              for (; j < len; j++) {
	                if (Expr.relative[tokens[j].type]) {
	                  break;
	                }
	              }
	              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
	              // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	              tokens.slice(0, i - 1).concat({
	                value: tokens[i - 2].type === " " ? "*" : ""
	              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
	            }
	            matchers.push(matcher);
	          }
	        }
	        return elementMatcher(matchers);
	      }
	      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
	        var bySet = setMatchers.length > 0,
	          byElement = elementMatchers.length > 0,
	          superMatcher = function (seed, context, xml, results, outermost) {
	            var elem,
	              j,
	              matcher,
	              matchedCount = 0,
	              i = "0",
	              unmatched = seed && [],
	              setMatched = [],
	              contextBackup = outermostContext,
	              // We must always have either seed elements or outermost context
	              elems = seed || byElement && Expr.find["TAG"]("*", outermost),
	              // Use integer dirruns iff this is the outermost matcher
	              dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
	              len = elems.length;
	            if (outermost) {
	              outermostContext = context === document || context || outermost;
	            }

	            // Add elements passing elementMatchers directly to results
	            // Support: IE<9, Safari
	            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
	            for (; i !== len && (elem = elems[i]) != null; i++) {
	              if (byElement && elem) {
	                j = 0;
	                if (!context && elem.ownerDocument !== document) {
	                  setDocument(elem);
	                  xml = !documentIsHTML;
	                }
	                while (matcher = elementMatchers[j++]) {
	                  if (matcher(elem, context || document, xml)) {
	                    results.push(elem);
	                    break;
	                  }
	                }
	                if (outermost) {
	                  dirruns = dirrunsUnique;
	                }
	              }

	              // Track unmatched elements for set filters
	              if (bySet) {
	                // They will have gone through all possible matchers
	                if (elem = !matcher && elem) {
	                  matchedCount--;
	                }

	                // Lengthen the array for every element, matched or not
	                if (seed) {
	                  unmatched.push(elem);
	                }
	              }
	            }

	            // `i` is now the count of elements visited above, and adding it to `matchedCount`
	            // makes the latter nonnegative.
	            matchedCount += i;

	            // Apply set filters to unmatched elements
	            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
	            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
	            // no element matchers and no seed.
	            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
	            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
	            // numerically zero.
	            if (bySet && i !== matchedCount) {
	              j = 0;
	              while (matcher = setMatchers[j++]) {
	                matcher(unmatched, setMatched, context, xml);
	              }
	              if (seed) {
	                // Reintegrate element matches to eliminate the need for sorting
	                if (matchedCount > 0) {
	                  while (i--) {
	                    if (!(unmatched[i] || setMatched[i])) {
	                      setMatched[i] = pop.call(results);
	                    }
	                  }
	                }

	                // Discard index placeholder values to get only actual matches
	                setMatched = condense(setMatched);
	              }

	              // Add matches to results
	              push.apply(results, setMatched);

	              // Seedless set matches succeeding multiple successful matchers stipulate sorting
	              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
	                Sizzle.uniqueSort(results);
	              }
	            }

	            // Override manipulation of globals by nested matchers
	            if (outermost) {
	              dirruns = dirrunsUnique;
	              outermostContext = contextBackup;
	            }
	            return unmatched;
	          };
	        return bySet ? markFunction(superMatcher) : superMatcher;
	      }
	      compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
	        var i,
	          setMatchers = [],
	          elementMatchers = [],
	          cached = compilerCache[selector + " "];
	        if (!cached) {
	          // Generate a function of recursive functions that can be used to check each element
	          if (!match) {
	            match = tokenize(selector);
	          }
	          i = match.length;
	          while (i--) {
	            cached = matcherFromTokens(match[i]);
	            if (cached[expando]) {
	              setMatchers.push(cached);
	            } else {
	              elementMatchers.push(cached);
	            }
	          }

	          // Cache the compiled function
	          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

	          // Save selector and tokenization
	          cached.selector = selector;
	        }
	        return cached;
	      };

	      /**
	       * A low-level selection function that works with Sizzle's compiled
	       *  selector functions
	       * @param {String|Function} selector A selector or a pre-compiled
	       *  selector function built with Sizzle.compile
	       * @param {Element} context
	       * @param {Array} [results]
	       * @param {Array} [seed] A set of elements to match against
	       */
	      select = Sizzle.select = function (selector, context, results, seed) {
	        var i,
	          tokens,
	          token,
	          type,
	          find,
	          compiled = typeof selector === "function" && selector,
	          match = !seed && tokenize(selector = compiled.selector || selector);
	        results = results || [];

	        // Try to minimize operations if there is only one selector in the list and no seed
	        // (the latter of which guarantees us context)
	        if (match.length === 1) {
	          // Reduce context if the leading compound selector is an ID
	          tokens = match[0] = match[0].slice(0);
	          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
	            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
	            if (!context) {
	              return results;

	              // Precompiled matchers will still verify ancestry, so step up a level
	            } else if (compiled) {
	              context = context.parentNode;
	            }
	            selector = selector.slice(tokens.shift().value.length);
	          }

	          // Fetch a seed set for right-to-left matching
	          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
	          while (i--) {
	            token = tokens[i];

	            // Abort if we hit a combinator
	            if (Expr.relative[type = token.type]) {
	              break;
	            }
	            if (find = Expr.find[type]) {
	              // Search, expanding context for leading sibling combinators
	              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
	                // If seed is empty or no tokens remain, we can return early
	                tokens.splice(i, 1);
	                selector = seed.length && toSelector(tokens);
	                if (!selector) {
	                  push.apply(results, seed);
	                  return results;
	                }
	                break;
	              }
	            }
	          }
	        }

	        // Compile and execute a filtering function if one is not provided
	        // Provide `match` to avoid retokenization if we modified the selector above
	        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
	        return results;
	      };

	      // One-time assignments

	      // Sort stability
	      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

	      // Support: Chrome 14-35+
	      // Always assume duplicates if they aren't passed to the comparison function
	      support.detectDuplicates = !!hasDuplicate;

	      // Initialize against the default document
	      setDocument();

	      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	      // Detached nodes confoundingly follow *each other*
	      support.sortDetached = assert(function (el) {
	        // Should return 1, but returns 4 (following)
	        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
	      });

	      // Support: IE<8
	      // Prevent attribute/property "interpolation"
	      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	      if (!assert(function (el) {
	        el.innerHTML = "<a href='#'></a>";
	        return el.firstChild.getAttribute("href") === "#";
	      })) {
	        addHandle("type|href|height|width", function (elem, name, isXML) {
	          if (!isXML) {
	            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
	          }
	        });
	      }

	      // Support: IE<9
	      // Use defaultValue in place of getAttribute("value")
	      if (!support.attributes || !assert(function (el) {
	        el.innerHTML = "<input/>";
	        el.firstChild.setAttribute("value", "");
	        return el.firstChild.getAttribute("value") === "";
	      })) {
	        addHandle("value", function (elem, name, isXML) {
	          if (!isXML && elem.nodeName.toLowerCase() === "input") {
	            return elem.defaultValue;
	          }
	        });
	      }

	      // Support: IE<9
	      // Use getAttributeNode to fetch booleans when getAttribute lies
	      if (!assert(function (el) {
	        return el.getAttribute("disabled") == null;
	      })) {
	        addHandle(booleans, function (elem, name, isXML) {
	          var val;
	          if (!isXML) {
	            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	          }
	        });
	      }
	      return Sizzle;
	    }(window);
	    jQuery.find = Sizzle;
	    jQuery.expr = Sizzle.selectors;

	    // Deprecated
	    jQuery.expr[":"] = jQuery.expr.pseudos;
	    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	    jQuery.text = Sizzle.getText;
	    jQuery.isXMLDoc = Sizzle.isXML;
	    jQuery.contains = Sizzle.contains;
	    jQuery.escapeSelector = Sizzle.escape;
	    var dir = function (elem, dir, until) {
	      var matched = [],
	        truncate = until !== undefined;
	      while ((elem = elem[dir]) && elem.nodeType !== 9) {
	        if (elem.nodeType === 1) {
	          if (truncate && jQuery(elem).is(until)) {
	            break;
	          }
	          matched.push(elem);
	        }
	      }
	      return matched;
	    };
	    var siblings = function (n, elem) {
	      var matched = [];
	      for (; n; n = n.nextSibling) {
	        if (n.nodeType === 1 && n !== elem) {
	          matched.push(n);
	        }
	      }
	      return matched;
	    };
	    var rneedsContext = jQuery.expr.match.needsContext;
	    function nodeName(elem, name) {
	      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	    }
	    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
	    var risSimple = /^.[^:#\[\.,]*$/;

	    // Implement the identical functionality for filter and not
	    function winnow(elements, qualifier, not) {
	      if (jQuery.isFunction(qualifier)) {
	        return jQuery.grep(elements, function (elem, i) {
	          return !!qualifier.call(elem, i, elem) !== not;
	        });
	      }

	      // Single element
	      if (qualifier.nodeType) {
	        return jQuery.grep(elements, function (elem) {
	          return elem === qualifier !== not;
	        });
	      }

	      // Arraylike of elements (jQuery, arguments, Array)
	      if (typeof qualifier !== "string") {
	        return jQuery.grep(elements, function (elem) {
	          return indexOf.call(qualifier, elem) > -1 !== not;
	        });
	      }

	      // Simple selector that can be filtered directly, removing non-Elements
	      if (risSimple.test(qualifier)) {
	        return jQuery.filter(qualifier, elements, not);
	      }

	      // Complex selector, compare the two sets, removing non-Elements
	      qualifier = jQuery.filter(qualifier, elements);
	      return jQuery.grep(elements, function (elem) {
	        return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
	      });
	    }
	    jQuery.filter = function (expr, elems, not) {
	      var elem = elems[0];
	      if (not) {
	        expr = ":not(" + expr + ")";
	      }
	      if (elems.length === 1 && elem.nodeType === 1) {
	        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
	      }
	      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
	        return elem.nodeType === 1;
	      }));
	    };
	    jQuery.fn.extend({
	      find: function (selector) {
	        var i,
	          ret,
	          len = this.length,
	          self = this;
	        if (typeof selector !== "string") {
	          return this.pushStack(jQuery(selector).filter(function () {
	            for (i = 0; i < len; i++) {
	              if (jQuery.contains(self[i], this)) {
	                return true;
	              }
	            }
	          }));
	        }
	        ret = this.pushStack([]);
	        for (i = 0; i < len; i++) {
	          jQuery.find(selector, self[i], ret);
	        }
	        return len > 1 ? jQuery.uniqueSort(ret) : ret;
	      },
	      filter: function (selector) {
	        return this.pushStack(winnow(this, selector || [], false));
	      },
	      not: function (selector) {
	        return this.pushStack(winnow(this, selector || [], true));
	      },
	      is: function (selector) {
	        return !!winnow(this,
	        // If this is a positional/relative selector, check membership in the returned set
	        // so $("p:first").is("p:last") won't return true for a doc with two "p".
	        typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
	      }
	    });

	    // Initialize a jQuery object

	    // A central reference to the root jQuery(document)
	    var rootjQuery,
	      // A simple way to check for HTML strings
	      // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	      // Strict HTML recognition (#11290: must start with <)
	      // Shortcut simple #id case for speed
	      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	      init = jQuery.fn.init = function (selector, context, root) {
	        var match, elem;

	        // HANDLE: $(""), $(null), $(undefined), $(false)
	        if (!selector) {
	          return this;
	        }

	        // Method init() accepts an alternate rootjQuery
	        // so migrate can support jQuery.sub (gh-2101)
	        root = root || rootjQuery;

	        // Handle HTML strings
	        if (typeof selector === "string") {
	          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
	            // Assume that strings that start and end with <> are HTML and skip the regex check
	            match = [null, selector, null];
	          } else {
	            match = rquickExpr.exec(selector);
	          }

	          // Match html or make sure no context is specified for #id
	          if (match && (match[1] || !context)) {
	            // HANDLE: $(html) -> $(array)
	            if (match[1]) {
	              context = context instanceof jQuery ? context[0] : context;

	              // Option to run scripts is true for back-compat
	              // Intentionally let the error be thrown if parseHTML is not present
	              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

	              // HANDLE: $(html, props)
	              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
	                for (match in context) {
	                  // Properties of context are called as methods if possible
	                  if (jQuery.isFunction(this[match])) {
	                    this[match](context[match]);

	                    // ...and otherwise set as attributes
	                  } else {
	                    this.attr(match, context[match]);
	                  }
	                }
	              }
	              return this;

	              // HANDLE: $(#id)
	            } else {
	              elem = document.getElementById(match[2]);
	              if (elem) {
	                // Inject the element directly into the jQuery object
	                this[0] = elem;
	                this.length = 1;
	              }
	              return this;
	            }

	            // HANDLE: $(expr, $(...))
	          } else if (!context || context.jquery) {
	            return (context || root).find(selector);

	            // HANDLE: $(expr, context)
	            // (which is just equivalent to: $(context).find(expr)
	          } else {
	            return this.constructor(context).find(selector);
	          }

	          // HANDLE: $(DOMElement)
	        } else if (selector.nodeType) {
	          this[0] = selector;
	          this.length = 1;
	          return this;

	          // HANDLE: $(function)
	          // Shortcut for document ready
	        } else if (jQuery.isFunction(selector)) {
	          return root.ready !== undefined ? root.ready(selector) :
	          // Execute immediately if ready is not present
	          selector(jQuery);
	        }
	        return jQuery.makeArray(selector, this);
	      };

	    // Give the init function the jQuery prototype for later instantiation
	    init.prototype = jQuery.fn;

	    // Initialize central reference
	    rootjQuery = jQuery(document);
	    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	      // Methods guaranteed to produce a unique set when starting from a unique set
	      guaranteedUnique = {
	        children: true,
	        contents: true,
	        next: true,
	        prev: true
	      };
	    jQuery.fn.extend({
	      has: function (target) {
	        var targets = jQuery(target, this),
	          l = targets.length;
	        return this.filter(function () {
	          var i = 0;
	          for (; i < l; i++) {
	            if (jQuery.contains(this, targets[i])) {
	              return true;
	            }
	          }
	        });
	      },
	      closest: function (selectors, context) {
	        var cur,
	          i = 0,
	          l = this.length,
	          matched = [],
	          targets = typeof selectors !== "string" && jQuery(selectors);

	        // Positional selectors never match, since there's no _selection_ context
	        if (!rneedsContext.test(selectors)) {
	          for (; i < l; i++) {
	            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
	              // Always skip document fragments
	              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :
	              // Don't pass non-elements to Sizzle
	              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
	                matched.push(cur);
	                break;
	              }
	            }
	          }
	        }
	        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
	      },
	      // Determine the position of an element within the set
	      index: function (elem) {
	        // No argument, return index in parent
	        if (!elem) {
	          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
	        }

	        // Index in selector
	        if (typeof elem === "string") {
	          return indexOf.call(jQuery(elem), this[0]);
	        }

	        // Locate the position of the desired element
	        return indexOf.call(this,
	        // If it receives a jQuery object, the first element is used
	        elem.jquery ? elem[0] : elem);
	      },
	      add: function (selector, context) {
	        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
	      },
	      addBack: function (selector) {
	        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
	      }
	    });
	    function sibling(cur, dir) {
	      while ((cur = cur[dir]) && cur.nodeType !== 1) {}
	      return cur;
	    }
	    jQuery.each({
	      parent: function (elem) {
	        var parent = elem.parentNode;
	        return parent && parent.nodeType !== 11 ? parent : null;
	      },
	      parents: function (elem) {
	        return dir(elem, "parentNode");
	      },
	      parentsUntil: function (elem, i, until) {
	        return dir(elem, "parentNode", until);
	      },
	      next: function (elem) {
	        return sibling(elem, "nextSibling");
	      },
	      prev: function (elem) {
	        return sibling(elem, "previousSibling");
	      },
	      nextAll: function (elem) {
	        return dir(elem, "nextSibling");
	      },
	      prevAll: function (elem) {
	        return dir(elem, "previousSibling");
	      },
	      nextUntil: function (elem, i, until) {
	        return dir(elem, "nextSibling", until);
	      },
	      prevUntil: function (elem, i, until) {
	        return dir(elem, "previousSibling", until);
	      },
	      siblings: function (elem) {
	        return siblings((elem.parentNode || {}).firstChild, elem);
	      },
	      children: function (elem) {
	        return siblings(elem.firstChild);
	      },
	      contents: function (elem) {
	        if (nodeName(elem, "iframe")) {
	          return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if (nodeName(elem, "template")) {
	          elem = elem.content || elem;
	        }
	        return jQuery.merge([], elem.childNodes);
	      }
	    }, function (name, fn) {
	      jQuery.fn[name] = function (until, selector) {
	        var matched = jQuery.map(this, fn, until);
	        if (name.slice(-5) !== "Until") {
	          selector = until;
	        }
	        if (selector && typeof selector === "string") {
	          matched = jQuery.filter(selector, matched);
	        }
	        if (this.length > 1) {
	          // Remove duplicates
	          if (!guaranteedUnique[name]) {
	            jQuery.uniqueSort(matched);
	          }

	          // Reverse order for parents* and prev-derivatives
	          if (rparentsprev.test(name)) {
	            matched.reverse();
	          }
	        }
	        return this.pushStack(matched);
	      };
	    });
	    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

	    // Convert String-formatted options into Object-formatted ones
	    function createOptions(options) {
	      var object = {};
	      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
	        object[flag] = true;
	      });
	      return object;
	    }

	    /*
	     * Create a callback list using the following parameters:
	     *
	     *	options: an optional list of space-separated options that will change how
	     *			the callback list behaves or a more traditional option object
	     *
	     * By default a callback list will act like an event callback list and can be
	     * "fired" multiple times.
	     *
	     * Possible options:
	     *
	     *	once:			will ensure the callback list can only be fired once (like a Deferred)
	     *
	     *	memory:			will keep track of previous values and will call any callback added
	     *					after the list has been fired right away with the latest "memorized"
	     *					values (like a Deferred)
	     *
	     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	     *
	     *	stopOnFalse:	interrupt callings when a callback returns false
	     *
	     */
	    jQuery.Callbacks = function (options) {
	      // Convert options from String-formatted to Object-formatted if needed
	      // (we check in cache first)
	      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
	      var
	        // Flag to know if list is currently firing
	        firing,
	        // Last fire value for non-forgettable lists
	        memory,
	        // Flag to know if list was already fired
	        fired,
	        // Flag to prevent firing
	        locked,
	        // Actual callback list
	        list = [],
	        // Queue of execution data for repeatable lists
	        queue = [],
	        // Index of currently firing callback (modified by add/remove as needed)
	        firingIndex = -1,
	        // Fire callbacks
	        fire = function () {
	          // Enforce single-firing
	          locked = locked || options.once;

	          // Execute callbacks for all pending executions,
	          // respecting firingIndex overrides and runtime changes
	          fired = firing = true;
	          for (; queue.length; firingIndex = -1) {
	            memory = queue.shift();
	            while (++firingIndex < list.length) {
	              // Run callback and check for early termination
	              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
	                // Jump to end and forget the data so .add doesn't re-fire
	                firingIndex = list.length;
	                memory = false;
	              }
	            }
	          }

	          // Forget the data if we're done with it
	          if (!options.memory) {
	            memory = false;
	          }
	          firing = false;

	          // Clean up if we're done firing for good
	          if (locked) {
	            // Keep an empty list if we have data for future add calls
	            if (memory) {
	              list = [];

	              // Otherwise, this object is spent
	            } else {
	              list = "";
	            }
	          }
	        },
	        // Actual Callbacks object
	        self = {
	          // Add a callback or a collection of callbacks to the list
	          add: function () {
	            if (list) {
	              // If we have memory from a past run, we should fire after adding
	              if (memory && !firing) {
	                firingIndex = list.length - 1;
	                queue.push(memory);
	              }
	              (function add(args) {
	                jQuery.each(args, function (_, arg) {
	                  if (jQuery.isFunction(arg)) {
	                    if (!options.unique || !self.has(arg)) {
	                      list.push(arg);
	                    }
	                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
	                    // Inspect recursively
	                    add(arg);
	                  }
	                });
	              })(arguments);
	              if (memory && !firing) {
	                fire();
	              }
	            }
	            return this;
	          },
	          // Remove a callback from the list
	          remove: function () {
	            jQuery.each(arguments, function (_, arg) {
	              var index;
	              while ((index = jQuery.inArray(arg, list, index)) > -1) {
	                list.splice(index, 1);

	                // Handle firing indexes
	                if (index <= firingIndex) {
	                  firingIndex--;
	                }
	              }
	            });
	            return this;
	          },
	          // Check if a given callback is in the list.
	          // If no argument is given, return whether or not list has callbacks attached.
	          has: function (fn) {
	            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
	          },
	          // Remove all callbacks from the list
	          empty: function () {
	            if (list) {
	              list = [];
	            }
	            return this;
	          },
	          // Disable .fire and .add
	          // Abort any current/pending executions
	          // Clear all callbacks and values
	          disable: function () {
	            locked = queue = [];
	            list = memory = "";
	            return this;
	          },
	          disabled: function () {
	            return !list;
	          },
	          // Disable .fire
	          // Also disable .add unless we have memory (since it would have no effect)
	          // Abort any pending executions
	          lock: function () {
	            locked = queue = [];
	            if (!memory && !firing) {
	              list = memory = "";
	            }
	            return this;
	          },
	          locked: function () {
	            return !!locked;
	          },
	          // Call all callbacks with the given context and arguments
	          fireWith: function (context, args) {
	            if (!locked) {
	              args = args || [];
	              args = [context, args.slice ? args.slice() : args];
	              queue.push(args);
	              if (!firing) {
	                fire();
	              }
	            }
	            return this;
	          },
	          // Call all the callbacks with the given arguments
	          fire: function () {
	            self.fireWith(this, arguments);
	            return this;
	          },
	          // To know if the callbacks have already been called at least once
	          fired: function () {
	            return !!fired;
	          }
	        };
	      return self;
	    };
	    function Identity(v) {
	      return v;
	    }
	    function Thrower(ex) {
	      throw ex;
	    }
	    function adoptValue(value, resolve, reject, noValue) {
	      var method;
	      try {
	        // Check for promise aspect first to privilege synchronous behavior
	        if (value && jQuery.isFunction(method = value.promise)) {
	          method.call(value).done(resolve).fail(reject);

	          // Other thenables
	        } else if (value && jQuery.isFunction(method = value.then)) {
	          method.call(value, resolve, reject);

	          // Other non-thenables
	        } else {
	          // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
	          // * false: [ value ].slice( 0 ) => resolve( value )
	          // * true: [ value ].slice( 1 ) => resolve()
	          resolve.apply(undefined, [value].slice(noValue));
	        }

	        // For Promises/A+, convert exceptions into rejections
	        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	        // Deferred#then to conditionally suppress rejection.
	      } catch (value) {
	        // Support: Android 4.0 only
	        // Strict mode functions invoked without .call/.apply get global-object context
	        reject.apply(undefined, [value]);
	      }
	    }
	    jQuery.extend({
	      Deferred: function (func) {
	        var tuples = [
	          // action, add listener, callbacks,
	          // ... .then handlers, argument index, [final state]
	          ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
	          state = "pending",
	          promise = {
	            state: function () {
	              return state;
	            },
	            always: function () {
	              deferred.done(arguments).fail(arguments);
	              return this;
	            },
	            "catch": function (fn) {
	              return promise.then(null, fn);
	            },
	            // Keep pipe for back-compat
	            pipe: function /* fnDone, fnFail, fnProgress */
	            () {
	              var fns = arguments;
	              return jQuery.Deferred(function (newDefer) {
	                jQuery.each(tuples, function (i, tuple) {
	                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)
	                  var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

	                  // deferred.progress(function() { bind to newDefer or newDefer.notify })
	                  // deferred.done(function() { bind to newDefer or newDefer.resolve })
	                  // deferred.fail(function() { bind to newDefer or newDefer.reject })
	                  deferred[tuple[1]](function () {
	                    var returned = fn && fn.apply(this, arguments);
	                    if (returned && jQuery.isFunction(returned.promise)) {
	                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
	                    } else {
	                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
	                    }
	                  });
	                });
	                fns = null;
	              }).promise();
	            },
	            then: function (onFulfilled, onRejected, onProgress) {
	              var maxDepth = 0;
	              function resolve(depth, deferred, handler, special) {
	                return function () {
	                  var that = this,
	                    args = arguments,
	                    mightThrow = function () {
	                      var returned, then;

	                      // Support: Promises/A+ section 2.3.3.3.3
	                      // https://promisesaplus.com/#point-59
	                      // Ignore double-resolution attempts
	                      if (depth < maxDepth) {
	                        return;
	                      }
	                      returned = handler.apply(that, args);

	                      // Support: Promises/A+ section 2.3.1
	                      // https://promisesaplus.com/#point-48
	                      if (returned === deferred.promise()) {
	                        throw new TypeError("Thenable self-resolution");
	                      }

	                      // Support: Promises/A+ sections 2.3.3.1, 3.5
	                      // https://promisesaplus.com/#point-54
	                      // https://promisesaplus.com/#point-75
	                      // Retrieve `then` only once
	                      then = returned && (
	                      // Support: Promises/A+ section 2.3.4
	                      // https://promisesaplus.com/#point-64
	                      // Only check objects and functions for thenability
	                      typeof returned === "object" || typeof returned === "function") && returned.then;

	                      // Handle a returned thenable
	                      if (jQuery.isFunction(then)) {
	                        // Special processors (notify) just wait for resolution
	                        if (special) {
	                          then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));

	                          // Normal processors (resolve) also hook into progress
	                        } else {
	                          // ...and disregard older resolution values
	                          maxDepth++;
	                          then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
	                        }

	                        // Handle all other returned values
	                      } else {
	                        // Only substitute handlers pass on context
	                        // and multiple values (non-spec behavior)
	                        if (handler !== Identity) {
	                          that = undefined;
	                          args = [returned];
	                        }

	                        // Process the value(s)
	                        // Default process is resolve
	                        (special || deferred.resolveWith)(that, args);
	                      }
	                    },
	                    // Only normal processors (resolve) catch and reject exceptions
	                    process = special ? mightThrow : function () {
	                      try {
	                        mightThrow();
	                      } catch (e) {
	                        if (jQuery.Deferred.exceptionHook) {
	                          jQuery.Deferred.exceptionHook(e, process.stackTrace);
	                        }

	                        // Support: Promises/A+ section 2.3.3.3.4.1
	                        // https://promisesaplus.com/#point-61
	                        // Ignore post-resolution exceptions
	                        if (depth + 1 >= maxDepth) {
	                          // Only substitute handlers pass on context
	                          // and multiple values (non-spec behavior)
	                          if (handler !== Thrower) {
	                            that = undefined;
	                            args = [e];
	                          }
	                          deferred.rejectWith(that, args);
	                        }
	                      }
	                    };

	                  // Support: Promises/A+ section 2.3.3.3.1
	                  // https://promisesaplus.com/#point-57
	                  // Re-resolve promises immediately to dodge false rejection from
	                  // subsequent errors
	                  if (depth) {
	                    process();
	                  } else {
	                    // Call an optional hook to record the stack, in case of exception
	                    // since it's otherwise lost when execution goes async
	                    if (jQuery.Deferred.getStackHook) {
	                      process.stackTrace = jQuery.Deferred.getStackHook();
	                    }
	                    window.setTimeout(process);
	                  }
	                };
	              }
	              return jQuery.Deferred(function (newDefer) {
	                // progress_handlers.add( ... )
	                tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));

	                // fulfilled_handlers.add( ... )
	                tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));

	                // rejected_handlers.add( ... )
	                tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
	              }).promise();
	            },
	            // Get a promise for this deferred
	            // If obj is provided, the promise aspect is added to the object
	            promise: function (obj) {
	              return obj != null ? jQuery.extend(obj, promise) : promise;
	            }
	          },
	          deferred = {};

	        // Add list-specific methods
	        jQuery.each(tuples, function (i, tuple) {
	          var list = tuple[2],
	            stateString = tuple[5];

	          // promise.progress = list.add
	          // promise.done = list.add
	          // promise.fail = list.add
	          promise[tuple[1]] = list.add;

	          // Handle state
	          if (stateString) {
	            list.add(function () {
	              // state = "resolved" (i.e., fulfilled)
	              // state = "rejected"
	              state = stateString;
	            },
	            // rejected_callbacks.disable
	            // fulfilled_callbacks.disable
	            tuples[3 - i][2].disable,
	            // progress_callbacks.lock
	            tuples[0][2].lock);
	          }

	          // progress_handlers.fire
	          // fulfilled_handlers.fire
	          // rejected_handlers.fire
	          list.add(tuple[3].fire);

	          // deferred.notify = function() { deferred.notifyWith(...) }
	          // deferred.resolve = function() { deferred.resolveWith(...) }
	          // deferred.reject = function() { deferred.rejectWith(...) }
	          deferred[tuple[0]] = function () {
	            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
	            return this;
	          };

	          // deferred.notifyWith = list.fireWith
	          // deferred.resolveWith = list.fireWith
	          // deferred.rejectWith = list.fireWith
	          deferred[tuple[0] + "With"] = list.fireWith;
	        });

	        // Make the deferred a promise
	        promise.promise(deferred);

	        // Call given func if any
	        if (func) {
	          func.call(deferred, deferred);
	        }

	        // All done!
	        return deferred;
	      },
	      // Deferred helper
	      when: function (singleValue) {
	        var
	          // count of uncompleted subordinates
	          remaining = arguments.length,
	          // count of unprocessed arguments
	          i = remaining,
	          // subordinate fulfillment data
	          resolveContexts = Array(i),
	          resolveValues = slice.call(arguments),
	          // the master Deferred
	          master = jQuery.Deferred(),
	          // subordinate callback factory
	          updateFunc = function (i) {
	            return function (value) {
	              resolveContexts[i] = this;
	              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
	              if (! --remaining) {
	                master.resolveWith(resolveContexts, resolveValues);
	              }
	            };
	          };

	        // Single- and empty arguments are adopted like Promise.resolve
	        if (remaining <= 1) {
	          adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);

	          // Use .then() to unwrap secondary thenables (cf. gh-3000)
	          if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
	            return master.then();
	          }
	        }

	        // Multiple arguments are aggregated like Promise.all array elements
	        while (i--) {
	          adoptValue(resolveValues[i], updateFunc(i), master.reject);
	        }
	        return master.promise();
	      }
	    });

	    // These usually indicate a programmer mistake during development,
	    // warn about them ASAP rather than swallowing them by default.
	    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	    jQuery.Deferred.exceptionHook = function (error, stack) {
	      // Support: IE 8 - 9 only
	      // Console exists when dev tools are open, which can happen at any time
	      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
	        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
	      }
	    };
	    jQuery.readyException = function (error) {
	      window.setTimeout(function () {
	        throw error;
	      });
	    };

	    // The deferred used on DOM ready
	    var readyList = jQuery.Deferred();
	    jQuery.fn.ready = function (fn) {
	      readyList.then(fn)

	      // Wrap jQuery.readyException in a function so that the lookup
	      // happens at the time of error handling instead of callback
	      // registration.
	      .catch(function (error) {
	        jQuery.readyException(error);
	      });
	      return this;
	    };
	    jQuery.extend({
	      // Is the DOM ready to be used? Set to true once it occurs.
	      isReady: false,
	      // A counter to track how many items to wait for before
	      // the ready event fires. See #6781
	      readyWait: 1,
	      // Handle when the DOM is ready
	      ready: function (wait) {
	        // Abort if there are pending holds or we're already ready
	        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
	          return;
	        }

	        // Remember that the DOM is ready
	        jQuery.isReady = true;

	        // If a normal DOM Ready event fired, decrement, and wait if need be
	        if (wait !== true && --jQuery.readyWait > 0) {
	          return;
	        }

	        // If there are functions bound, to execute
	        readyList.resolveWith(document, [jQuery]);
	      }
	    });
	    jQuery.ready.then = readyList.then;

	    // The ready event handler and self cleanup method
	    function completed() {
	      document.removeEventListener("DOMContentLoaded", completed);
	      window.removeEventListener("load", completed);
	      jQuery.ready();
	    }

	    // Catch cases where $(document).ready() is called
	    // after the browser event has already occurred.
	    // Support: IE <=9 - 10 only
	    // Older IE sometimes signals "interactive" too soon
	    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
	      // Handle it asynchronously to allow scripts the opportunity to delay ready
	      window.setTimeout(jQuery.ready);
	    } else {
	      // Use the handy event callback
	      document.addEventListener("DOMContentLoaded", completed);

	      // A fallback to window.onload, that will always work
	      window.addEventListener("load", completed);
	    }

	    // Multifunctional method to get and set values of a collection
	    // The value/s can optionally be executed if it's a function
	    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
	      var i = 0,
	        len = elems.length,
	        bulk = key == null;

	      // Sets many values
	      if (jQuery.type(key) === "object") {
	        chainable = true;
	        for (i in key) {
	          access(elems, fn, i, key[i], true, emptyGet, raw);
	        }

	        // Sets one value
	      } else if (value !== undefined) {
	        chainable = true;
	        if (!jQuery.isFunction(value)) {
	          raw = true;
	        }
	        if (bulk) {
	          // Bulk operations run against the entire set
	          if (raw) {
	            fn.call(elems, value);
	            fn = null;

	            // ...except when executing function values
	          } else {
	            bulk = fn;
	            fn = function (elem, key, value) {
	              return bulk.call(jQuery(elem), value);
	            };
	          }
	        }
	        if (fn) {
	          for (; i < len; i++) {
	            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
	          }
	        }
	      }
	      if (chainable) {
	        return elems;
	      }

	      // Gets
	      if (bulk) {
	        return fn.call(elems);
	      }
	      return len ? fn(elems[0], key) : emptyGet;
	    };
	    var acceptData = function (owner) {
	      // Accepts only:
	      //  - Node
	      //    - Node.ELEMENT_NODE
	      //    - Node.DOCUMENT_NODE
	      //  - Object
	      //    - Any
	      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	    };
	    function Data() {
	      this.expando = jQuery.expando + Data.uid++;
	    }
	    Data.uid = 1;
	    Data.prototype = {
	      cache: function (owner) {
	        // Check if the owner object already has a cache
	        var value = owner[this.expando];

	        // If not, create one
	        if (!value) {
	          value = {};

	          // We can accept data for non-element nodes in modern browsers,
	          // but we should not, see #8335.
	          // Always return an empty object.
	          if (acceptData(owner)) {
	            // If it is a node unlikely to be stringify-ed or looped over
	            // use plain assignment
	            if (owner.nodeType) {
	              owner[this.expando] = value;

	              // Otherwise secure it in a non-enumerable property
	              // configurable must be true to allow the property to be
	              // deleted when data is removed
	            } else {
	              Object.defineProperty(owner, this.expando, {
	                value: value,
	                configurable: true
	              });
	            }
	          }
	        }
	        return value;
	      },
	      set: function (owner, data, value) {
	        var prop,
	          cache = this.cache(owner);

	        // Handle: [ owner, key, value ] args
	        // Always use camelCase key (gh-2257)
	        if (typeof data === "string") {
	          cache[jQuery.camelCase(data)] = value;

	          // Handle: [ owner, { properties } ] args
	        } else {
	          // Copy the properties one-by-one to the cache object
	          for (prop in data) {
	            cache[jQuery.camelCase(prop)] = data[prop];
	          }
	        }
	        return cache;
	      },
	      get: function (owner, key) {
	        return key === undefined ? this.cache(owner) :
	        // Always use camelCase key (gh-2257)
	        owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
	      },
	      access: function (owner, key, value) {
	        // In cases where either:
	        //
	        //   1. No key was specified
	        //   2. A string key was specified, but no value provided
	        //
	        // Take the "read" path and allow the get method to determine
	        // which value to return, respectively either:
	        //
	        //   1. The entire cache object
	        //   2. The data stored at the key
	        //
	        if (key === undefined || key && typeof key === "string" && value === undefined) {
	          return this.get(owner, key);
	        }

	        // When the key is not a string, or both a key and value
	        // are specified, set or extend (existing objects) with either:
	        //
	        //   1. An object of properties
	        //   2. A key and value
	        //
	        this.set(owner, key, value);

	        // Since the "set" path can have two possible entry points
	        // return the expected data based on which path was taken[*]
	        return value !== undefined ? value : key;
	      },
	      remove: function (owner, key) {
	        var i,
	          cache = owner[this.expando];
	        if (cache === undefined) {
	          return;
	        }
	        if (key !== undefined) {
	          // Support array or space separated string of keys
	          if (Array.isArray(key)) {
	            // If key is an array of keys...
	            // We always set camelCase keys, so remove that.
	            key = key.map(jQuery.camelCase);
	          } else {
	            key = jQuery.camelCase(key);

	            // If a key with the spaces exists, use it.
	            // Otherwise, create an array by matching non-whitespace
	            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
	          }
	          i = key.length;
	          while (i--) {
	            delete cache[key[i]];
	          }
	        }

	        // Remove the expando if there's no more data
	        if (key === undefined || jQuery.isEmptyObject(cache)) {
	          // Support: Chrome <=35 - 45
	          // Webkit & Blink performance suffers when deleting properties
	          // from DOM nodes, so set to undefined instead
	          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
	          if (owner.nodeType) {
	            owner[this.expando] = undefined;
	          } else {
	            delete owner[this.expando];
	          }
	        }
	      },
	      hasData: function (owner) {
	        var cache = owner[this.expando];
	        return cache !== undefined && !jQuery.isEmptyObject(cache);
	      }
	    };
	    var dataPriv = new Data();
	    var dataUser = new Data();

	    //	Implementation Summary
	    //
	    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
	    //	2. Improve the module's maintainability by reducing the storage
	    //		paths to a single mechanism.
	    //	3. Use the same single mechanism to support "private" and "user" data.
	    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
	    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	      rmultiDash = /[A-Z]/g;
	    function getData(data) {
	      if (data === "true") {
	        return true;
	      }
	      if (data === "false") {
	        return false;
	      }
	      if (data === "null") {
	        return null;
	      }

	      // Only convert to a number if it doesn't change the string
	      if (data === +data + "") {
	        return +data;
	      }
	      if (rbrace.test(data)) {
	        return JSON.parse(data);
	      }
	      return data;
	    }
	    function dataAttr(elem, key, data) {
	      var name;

	      // If nothing was found internally, try to fetch any
	      // data from the HTML5 data-* attribute
	      if (data === undefined && elem.nodeType === 1) {
	        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
	        data = elem.getAttribute(name);
	        if (typeof data === "string") {
	          try {
	            data = getData(data);
	          } catch (e) {}

	          // Make sure we set the data so it isn't changed later
	          dataUser.set(elem, key, data);
	        } else {
	          data = undefined;
	        }
	      }
	      return data;
	    }
	    jQuery.extend({
	      hasData: function (elem) {
	        return dataUser.hasData(elem) || dataPriv.hasData(elem);
	      },
	      data: function (elem, name, data) {
	        return dataUser.access(elem, name, data);
	      },
	      removeData: function (elem, name) {
	        dataUser.remove(elem, name);
	      },
	      // TODO: Now that all calls to _data and _removeData have been replaced
	      // with direct calls to dataPriv methods, these can be deprecated.
	      _data: function (elem, name, data) {
	        return dataPriv.access(elem, name, data);
	      },
	      _removeData: function (elem, name) {
	        dataPriv.remove(elem, name);
	      }
	    });
	    jQuery.fn.extend({
	      data: function (key, value) {
	        var i,
	          name,
	          data,
	          elem = this[0],
	          attrs = elem && elem.attributes;

	        // Gets all values
	        if (key === undefined) {
	          if (this.length) {
	            data = dataUser.get(elem);
	            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
	              i = attrs.length;
	              while (i--) {
	                // Support: IE 11 only
	                // The attrs elements can be null (#14894)
	                if (attrs[i]) {
	                  name = attrs[i].name;
	                  if (name.indexOf("data-") === 0) {
	                    name = jQuery.camelCase(name.slice(5));
	                    dataAttr(elem, name, data[name]);
	                  }
	                }
	              }
	              dataPriv.set(elem, "hasDataAttrs", true);
	            }
	          }
	          return data;
	        }

	        // Sets multiple values
	        if (typeof key === "object") {
	          return this.each(function () {
	            dataUser.set(this, key);
	          });
	        }
	        return access(this, function (value) {
	          var data;

	          // The calling jQuery object (element matches) is not empty
	          // (and therefore has an element appears at this[ 0 ]) and the
	          // `value` parameter was not undefined. An empty jQuery object
	          // will result in `undefined` for elem = this[ 0 ] which will
	          // throw an exception if an attempt to read a data cache is made.
	          if (elem && value === undefined) {
	            // Attempt to get data from the cache
	            // The key will always be camelCased in Data
	            data = dataUser.get(elem, key);
	            if (data !== undefined) {
	              return data;
	            }

	            // Attempt to "discover" the data in
	            // HTML5 custom data-* attrs
	            data = dataAttr(elem, key);
	            if (data !== undefined) {
	              return data;
	            }

	            // We tried really hard, but the data doesn't exist.
	            return;
	          }

	          // Set the data...
	          this.each(function () {
	            // We always store the camelCased key
	            dataUser.set(this, key, value);
	          });
	        }, null, value, arguments.length > 1, null, true);
	      },
	      removeData: function (key) {
	        return this.each(function () {
	          dataUser.remove(this, key);
	        });
	      }
	    });
	    jQuery.extend({
	      queue: function (elem, type, data) {
	        var queue;
	        if (elem) {
	          type = (type || "fx") + "queue";
	          queue = dataPriv.get(elem, type);

	          // Speed up dequeue by getting out quickly if this is just a lookup
	          if (data) {
	            if (!queue || Array.isArray(data)) {
	              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
	            } else {
	              queue.push(data);
	            }
	          }
	          return queue || [];
	        }
	      },
	      dequeue: function (elem, type) {
	        type = type || "fx";
	        var queue = jQuery.queue(elem, type),
	          startLength = queue.length,
	          fn = queue.shift(),
	          hooks = jQuery._queueHooks(elem, type),
	          next = function () {
	            jQuery.dequeue(elem, type);
	          };

	        // If the fx queue is dequeued, always remove the progress sentinel
	        if (fn === "inprogress") {
	          fn = queue.shift();
	          startLength--;
	        }
	        if (fn) {
	          // Add a progress sentinel to prevent the fx queue from being
	          // automatically dequeued
	          if (type === "fx") {
	            queue.unshift("inprogress");
	          }

	          // Clear up the last queue stop function
	          delete hooks.stop;
	          fn.call(elem, next, hooks);
	        }
	        if (!startLength && hooks) {
	          hooks.empty.fire();
	        }
	      },
	      // Not public - generate a queueHooks object, or return the current one
	      _queueHooks: function (elem, type) {
	        var key = type + "queueHooks";
	        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
	          empty: jQuery.Callbacks("once memory").add(function () {
	            dataPriv.remove(elem, [type + "queue", key]);
	          })
	        });
	      }
	    });
	    jQuery.fn.extend({
	      queue: function (type, data) {
	        var setter = 2;
	        if (typeof type !== "string") {
	          data = type;
	          type = "fx";
	          setter--;
	        }
	        if (arguments.length < setter) {
	          return jQuery.queue(this[0], type);
	        }
	        return data === undefined ? this : this.each(function () {
	          var queue = jQuery.queue(this, type, data);

	          // Ensure a hooks for this queue
	          jQuery._queueHooks(this, type);
	          if (type === "fx" && queue[0] !== "inprogress") {
	            jQuery.dequeue(this, type);
	          }
	        });
	      },
	      dequeue: function (type) {
	        return this.each(function () {
	          jQuery.dequeue(this, type);
	        });
	      },
	      clearQueue: function (type) {
	        return this.queue(type || "fx", []);
	      },
	      // Get a promise resolved when queues of a certain type
	      // are emptied (fx is the type by default)
	      promise: function (type, obj) {
	        var tmp,
	          count = 1,
	          defer = jQuery.Deferred(),
	          elements = this,
	          i = this.length,
	          resolve = function () {
	            if (! --count) {
	              defer.resolveWith(elements, [elements]);
	            }
	          };
	        if (typeof type !== "string") {
	          obj = type;
	          type = undefined;
	        }
	        type = type || "fx";
	        while (i--) {
	          tmp = dataPriv.get(elements[i], type + "queueHooks");
	          if (tmp && tmp.empty) {
	            count++;
	            tmp.empty.add(resolve);
	          }
	        }
	        resolve();
	        return defer.promise(obj);
	      }
	    });
	    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
	    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
	    var cssExpand = ["Top", "Right", "Bottom", "Left"];
	    var isHiddenWithinTree = function (elem, el) {
	      // isHiddenWithinTree might be called from jQuery#filter function;
	      // in that case, element will be second argument
	      elem = el || elem;

	      // Inline style trumps all
	      return elem.style.display === "none" || elem.style.display === "" &&
	      // Otherwise, check computed style
	      // Support: Firefox <=43 - 45
	      // Disconnected elements can have computed display: none, so first confirm that elem is
	      // in the document.
	      jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
	    };
	    var swap = function (elem, options, callback, args) {
	      var ret,
	        name,
	        old = {};

	      // Remember the old values, and insert the new ones
	      for (name in options) {
	        old[name] = elem.style[name];
	        elem.style[name] = options[name];
	      }
	      ret = callback.apply(elem, args || []);

	      // Revert the old values
	      for (name in options) {
	        elem.style[name] = old[name];
	      }
	      return ret;
	    };
	    function adjustCSS(elem, prop, valueParts, tween) {
	      var adjusted,
	        scale = 1,
	        maxIterations = 20,
	        currentValue = tween ? function () {
	          return tween.cur();
	        } : function () {
	          return jQuery.css(elem, prop, "");
	        },
	        initial = currentValue(),
	        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
	        // Starting value computation is required for potential unit mismatches
	        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
	      if (initialInUnit && initialInUnit[3] !== unit) {
	        // Trust units reported by jQuery.css
	        unit = unit || initialInUnit[3];

	        // Make sure we update the tween properties later on
	        valueParts = valueParts || [];

	        // Iteratively approximate from a nonzero starting point
	        initialInUnit = +initial || 1;
	        do {
	          // If previous iteration zeroed out, double until we get *something*.
	          // Use string for doubling so we don't accidentally see scale as unchanged below
	          scale = scale || ".5";

	          // Adjust and apply
	          initialInUnit = initialInUnit / scale;
	          jQuery.style(elem, prop, initialInUnit + unit);

	          // Update scale, tolerating zero or NaN from tween.cur()
	          // Break the loop if scale is unchanged or perfect, or if we've just had enough.
	        } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
	      }
	      if (valueParts) {
	        initialInUnit = +initialInUnit || +initial || 0;

	        // Apply relative offset (+=/-=) if specified
	        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
	        if (tween) {
	          tween.unit = unit;
	          tween.start = initialInUnit;
	          tween.end = adjusted;
	        }
	      }
	      return adjusted;
	    }
	    var defaultDisplayMap = {};
	    function getDefaultDisplay(elem) {
	      var temp,
	        doc = elem.ownerDocument,
	        nodeName = elem.nodeName,
	        display = defaultDisplayMap[nodeName];
	      if (display) {
	        return display;
	      }
	      temp = doc.body.appendChild(doc.createElement(nodeName));
	      display = jQuery.css(temp, "display");
	      temp.parentNode.removeChild(temp);
	      if (display === "none") {
	        display = "block";
	      }
	      defaultDisplayMap[nodeName] = display;
	      return display;
	    }
	    function showHide(elements, show) {
	      var display,
	        elem,
	        values = [],
	        index = 0,
	        length = elements.length;

	      // Determine new display value for elements that need to change
	      for (; index < length; index++) {
	        elem = elements[index];
	        if (!elem.style) {
	          continue;
	        }
	        display = elem.style.display;
	        if (show) {
	          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
	          // check is required in this first loop unless we have a nonempty display value (either
	          // inline or about-to-be-restored)
	          if (display === "none") {
	            values[index] = dataPriv.get(elem, "display") || null;
	            if (!values[index]) {
	              elem.style.display = "";
	            }
	          }
	          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
	            values[index] = getDefaultDisplay(elem);
	          }
	        } else {
	          if (display !== "none") {
	            values[index] = "none";

	            // Remember what we're overwriting
	            dataPriv.set(elem, "display", display);
	          }
	        }
	      }

	      // Set the display of the elements in a second loop to avoid constant reflow
	      for (index = 0; index < length; index++) {
	        if (values[index] != null) {
	          elements[index].style.display = values[index];
	        }
	      }
	      return elements;
	    }
	    jQuery.fn.extend({
	      show: function () {
	        return showHide(this, true);
	      },
	      hide: function () {
	        return showHide(this);
	      },
	      toggle: function (state) {
	        if (typeof state === "boolean") {
	          return state ? this.show() : this.hide();
	        }
	        return this.each(function () {
	          if (isHiddenWithinTree(this)) {
	            jQuery(this).show();
	          } else {
	            jQuery(this).hide();
	          }
	        });
	      }
	    });
	    var rcheckableType = /^(?:checkbox|radio)$/i;
	    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
	    var rscriptType = /^$|\/(?:java|ecma)script/i;

	    // We have to close these tags to support XHTML (#13200)
	    var wrapMap = {
	      // Support: IE <=9 only
	      option: [1, "<select multiple='multiple'>", "</select>"],
	      // XHTML parsers do not magically insert elements in the
	      // same way that tag soup parsers do. So we cannot shorten
	      // this by omitting <tbody> or other required elements.
	      thead: [1, "<table>", "</table>"],
	      col: [2, "<table><colgroup>", "</colgroup></table>"],
	      tr: [2, "<table><tbody>", "</tbody></table>"],
	      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	      _default: [0, "", ""]
	    };

	    // Support: IE <=9 only
	    wrapMap.optgroup = wrapMap.option;
	    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	    wrapMap.th = wrapMap.td;
	    function getAll(context, tag) {
	      // Support: IE <=9 - 11 only
	      // Use typeof to avoid zero-argument method invocation on host objects (#15151)
	      var ret;
	      if (typeof context.getElementsByTagName !== "undefined") {
	        ret = context.getElementsByTagName(tag || "*");
	      } else if (typeof context.querySelectorAll !== "undefined") {
	        ret = context.querySelectorAll(tag || "*");
	      } else {
	        ret = [];
	      }
	      if (tag === undefined || tag && nodeName(context, tag)) {
	        return jQuery.merge([context], ret);
	      }
	      return ret;
	    }

	    // Mark scripts as having already been evaluated
	    function setGlobalEval(elems, refElements) {
	      var i = 0,
	        l = elems.length;
	      for (; i < l; i++) {
	        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
	      }
	    }
	    var rhtml = /<|&#?\w+;/;
	    function buildFragment(elems, context, scripts, selection, ignored) {
	      var elem,
	        tmp,
	        tag,
	        wrap,
	        contains,
	        j,
	        fragment = context.createDocumentFragment(),
	        nodes = [],
	        i = 0,
	        l = elems.length;
	      for (; i < l; i++) {
	        elem = elems[i];
	        if (elem || elem === 0) {
	          // Add nodes directly
	          if (jQuery.type(elem) === "object") {
	            // Support: Android <=4.0 only, PhantomJS 1 only
	            // push.apply(_, arraylike) throws on ancient WebKit
	            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

	            // Convert non-html into a text node
	          } else if (!rhtml.test(elem)) {
	            nodes.push(context.createTextNode(elem));

	            // Convert html into DOM nodes
	          } else {
	            tmp = tmp || fragment.appendChild(context.createElement("div"));

	            // Deserialize a standard representation
	            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
	            wrap = wrapMap[tag] || wrapMap._default;
	            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

	            // Descend through wrappers to the right content
	            j = wrap[0];
	            while (j--) {
	              tmp = tmp.lastChild;
	            }

	            // Support: Android <=4.0 only, PhantomJS 1 only
	            // push.apply(_, arraylike) throws on ancient WebKit
	            jQuery.merge(nodes, tmp.childNodes);

	            // Remember the top-level container
	            tmp = fragment.firstChild;

	            // Ensure the created nodes are orphaned (#12392)
	            tmp.textContent = "";
	          }
	        }
	      }

	      // Remove wrapper from fragment
	      fragment.textContent = "";
	      i = 0;
	      while (elem = nodes[i++]) {
	        // Skip elements already in the context collection (trac-4087)
	        if (selection && jQuery.inArray(elem, selection) > -1) {
	          if (ignored) {
	            ignored.push(elem);
	          }
	          continue;
	        }
	        contains = jQuery.contains(elem.ownerDocument, elem);

	        // Append to fragment
	        tmp = getAll(fragment.appendChild(elem), "script");

	        // Preserve script evaluation history
	        if (contains) {
	          setGlobalEval(tmp);
	        }

	        // Capture executables
	        if (scripts) {
	          j = 0;
	          while (elem = tmp[j++]) {
	            if (rscriptType.test(elem.type || "")) {
	              scripts.push(elem);
	            }
	          }
	        }
	      }
	      return fragment;
	    }
	    (function () {
	      var fragment = document.createDocumentFragment(),
	        div = fragment.appendChild(document.createElement("div")),
	        input = document.createElement("input");

	      // Support: Android 4.0 - 4.3 only
	      // Check state lost if the name is set (#11217)
	      // Support: Windows Web Apps (WWA)
	      // `name` and `type` must use .setAttribute for WWA (#14901)
	      input.setAttribute("type", "radio");
	      input.setAttribute("checked", "checked");
	      input.setAttribute("name", "t");
	      div.appendChild(input);

	      // Support: Android <=4.1 only
	      // Older WebKit doesn't clone checked state correctly in fragments
	      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

	      // Support: IE <=11 only
	      // Make sure textarea (and checkbox) defaultValue is properly cloned
	      div.innerHTML = "<textarea>x</textarea>";
	      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	    })();
	    var documentElement = document.documentElement;
	    var rkeyEvent = /^key/,
	      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	    function returnTrue() {
	      return true;
	    }
	    function returnFalse() {
	      return false;
	    }

	    // Support: IE <=9 only
	    // See #13393 for more info
	    function safeActiveElement() {
	      try {
	        return document.activeElement;
	      } catch (err) {}
	    }
	    function on(elem, types, selector, data, fn, one) {
	      var origFn, type;

	      // Types can be a map of types/handlers
	      if (typeof types === "object") {
	        // ( types-Object, selector, data )
	        if (typeof selector !== "string") {
	          // ( types-Object, data )
	          data = data || selector;
	          selector = undefined;
	        }
	        for (type in types) {
	          on(elem, type, selector, data, types[type], one);
	        }
	        return elem;
	      }
	      if (data == null && fn == null) {
	        // ( types, fn )
	        fn = selector;
	        data = selector = undefined;
	      } else if (fn == null) {
	        if (typeof selector === "string") {
	          // ( types, selector, fn )
	          fn = data;
	          data = undefined;
	        } else {
	          // ( types, data, fn )
	          fn = data;
	          data = selector;
	          selector = undefined;
	        }
	      }
	      if (fn === false) {
	        fn = returnFalse;
	      } else if (!fn) {
	        return elem;
	      }
	      if (one === 1) {
	        origFn = fn;
	        fn = function (event) {
	          // Can use an empty set, since event contains the info
	          jQuery().off(event);
	          return origFn.apply(this, arguments);
	        };

	        // Use same guid so caller can remove using origFn
	        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
	      }
	      return elem.each(function () {
	        jQuery.event.add(this, types, fn, data, selector);
	      });
	    }

	    /*
	     * Helper functions for managing events -- not part of the public interface.
	     * Props to Dean Edwards' addEvent library for many of the ideas.
	     */
	    jQuery.event = {
	      global: {},
	      add: function (elem, types, handler, data, selector) {
	        var handleObjIn,
	          eventHandle,
	          tmp,
	          events,
	          t,
	          handleObj,
	          special,
	          handlers,
	          type,
	          namespaces,
	          origType,
	          elemData = dataPriv.get(elem);

	        // Don't attach events to noData or text/comment nodes (but allow plain objects)
	        if (!elemData) {
	          return;
	        }

	        // Caller can pass in an object of custom data in lieu of the handler
	        if (handler.handler) {
	          handleObjIn = handler;
	          handler = handleObjIn.handler;
	          selector = handleObjIn.selector;
	        }

	        // Ensure that invalid selectors throw exceptions at attach time
	        // Evaluate against documentElement in case elem is a non-element node (e.g., document)
	        if (selector) {
	          jQuery.find.matchesSelector(documentElement, selector);
	        }

	        // Make sure that the handler has a unique ID, used to find/remove it later
	        if (!handler.guid) {
	          handler.guid = jQuery.guid++;
	        }

	        // Init the element's event structure and main handler, if this is the first
	        if (!(events = elemData.events)) {
	          events = elemData.events = {};
	        }
	        if (!(eventHandle = elemData.handle)) {
	          eventHandle = elemData.handle = function (e) {
	            // Discard the second event of a jQuery.event.trigger() and
	            // when an event is called after a page has unloaded
	            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
	          };
	        }

	        // Handle multiple events separated by a space
	        types = (types || "").match(rnothtmlwhite) || [""];
	        t = types.length;
	        while (t--) {
	          tmp = rtypenamespace.exec(types[t]) || [];
	          type = origType = tmp[1];
	          namespaces = (tmp[2] || "").split(".").sort();

	          // There *must* be a type, no attaching namespace-only handlers
	          if (!type) {
	            continue;
	          }

	          // If event changes its type, use the special event handlers for the changed type
	          special = jQuery.event.special[type] || {};

	          // If selector defined, determine special event api type, otherwise given type
	          type = (selector ? special.delegateType : special.bindType) || type;

	          // Update special based on newly reset type
	          special = jQuery.event.special[type] || {};

	          // handleObj is passed to all event handlers
	          handleObj = jQuery.extend({
	            type: type,
	            origType: origType,
	            data: data,
	            handler: handler,
	            guid: handler.guid,
	            selector: selector,
	            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
	            namespace: namespaces.join(".")
	          }, handleObjIn);

	          // Init the event handler queue if we're the first
	          if (!(handlers = events[type])) {
	            handlers = events[type] = [];
	            handlers.delegateCount = 0;

	            // Only use addEventListener if the special events handler returns false
	            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	              if (elem.addEventListener) {
	                elem.addEventListener(type, eventHandle);
	              }
	            }
	          }
	          if (special.add) {
	            special.add.call(elem, handleObj);
	            if (!handleObj.handler.guid) {
	              handleObj.handler.guid = handler.guid;
	            }
	          }

	          // Add to the element's handler list, delegates in front
	          if (selector) {
	            handlers.splice(handlers.delegateCount++, 0, handleObj);
	          } else {
	            handlers.push(handleObj);
	          }

	          // Keep track of which events have ever been used, for event optimization
	          jQuery.event.global[type] = true;
	        }
	      },
	      // Detach an event or set of events from an element
	      remove: function (elem, types, handler, selector, mappedTypes) {
	        var j,
	          origCount,
	          tmp,
	          events,
	          t,
	          handleObj,
	          special,
	          handlers,
	          type,
	          namespaces,
	          origType,
	          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
	        if (!elemData || !(events = elemData.events)) {
	          return;
	        }

	        // Once for each type.namespace in types; type may be omitted
	        types = (types || "").match(rnothtmlwhite) || [""];
	        t = types.length;
	        while (t--) {
	          tmp = rtypenamespace.exec(types[t]) || [];
	          type = origType = tmp[1];
	          namespaces = (tmp[2] || "").split(".").sort();

	          // Unbind all events (on this namespace, if provided) for the element
	          if (!type) {
	            for (type in events) {
	              jQuery.event.remove(elem, type + types[t], handler, selector, true);
	            }
	            continue;
	          }
	          special = jQuery.event.special[type] || {};
	          type = (selector ? special.delegateType : special.bindType) || type;
	          handlers = events[type] || [];
	          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

	          // Remove matching events
	          origCount = j = handlers.length;
	          while (j--) {
	            handleObj = handlers[j];
	            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
	              handlers.splice(j, 1);
	              if (handleObj.selector) {
	                handlers.delegateCount--;
	              }
	              if (special.remove) {
	                special.remove.call(elem, handleObj);
	              }
	            }
	          }

	          // Remove generic event handler if we removed something and no more handlers exist
	          // (avoids potential for endless recursion during removal of special event handlers)
	          if (origCount && !handlers.length) {
	            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	              jQuery.removeEvent(elem, type, elemData.handle);
	            }
	            delete events[type];
	          }
	        }

	        // Remove data and the expando if it's no longer used
	        if (jQuery.isEmptyObject(events)) {
	          dataPriv.remove(elem, "handle events");
	        }
	      },
	      dispatch: function (nativeEvent) {
	        // Make a writable jQuery.Event from the native event object
	        var event = jQuery.event.fix(nativeEvent);
	        var i,
	          j,
	          ret,
	          matched,
	          handleObj,
	          handlerQueue,
	          args = new Array(arguments.length),
	          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
	          special = jQuery.event.special[event.type] || {};

	        // Use the fix-ed jQuery.Event rather than the (read-only) native event
	        args[0] = event;
	        for (i = 1; i < arguments.length; i++) {
	          args[i] = arguments[i];
	        }
	        event.delegateTarget = this;

	        // Call the preDispatch hook for the mapped type, and let it bail if desired
	        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
	          return;
	        }

	        // Determine handlers
	        handlerQueue = jQuery.event.handlers.call(this, event, handlers);

	        // Run delegates first; they may want to stop propagation beneath us
	        i = 0;
	        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
	          event.currentTarget = matched.elem;
	          j = 0;
	          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
	            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
	            // a subset or equal to those in the bound event (both can have no namespace).
	            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
	              event.handleObj = handleObj;
	              event.data = handleObj.data;
	              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
	              if (ret !== undefined) {
	                if ((event.result = ret) === false) {
	                  event.preventDefault();
	                  event.stopPropagation();
	                }
	              }
	            }
	          }
	        }

	        // Call the postDispatch hook for the mapped type
	        if (special.postDispatch) {
	          special.postDispatch.call(this, event);
	        }
	        return event.result;
	      },
	      handlers: function (event, handlers) {
	        var i,
	          handleObj,
	          sel,
	          matchedHandlers,
	          matchedSelectors,
	          handlerQueue = [],
	          delegateCount = handlers.delegateCount,
	          cur = event.target;

	        // Find delegate handlers
	        if (delegateCount &&
	        // Support: IE <=9
	        // Black-hole SVG <use> instance trees (trac-13180)
	        cur.nodeType &&
	        // Support: Firefox <=42
	        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
	        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
	        // Support: IE 11 only
	        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
	        !(event.type === "click" && event.button >= 1)) {
	          for (; cur !== this; cur = cur.parentNode || this) {
	            // Don't check non-elements (#13208)
	            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
	              matchedHandlers = [];
	              matchedSelectors = {};
	              for (i = 0; i < delegateCount; i++) {
	                handleObj = handlers[i];

	                // Don't conflict with Object.prototype properties (#13203)
	                sel = handleObj.selector + " ";
	                if (matchedSelectors[sel] === undefined) {
	                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
	                }
	                if (matchedSelectors[sel]) {
	                  matchedHandlers.push(handleObj);
	                }
	              }
	              if (matchedHandlers.length) {
	                handlerQueue.push({
	                  elem: cur,
	                  handlers: matchedHandlers
	                });
	              }
	            }
	          }
	        }

	        // Add the remaining (directly-bound) handlers
	        cur = this;
	        if (delegateCount < handlers.length) {
	          handlerQueue.push({
	            elem: cur,
	            handlers: handlers.slice(delegateCount)
	          });
	        }
	        return handlerQueue;
	      },
	      addProp: function (name, hook) {
	        Object.defineProperty(jQuery.Event.prototype, name, {
	          enumerable: true,
	          configurable: true,
	          get: jQuery.isFunction(hook) ? function () {
	            if (this.originalEvent) {
	              return hook(this.originalEvent);
	            }
	          } : function () {
	            if (this.originalEvent) {
	              return this.originalEvent[name];
	            }
	          },
	          set: function (value) {
	            Object.defineProperty(this, name, {
	              enumerable: true,
	              configurable: true,
	              writable: true,
	              value: value
	            });
	          }
	        });
	      },
	      fix: function (originalEvent) {
	        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
	      },
	      special: {
	        load: {
	          // Prevent triggered image.load events from bubbling to window.load
	          noBubble: true
	        },
	        focus: {
	          // Fire native event if possible so blur/focus sequence is correct
	          trigger: function () {
	            if (this !== safeActiveElement() && this.focus) {
	              this.focus();
	              return false;
	            }
	          },
	          delegateType: "focusin"
	        },
	        blur: {
	          trigger: function () {
	            if (this === safeActiveElement() && this.blur) {
	              this.blur();
	              return false;
	            }
	          },
	          delegateType: "focusout"
	        },
	        click: {
	          // For checkbox, fire native event so checked state will be right
	          trigger: function () {
	            if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
	              this.click();
	              return false;
	            }
	          },
	          // For cross-browser consistency, don't fire native .click() on links
	          _default: function (event) {
	            return nodeName(event.target, "a");
	          }
	        },
	        beforeunload: {
	          postDispatch: function (event) {
	            // Support: Firefox 20+
	            // Firefox doesn't alert if the returnValue field is not set.
	            if (event.result !== undefined && event.originalEvent) {
	              event.originalEvent.returnValue = event.result;
	            }
	          }
	        }
	      }
	    };
	    jQuery.removeEvent = function (elem, type, handle) {
	      // This "if" is needed for plain objects
	      if (elem.removeEventListener) {
	        elem.removeEventListener(type, handle);
	      }
	    };
	    jQuery.Event = function (src, props) {
	      // Allow instantiation without the 'new' keyword
	      if (!(this instanceof jQuery.Event)) {
	        return new jQuery.Event(src, props);
	      }

	      // Event object
	      if (src && src.type) {
	        this.originalEvent = src;
	        this.type = src.type;

	        // Events bubbling up the document may have been marked as prevented
	        // by a handler lower down the tree; reflect the correct value.
	        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
	        // Support: Android <=2.3 only
	        src.returnValue === false ? returnTrue : returnFalse;

	        // Create target properties
	        // Support: Safari <=6 - 7 only
	        // Target should not be a text node (#504, #13143)
	        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
	        this.currentTarget = src.currentTarget;
	        this.relatedTarget = src.relatedTarget;

	        // Event type
	      } else {
	        this.type = src;
	      }

	      // Put explicitly provided properties onto the event object
	      if (props) {
	        jQuery.extend(this, props);
	      }

	      // Create a timestamp if incoming event doesn't have one
	      this.timeStamp = src && src.timeStamp || jQuery.now();

	      // Mark it as fixed
	      this[jQuery.expando] = true;
	    };

	    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	    jQuery.Event.prototype = {
	      constructor: jQuery.Event,
	      isDefaultPrevented: returnFalse,
	      isPropagationStopped: returnFalse,
	      isImmediatePropagationStopped: returnFalse,
	      isSimulated: false,
	      preventDefault: function () {
	        var e = this.originalEvent;
	        this.isDefaultPrevented = returnTrue;
	        if (e && !this.isSimulated) {
	          e.preventDefault();
	        }
	      },
	      stopPropagation: function () {
	        var e = this.originalEvent;
	        this.isPropagationStopped = returnTrue;
	        if (e && !this.isSimulated) {
	          e.stopPropagation();
	        }
	      },
	      stopImmediatePropagation: function () {
	        var e = this.originalEvent;
	        this.isImmediatePropagationStopped = returnTrue;
	        if (e && !this.isSimulated) {
	          e.stopImmediatePropagation();
	        }
	        this.stopPropagation();
	      }
	    };

	    // Includes all common event props including KeyEvent and MouseEvent specific props
	    jQuery.each({
	      altKey: true,
	      bubbles: true,
	      cancelable: true,
	      changedTouches: true,
	      ctrlKey: true,
	      detail: true,
	      eventPhase: true,
	      metaKey: true,
	      pageX: true,
	      pageY: true,
	      shiftKey: true,
	      view: true,
	      "char": true,
	      charCode: true,
	      key: true,
	      keyCode: true,
	      button: true,
	      buttons: true,
	      clientX: true,
	      clientY: true,
	      offsetX: true,
	      offsetY: true,
	      pointerId: true,
	      pointerType: true,
	      screenX: true,
	      screenY: true,
	      targetTouches: true,
	      toElement: true,
	      touches: true,
	      which: function (event) {
	        var button = event.button;

	        // Add which for key events
	        if (event.which == null && rkeyEvent.test(event.type)) {
	          return event.charCode != null ? event.charCode : event.keyCode;
	        }

	        // Add which for click: 1 === left; 2 === middle; 3 === right
	        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
	          if (button & 1) {
	            return 1;
	          }
	          if (button & 2) {
	            return 3;
	          }
	          if (button & 4) {
	            return 2;
	          }
	          return 0;
	        }
	        return event.which;
	      }
	    }, jQuery.event.addProp);

	    // Create mouseenter/leave events using mouseover/out and event-time checks
	    // so that event delegation works in jQuery.
	    // Do the same for pointerenter/pointerleave and pointerover/pointerout
	    //
	    // Support: Safari 7 only
	    // Safari sends mouseenter too often; see:
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	    // for the description of the bug (it existed in older Chrome versions as well).
	    jQuery.each({
	      mouseenter: "mouseover",
	      mouseleave: "mouseout",
	      pointerenter: "pointerover",
	      pointerleave: "pointerout"
	    }, function (orig, fix) {
	      jQuery.event.special[orig] = {
	        delegateType: fix,
	        bindType: fix,
	        handle: function (event) {
	          var ret,
	            target = this,
	            related = event.relatedTarget,
	            handleObj = event.handleObj;

	          // For mouseenter/leave call the handler if related is outside the target.
	          // NB: No relatedTarget if the mouse left/entered the browser window
	          if (!related || related !== target && !jQuery.contains(target, related)) {
	            event.type = handleObj.origType;
	            ret = handleObj.handler.apply(this, arguments);
	            event.type = fix;
	          }
	          return ret;
	        }
	      };
	    });
	    jQuery.fn.extend({
	      on: function (types, selector, data, fn) {
	        return on(this, types, selector, data, fn);
	      },
	      one: function (types, selector, data, fn) {
	        return on(this, types, selector, data, fn, 1);
	      },
	      off: function (types, selector, fn) {
	        var handleObj, type;
	        if (types && types.preventDefault && types.handleObj) {
	          // ( event )  dispatched jQuery.Event
	          handleObj = types.handleObj;
	          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
	          return this;
	        }
	        if (typeof types === "object") {
	          // ( types-object [, selector] )
	          for (type in types) {
	            this.off(type, selector, types[type]);
	          }
	          return this;
	        }
	        if (selector === false || typeof selector === "function") {
	          // ( types [, fn] )
	          fn = selector;
	          selector = undefined;
	        }
	        if (fn === false) {
	          fn = returnFalse;
	        }
	        return this.each(function () {
	          jQuery.event.remove(this, types, fn, selector);
	        });
	      }
	    });
	    var /* eslint-disable max-len */

	      // See https://github.com/eslint/eslint/issues/3229
	      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
	      /* eslint-enable */

	      // Support: IE <=10 - 11, Edge 12 - 13
	      // In IE/Edge using regex groups here causes severe slowdowns.
	      // See https://connect.microsoft.com/IE/feedback/details/1736512/
	      rnoInnerhtml = /<script|<style|<link/i,
	      // checked="checked" or checked
	      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	      rscriptTypeMasked = /^true\/(.*)/,
	      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	    // Prefer a tbody over its parent table for containing new rows
	    function manipulationTarget(elem, content) {
	      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
	        return jQuery(">tbody", elem)[0] || elem;
	      }
	      return elem;
	    }

	    // Replace/restore the type attribute of script elements for safe DOM manipulation
	    function disableScript(elem) {
	      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	      return elem;
	    }
	    function restoreScript(elem) {
	      var match = rscriptTypeMasked.exec(elem.type);
	      if (match) {
	        elem.type = match[1];
	      } else {
	        elem.removeAttribute("type");
	      }
	      return elem;
	    }
	    function cloneCopyEvent(src, dest) {
	      var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	      if (dest.nodeType !== 1) {
	        return;
	      }

	      // 1. Copy private data: events, handlers, etc.
	      if (dataPriv.hasData(src)) {
	        pdataOld = dataPriv.access(src);
	        pdataCur = dataPriv.set(dest, pdataOld);
	        events = pdataOld.events;
	        if (events) {
	          delete pdataCur.handle;
	          pdataCur.events = {};
	          for (type in events) {
	            for (i = 0, l = events[type].length; i < l; i++) {
	              jQuery.event.add(dest, type, events[type][i]);
	            }
	          }
	        }
	      }

	      // 2. Copy user data
	      if (dataUser.hasData(src)) {
	        udataOld = dataUser.access(src);
	        udataCur = jQuery.extend({}, udataOld);
	        dataUser.set(dest, udataCur);
	      }
	    }

	    // Fix IE bugs, see support tests
	    function fixInput(src, dest) {
	      var nodeName = dest.nodeName.toLowerCase();

	      // Fails to persist the checked state of a cloned checkbox or radio button.
	      if (nodeName === "input" && rcheckableType.test(src.type)) {
	        dest.checked = src.checked;

	        // Fails to return the selected option to the default selected state when cloning options
	      } else if (nodeName === "input" || nodeName === "textarea") {
	        dest.defaultValue = src.defaultValue;
	      }
	    }
	    function domManip(collection, args, callback, ignored) {
	      // Flatten any nested arrays
	      args = concat.apply([], args);
	      var fragment,
	        first,
	        scripts,
	        hasScripts,
	        node,
	        doc,
	        i = 0,
	        l = collection.length,
	        iNoClone = l - 1,
	        value = args[0],
	        isFunction = jQuery.isFunction(value);

	      // We can't cloneNode fragments that contain checked, in WebKit
	      if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
	        return collection.each(function (index) {
	          var self = collection.eq(index);
	          if (isFunction) {
	            args[0] = value.call(this, index, self.html());
	          }
	          domManip(self, args, callback, ignored);
	        });
	      }
	      if (l) {
	        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
	        first = fragment.firstChild;
	        if (fragment.childNodes.length === 1) {
	          fragment = first;
	        }

	        // Require either new content or an interest in ignored elements to invoke the callback
	        if (first || ignored) {
	          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
	          hasScripts = scripts.length;

	          // Use the original fragment for the last item
	          // instead of the first because it can end up
	          // being emptied incorrectly in certain situations (#8070).
	          for (; i < l; i++) {
	            node = fragment;
	            if (i !== iNoClone) {
	              node = jQuery.clone(node, true, true);

	              // Keep references to cloned scripts for later restoration
	              if (hasScripts) {
	                // Support: Android <=4.0 only, PhantomJS 1 only
	                // push.apply(_, arraylike) throws on ancient WebKit
	                jQuery.merge(scripts, getAll(node, "script"));
	              }
	            }
	            callback.call(collection[i], node, i);
	          }
	          if (hasScripts) {
	            doc = scripts[scripts.length - 1].ownerDocument;

	            // Reenable scripts
	            jQuery.map(scripts, restoreScript);

	            // Evaluate executable scripts on first document insertion
	            for (i = 0; i < hasScripts; i++) {
	              node = scripts[i];
	              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
	                if (node.src) {
	                  // Optional AJAX dependency, but won't run scripts if not present
	                  if (jQuery._evalUrl) {
	                    jQuery._evalUrl(node.src);
	                  }
	                } else {
	                  DOMEval(node.textContent.replace(rcleanScript, ""), doc);
	                }
	              }
	            }
	          }
	        }
	      }
	      return collection;
	    }
	    function remove(elem, selector, keepData) {
	      var node,
	        nodes = selector ? jQuery.filter(selector, elem) : elem,
	        i = 0;
	      for (; (node = nodes[i]) != null; i++) {
	        if (!keepData && node.nodeType === 1) {
	          jQuery.cleanData(getAll(node));
	        }
	        if (node.parentNode) {
	          if (keepData && jQuery.contains(node.ownerDocument, node)) {
	            setGlobalEval(getAll(node, "script"));
	          }
	          node.parentNode.removeChild(node);
	        }
	      }
	      return elem;
	    }
	    jQuery.extend({
	      htmlPrefilter: function (html) {
	        return html.replace(rxhtmlTag, "<$1></$2>");
	      },
	      clone: function (elem, dataAndEvents, deepDataAndEvents) {
	        var i,
	          l,
	          srcElements,
	          destElements,
	          clone = elem.cloneNode(true),
	          inPage = jQuery.contains(elem.ownerDocument, elem);

	        // Fix IE cloning issues
	        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
	          // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
	          destElements = getAll(clone);
	          srcElements = getAll(elem);
	          for (i = 0, l = srcElements.length; i < l; i++) {
	            fixInput(srcElements[i], destElements[i]);
	          }
	        }

	        // Copy the events from the original to the clone
	        if (dataAndEvents) {
	          if (deepDataAndEvents) {
	            srcElements = srcElements || getAll(elem);
	            destElements = destElements || getAll(clone);
	            for (i = 0, l = srcElements.length; i < l; i++) {
	              cloneCopyEvent(srcElements[i], destElements[i]);
	            }
	          } else {
	            cloneCopyEvent(elem, clone);
	          }
	        }

	        // Preserve script evaluation history
	        destElements = getAll(clone, "script");
	        if (destElements.length > 0) {
	          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
	        }

	        // Return the cloned set
	        return clone;
	      },
	      cleanData: function (elems) {
	        var data,
	          elem,
	          type,
	          special = jQuery.event.special,
	          i = 0;
	        for (; (elem = elems[i]) !== undefined; i++) {
	          if (acceptData(elem)) {
	            if (data = elem[dataPriv.expando]) {
	              if (data.events) {
	                for (type in data.events) {
	                  if (special[type]) {
	                    jQuery.event.remove(elem, type);

	                    // This is a shortcut to avoid jQuery.event.remove's overhead
	                  } else {
	                    jQuery.removeEvent(elem, type, data.handle);
	                  }
	                }
	              }

	              // Support: Chrome <=35 - 45+
	              // Assign undefined instead of using delete, see Data#remove
	              elem[dataPriv.expando] = undefined;
	            }
	            if (elem[dataUser.expando]) {
	              // Support: Chrome <=35 - 45+
	              // Assign undefined instead of using delete, see Data#remove
	              elem[dataUser.expando] = undefined;
	            }
	          }
	        }
	      }
	    });
	    jQuery.fn.extend({
	      detach: function (selector) {
	        return remove(this, selector, true);
	      },
	      remove: function (selector) {
	        return remove(this, selector);
	      },
	      text: function (value) {
	        return access(this, function (value) {
	          return value === undefined ? jQuery.text(this) : this.empty().each(function () {
	            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	              this.textContent = value;
	            }
	          });
	        }, null, value, arguments.length);
	      },
	      append: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	            var target = manipulationTarget(this, elem);
	            target.appendChild(elem);
	          }
	        });
	      },
	      prepend: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
	            var target = manipulationTarget(this, elem);
	            target.insertBefore(elem, target.firstChild);
	          }
	        });
	      },
	      before: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.parentNode) {
	            this.parentNode.insertBefore(elem, this);
	          }
	        });
	      },
	      after: function () {
	        return domManip(this, arguments, function (elem) {
	          if (this.parentNode) {
	            this.parentNode.insertBefore(elem, this.nextSibling);
	          }
	        });
	      },
	      empty: function () {
	        var elem,
	          i = 0;
	        for (; (elem = this[i]) != null; i++) {
	          if (elem.nodeType === 1) {
	            // Prevent memory leaks
	            jQuery.cleanData(getAll(elem, false));

	            // Remove any remaining nodes
	            elem.textContent = "";
	          }
	        }
	        return this;
	      },
	      clone: function (dataAndEvents, deepDataAndEvents) {
	        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
	        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	        return this.map(function () {
	          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
	        });
	      },
	      html: function (value) {
	        return access(this, function (value) {
	          var elem = this[0] || {},
	            i = 0,
	            l = this.length;
	          if (value === undefined && elem.nodeType === 1) {
	            return elem.innerHTML;
	          }

	          // See if we can take a shortcut and just use innerHTML
	          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
	            value = jQuery.htmlPrefilter(value);
	            try {
	              for (; i < l; i++) {
	                elem = this[i] || {};

	                // Remove element nodes and prevent memory leaks
	                if (elem.nodeType === 1) {
	                  jQuery.cleanData(getAll(elem, false));
	                  elem.innerHTML = value;
	                }
	              }
	              elem = 0;

	              // If using innerHTML throws an exception, use the fallback method
	            } catch (e) {}
	          }
	          if (elem) {
	            this.empty().append(value);
	          }
	        }, null, value, arguments.length);
	      },
	      replaceWith: function () {
	        var ignored = [];

	        // Make the changes, replacing each non-ignored context element with the new content
	        return domManip(this, arguments, function (elem) {
	          var parent = this.parentNode;
	          if (jQuery.inArray(this, ignored) < 0) {
	            jQuery.cleanData(getAll(this));
	            if (parent) {
	              parent.replaceChild(elem, this);
	            }
	          }

	          // Force callback invocation
	        }, ignored);
	      }
	    });
	    jQuery.each({
	      appendTo: "append",
	      prependTo: "prepend",
	      insertBefore: "before",
	      insertAfter: "after",
	      replaceAll: "replaceWith"
	    }, function (name, original) {
	      jQuery.fn[name] = function (selector) {
	        var elems,
	          ret = [],
	          insert = jQuery(selector),
	          last = insert.length - 1,
	          i = 0;
	        for (; i <= last; i++) {
	          elems = i === last ? this : this.clone(true);
	          jQuery(insert[i])[original](elems);

	          // Support: Android <=4.0 only, PhantomJS 1 only
	          // .get() because push.apply(_, arraylike) throws on ancient WebKit
	          push.apply(ret, elems.get());
	        }
	        return this.pushStack(ret);
	      };
	    });
	    var rmargin = /^margin/;
	    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
	    var getStyles = function (elem) {
	      // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
	      // IE throws on elements created in popups
	      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
	      var view = elem.ownerDocument.defaultView;
	      if (!view || !view.opener) {
	        view = window;
	      }
	      return view.getComputedStyle(elem);
	    };
	    (function () {
	      // Executing both pixelPosition & boxSizingReliable tests require only one layout
	      // so they're executed at the same time to save the second computation.
	      function computeStyleTests() {
	        // This is a singleton, we need to execute it only once
	        if (!div) {
	          return;
	        }
	        div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
	        div.innerHTML = "";
	        documentElement.appendChild(container);
	        var divStyle = window.getComputedStyle(div);
	        pixelPositionVal = divStyle.top !== "1%";

	        // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
	        reliableMarginLeftVal = divStyle.marginLeft === "2px";
	        boxSizingReliableVal = divStyle.width === "4px";

	        // Support: Android 4.0 - 4.3 only
	        // Some styles come back with percentage values, even though they shouldn't
	        div.style.marginRight = "50%";
	        pixelMarginRightVal = divStyle.marginRight === "4px";
	        documentElement.removeChild(container);

	        // Nullify the div so it wouldn't be stored in the memory and
	        // it will also be a sign that checks already performed
	        div = null;
	      }
	      var pixelPositionVal,
	        boxSizingReliableVal,
	        pixelMarginRightVal,
	        reliableMarginLeftVal,
	        container = document.createElement("div"),
	        div = document.createElement("div");

	      // Finish early in limited (non-browser) environments
	      if (!div.style) {
	        return;
	      }

	      // Support: IE <=9 - 11 only
	      // Style of cloned element affects source element cloned (#8908)
	      div.style.backgroundClip = "content-box";
	      div.cloneNode(true).style.backgroundClip = "";
	      support.clearCloneStyle = div.style.backgroundClip === "content-box";
	      container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
	      container.appendChild(div);
	      jQuery.extend(support, {
	        pixelPosition: function () {
	          computeStyleTests();
	          return pixelPositionVal;
	        },
	        boxSizingReliable: function () {
	          computeStyleTests();
	          return boxSizingReliableVal;
	        },
	        pixelMarginRight: function () {
	          computeStyleTests();
	          return pixelMarginRightVal;
	        },
	        reliableMarginLeft: function () {
	          computeStyleTests();
	          return reliableMarginLeftVal;
	        }
	      });
	    })();
	    function curCSS(elem, name, computed) {
	      var width,
	        minWidth,
	        maxWidth,
	        ret,
	        // Support: Firefox 51+
	        // Retrieving style before computed somehow
	        // fixes an issue with getting wrong values
	        // on detached elements
	        style = elem.style;
	      computed = computed || getStyles(elem);

	      // getPropertyValue is needed for:
	      //   .css('filter') (IE 9 only, #12537)
	      //   .css('--customProperty) (#3144)
	      if (computed) {
	        ret = computed.getPropertyValue(name) || computed[name];
	        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
	          ret = jQuery.style(elem, name);
	        }

	        // A tribute to the "awesome hack by Dean Edwards"
	        // Android Browser returns percentage for some values,
	        // but width seems to be reliably pixels.
	        // This is against the CSSOM draft spec:
	        // https://drafts.csswg.org/cssom/#resolved-values
	        if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
	          // Remember the original values
	          width = style.width;
	          minWidth = style.minWidth;
	          maxWidth = style.maxWidth;

	          // Put in the new values to get a computed value out
	          style.minWidth = style.maxWidth = style.width = ret;
	          ret = computed.width;

	          // Revert the changed values
	          style.width = width;
	          style.minWidth = minWidth;
	          style.maxWidth = maxWidth;
	        }
	      }
	      return ret !== undefined ?
	      // Support: IE <=9 - 11 only
	      // IE returns zIndex value as an integer.
	      ret + "" : ret;
	    }
	    function addGetHookIf(conditionFn, hookFn) {
	      // Define the hook, we'll check on the first run if it's really needed.
	      return {
	        get: function () {
	          if (conditionFn()) {
	            // Hook not needed (or it's not possible to use it due
	            // to missing dependency), remove it.
	            delete this.get;
	            return;
	          }

	          // Hook needed; redefine it so that the support test is not executed again.
	          return (this.get = hookFn).apply(this, arguments);
	        }
	      };
	    }
	    var
	      // Swappable if display is none or starts with table
	      // except "table", "table-cell", or "table-caption"
	      // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	      rcustomProp = /^--/,
	      cssShow = {
	        position: "absolute",
	        visibility: "hidden",
	        display: "block"
	      },
	      cssNormalTransform = {
	        letterSpacing: "0",
	        fontWeight: "400"
	      },
	      cssPrefixes = ["Webkit", "Moz", "ms"],
	      emptyStyle = document.createElement("div").style;

	    // Return a css property mapped to a potentially vendor prefixed property
	    function vendorPropName(name) {
	      // Shortcut for names that are not vendor prefixed
	      if (name in emptyStyle) {
	        return name;
	      }

	      // Check for vendor prefixed names
	      var capName = name[0].toUpperCase() + name.slice(1),
	        i = cssPrefixes.length;
	      while (i--) {
	        name = cssPrefixes[i] + capName;
	        if (name in emptyStyle) {
	          return name;
	        }
	      }
	    }

	    // Return a property mapped along what jQuery.cssProps suggests or to
	    // a vendor prefixed property.
	    function finalPropName(name) {
	      var ret = jQuery.cssProps[name];
	      if (!ret) {
	        ret = jQuery.cssProps[name] = vendorPropName(name) || name;
	      }
	      return ret;
	    }
	    function setPositiveNumber(elem, value, subtract) {
	      // Any relative (+/-) values have already been
	      // normalized at this point
	      var matches = rcssNum.exec(value);
	      return matches ?
	      // Guard against undefined "subtract", e.g., when used as in cssHooks
	      Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	    }
	    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
	      var i,
	        val = 0;

	      // If we already have the right measurement, avoid augmentation
	      if (extra === (isBorderBox ? "border" : "content")) {
	        i = 4;

	        // Otherwise initialize for horizontal or vertical properties
	      } else {
	        i = name === "width" ? 1 : 0;
	      }
	      for (; i < 4; i += 2) {
	        // Both box models exclude margin, so add it if we want it
	        if (extra === "margin") {
	          val += jQuery.css(elem, extra + cssExpand[i], true, styles);
	        }
	        if (isBorderBox) {
	          // border-box includes padding, so remove it if we want content
	          if (extra === "content") {
	            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
	          }

	          // At this point, extra isn't border nor margin, so remove border
	          if (extra !== "margin") {
	            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	          }
	        } else {
	          // At this point, extra isn't content, so add padding
	          val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

	          // At this point, extra isn't content nor padding, so add border
	          if (extra !== "padding") {
	            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
	          }
	        }
	      }
	      return val;
	    }
	    function getWidthOrHeight(elem, name, extra) {
	      // Start with computed style
	      var valueIsBorderBox,
	        styles = getStyles(elem),
	        val = curCSS(elem, name, styles),
	        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

	      // Computed unit is not pixels. Stop here and return.
	      if (rnumnonpx.test(val)) {
	        return val;
	      }

	      // Check for style in case a browser which returns unreliable values
	      // for getComputedStyle silently falls back to the reliable elem.style
	      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

	      // Fall back to offsetWidth/Height when value is "auto"
	      // This happens for inline elements with no explicit setting (gh-3571)
	      if (val === "auto") {
	        val = elem["offset" + name[0].toUpperCase() + name.slice(1)];
	      }

	      // Normalize "", auto, and prepare for extra
	      val = parseFloat(val) || 0;

	      // Use the active box-sizing model to add/subtract irrelevant styles
	      return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	    }
	    jQuery.extend({
	      // Add in style property hooks for overriding the default
	      // behavior of getting and setting a style property
	      cssHooks: {
	        opacity: {
	          get: function (elem, computed) {
	            if (computed) {
	              // We should always get a number back from opacity
	              var ret = curCSS(elem, "opacity");
	              return ret === "" ? "1" : ret;
	            }
	          }
	        }
	      },
	      // Don't automatically add "px" to these possibly-unitless properties
	      cssNumber: {
	        "animationIterationCount": true,
	        "columnCount": true,
	        "fillOpacity": true,
	        "flexGrow": true,
	        "flexShrink": true,
	        "fontWeight": true,
	        "lineHeight": true,
	        "opacity": true,
	        "order": true,
	        "orphans": true,
	        "widows": true,
	        "zIndex": true,
	        "zoom": true
	      },
	      // Add in properties whose names you wish to fix before
	      // setting or getting the value
	      cssProps: {
	        "float": "cssFloat"
	      },
	      // Get and set the style property on a DOM Node
	      style: function (elem, name, value, extra) {
	        // Don't set styles on text and comment nodes
	        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
	          return;
	        }

	        // Make sure that we're working with the right name
	        var ret,
	          type,
	          hooks,
	          origName = jQuery.camelCase(name),
	          isCustomProp = rcustomProp.test(name),
	          style = elem.style;

	        // Make sure that we're working with the right name. We don't
	        // want to query the value if it is a CSS custom property
	        // since they are user-defined.
	        if (!isCustomProp) {
	          name = finalPropName(origName);
	        }

	        // Gets hook for the prefixed version, then unprefixed version
	        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

	        // Check if we're setting a value
	        if (value !== undefined) {
	          type = typeof value;

	          // Convert "+=" or "-=" to relative numbers (#7345)
	          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
	            value = adjustCSS(elem, name, ret);

	            // Fixes bug #9237
	            type = "number";
	          }

	          // Make sure that null and NaN values aren't set (#7116)
	          if (value == null || value !== value) {
	            return;
	          }

	          // If a number was passed in, add the unit (except for certain CSS properties)
	          if (type === "number") {
	            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
	          }

	          // background-* props affect original clone's values
	          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
	            style[name] = "inherit";
	          }

	          // If a hook was provided, use that value, otherwise just set the specified value
	          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
	            if (isCustomProp) {
	              style.setProperty(name, value);
	            } else {
	              style[name] = value;
	            }
	          }
	        } else {
	          // If a hook was provided get the non-computed value from there
	          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
	            return ret;
	          }

	          // Otherwise just get the value from the style object
	          return style[name];
	        }
	      },
	      css: function (elem, name, extra, styles) {
	        var val,
	          num,
	          hooks,
	          origName = jQuery.camelCase(name),
	          isCustomProp = rcustomProp.test(name);

	        // Make sure that we're working with the right name. We don't
	        // want to modify the value if it is a CSS custom property
	        // since they are user-defined.
	        if (!isCustomProp) {
	          name = finalPropName(origName);
	        }

	        // Try prefixed name followed by the unprefixed name
	        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

	        // If a hook was provided get the computed value from there
	        if (hooks && "get" in hooks) {
	          val = hooks.get(elem, true, extra);
	        }

	        // Otherwise, if a way to get the computed value exists, use that
	        if (val === undefined) {
	          val = curCSS(elem, name, styles);
	        }

	        // Convert "normal" to computed value
	        if (val === "normal" && name in cssNormalTransform) {
	          val = cssNormalTransform[name];
	        }

	        // Make numeric if forced or a qualifier was provided and val looks numeric
	        if (extra === "" || extra) {
	          num = parseFloat(val);
	          return extra === true || isFinite(num) ? num || 0 : val;
	        }
	        return val;
	      }
	    });
	    jQuery.each(["height", "width"], function (i, name) {
	      jQuery.cssHooks[name] = {
	        get: function (elem, computed, extra) {
	          if (computed) {
	            // Certain elements can have dimension info if we invisibly show them
	            // but it must have a current display style that would benefit
	            return rdisplayswap.test(jQuery.css(elem, "display")) && (
	            // Support: Safari 8+
	            // Table columns in Safari have non-zero offsetWidth & zero
	            // getBoundingClientRect().width unless display is changed.
	            // Support: IE <=11 only
	            // Running getBoundingClientRect on a disconnected node
	            // in IE throws an error.
	            !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
	              return getWidthOrHeight(elem, name, extra);
	            }) : getWidthOrHeight(elem, name, extra);
	          }
	        },
	        set: function (elem, value, extra) {
	          var matches,
	            styles = extra && getStyles(elem),
	            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

	          // Convert to pixels if value adjustment is needed
	          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
	            elem.style[name] = value;
	            value = jQuery.css(elem, name);
	          }
	          return setPositiveNumber(elem, value, subtract);
	        }
	      };
	    });
	    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
	      if (computed) {
	        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
	          marginLeft: 0
	        }, function () {
	          return elem.getBoundingClientRect().left;
	        })) + "px";
	      }
	    });

	    // These hooks are used by animate to expand properties
	    jQuery.each({
	      margin: "",
	      padding: "",
	      border: "Width"
	    }, function (prefix, suffix) {
	      jQuery.cssHooks[prefix + suffix] = {
	        expand: function (value) {
	          var i = 0,
	            expanded = {},
	            // Assumes a single number if not a string
	            parts = typeof value === "string" ? value.split(" ") : [value];
	          for (; i < 4; i++) {
	            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
	          }
	          return expanded;
	        }
	      };
	      if (!rmargin.test(prefix)) {
	        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
	      }
	    });
	    jQuery.fn.extend({
	      css: function (name, value) {
	        return access(this, function (elem, name, value) {
	          var styles,
	            len,
	            map = {},
	            i = 0;
	          if (Array.isArray(name)) {
	            styles = getStyles(elem);
	            len = name.length;
	            for (; i < len; i++) {
	              map[name[i]] = jQuery.css(elem, name[i], false, styles);
	            }
	            return map;
	          }
	          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
	        }, name, value, arguments.length > 1);
	      }
	    });
	    function Tween(elem, options, prop, end, easing) {
	      return new Tween.prototype.init(elem, options, prop, end, easing);
	    }
	    jQuery.Tween = Tween;
	    Tween.prototype = {
	      constructor: Tween,
	      init: function (elem, options, prop, end, easing, unit) {
	        this.elem = elem;
	        this.prop = prop;
	        this.easing = easing || jQuery.easing._default;
	        this.options = options;
	        this.start = this.now = this.cur();
	        this.end = end;
	        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
	      },
	      cur: function () {
	        var hooks = Tween.propHooks[this.prop];
	        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
	      },
	      run: function (percent) {
	        var eased,
	          hooks = Tween.propHooks[this.prop];
	        if (this.options.duration) {
	          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
	        } else {
	          this.pos = eased = percent;
	        }
	        this.now = (this.end - this.start) * eased + this.start;
	        if (this.options.step) {
	          this.options.step.call(this.elem, this.now, this);
	        }
	        if (hooks && hooks.set) {
	          hooks.set(this);
	        } else {
	          Tween.propHooks._default.set(this);
	        }
	        return this;
	      }
	    };
	    Tween.prototype.init.prototype = Tween.prototype;
	    Tween.propHooks = {
	      _default: {
	        get: function (tween) {
	          var result;

	          // Use a property on the element directly when it is not a DOM element,
	          // or when there is no matching style property that exists.
	          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
	            return tween.elem[tween.prop];
	          }

	          // Passing an empty string as a 3rd parameter to .css will automatically
	          // attempt a parseFloat and fallback to a string if the parse fails.
	          // Simple values such as "10px" are parsed to Float;
	          // complex values such as "rotate(1rad)" are returned as-is.
	          result = jQuery.css(tween.elem, tween.prop, "");

	          // Empty strings, null, undefined and "auto" are converted to 0.
	          return !result || result === "auto" ? 0 : result;
	        },
	        set: function (tween) {
	          // Use step hook for back compat.
	          // Use cssHook if its there.
	          // Use .style if available and use plain properties where available.
	          if (jQuery.fx.step[tween.prop]) {
	            jQuery.fx.step[tween.prop](tween);
	          } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
	            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
	          } else {
	            tween.elem[tween.prop] = tween.now;
	          }
	        }
	      }
	    };

	    // Support: IE <=9 only
	    // Panic based approach to setting things on disconnected nodes
	    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	      set: function (tween) {
	        if (tween.elem.nodeType && tween.elem.parentNode) {
	          tween.elem[tween.prop] = tween.now;
	        }
	      }
	    };
	    jQuery.easing = {
	      linear: function (p) {
	        return p;
	      },
	      swing: function (p) {
	        return 0.5 - Math.cos(p * Math.PI) / 2;
	      },
	      _default: "swing"
	    };
	    jQuery.fx = Tween.prototype.init;

	    // Back compat <1.8 extension point
	    jQuery.fx.step = {};
	    var fxNow,
	      inProgress,
	      rfxtypes = /^(?:toggle|show|hide)$/,
	      rrun = /queueHooks$/;
	    function schedule() {
	      if (inProgress) {
	        if (document.hidden === false && window.requestAnimationFrame) {
	          window.requestAnimationFrame(schedule);
	        } else {
	          window.setTimeout(schedule, jQuery.fx.interval);
	        }
	        jQuery.fx.tick();
	      }
	    }

	    // Animations created synchronously will run synchronously
	    function createFxNow() {
	      window.setTimeout(function () {
	        fxNow = undefined;
	      });
	      return fxNow = jQuery.now();
	    }

	    // Generate parameters to create a standard animation
	    function genFx(type, includeWidth) {
	      var which,
	        i = 0,
	        attrs = {
	          height: type
	        };

	      // If we include width, step value is 1 to do all cssExpand values,
	      // otherwise step value is 2 to skip over Left and Right
	      includeWidth = includeWidth ? 1 : 0;
	      for (; i < 4; i += 2 - includeWidth) {
	        which = cssExpand[i];
	        attrs["margin" + which] = attrs["padding" + which] = type;
	      }
	      if (includeWidth) {
	        attrs.opacity = attrs.width = type;
	      }
	      return attrs;
	    }
	    function createTween(value, prop, animation) {
	      var tween,
	        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
	        index = 0,
	        length = collection.length;
	      for (; index < length; index++) {
	        if (tween = collection[index].call(animation, prop, value)) {
	          // We're done with this property
	          return tween;
	        }
	      }
	    }
	    function defaultPrefilter(elem, props, opts) {
	      var prop,
	        value,
	        toggle,
	        hooks,
	        oldfire,
	        propTween,
	        restoreDisplay,
	        display,
	        isBox = "width" in props || "height" in props,
	        anim = this,
	        orig = {},
	        style = elem.style,
	        hidden = elem.nodeType && isHiddenWithinTree(elem),
	        dataShow = dataPriv.get(elem, "fxshow");

	      // Queue-skipping animations hijack the fx hooks
	      if (!opts.queue) {
	        hooks = jQuery._queueHooks(elem, "fx");
	        if (hooks.unqueued == null) {
	          hooks.unqueued = 0;
	          oldfire = hooks.empty.fire;
	          hooks.empty.fire = function () {
	            if (!hooks.unqueued) {
	              oldfire();
	            }
	          };
	        }
	        hooks.unqueued++;
	        anim.always(function () {
	          // Ensure the complete handler is called before this completes
	          anim.always(function () {
	            hooks.unqueued--;
	            if (!jQuery.queue(elem, "fx").length) {
	              hooks.empty.fire();
	            }
	          });
	        });
	      }

	      // Detect show/hide animations
	      for (prop in props) {
	        value = props[prop];
	        if (rfxtypes.test(value)) {
	          delete props[prop];
	          toggle = toggle || value === "toggle";
	          if (value === (hidden ? "hide" : "show")) {
	            // Pretend to be hidden if this is a "show" and
	            // there is still data from a stopped show/hide
	            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
	              hidden = true;

	              // Ignore all other no-op show/hide data
	            } else {
	              continue;
	            }
	          }
	          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
	        }
	      }

	      // Bail out if this is a no-op like .hide().hide()
	      propTween = !jQuery.isEmptyObject(props);
	      if (!propTween && jQuery.isEmptyObject(orig)) {
	        return;
	      }

	      // Restrict "overflow" and "display" styles during box animations
	      if (isBox && elem.nodeType === 1) {
	        // Support: IE <=9 - 11, Edge 12 - 13
	        // Record all 3 overflow attributes because IE does not infer the shorthand
	        // from identically-valued overflowX and overflowY
	        opts.overflow = [style.overflow, style.overflowX, style.overflowY];

	        // Identify a display type, preferring old show/hide data over the CSS cascade
	        restoreDisplay = dataShow && dataShow.display;
	        if (restoreDisplay == null) {
	          restoreDisplay = dataPriv.get(elem, "display");
	        }
	        display = jQuery.css(elem, "display");
	        if (display === "none") {
	          if (restoreDisplay) {
	            display = restoreDisplay;
	          } else {
	            // Get nonempty value(s) by temporarily forcing visibility
	            showHide([elem], true);
	            restoreDisplay = elem.style.display || restoreDisplay;
	            display = jQuery.css(elem, "display");
	            showHide([elem]);
	          }
	        }

	        // Animate inline elements as inline-block
	        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
	          if (jQuery.css(elem, "float") === "none") {
	            // Restore the original display value at the end of pure show/hide animations
	            if (!propTween) {
	              anim.done(function () {
	                style.display = restoreDisplay;
	              });
	              if (restoreDisplay == null) {
	                display = style.display;
	                restoreDisplay = display === "none" ? "" : display;
	              }
	            }
	            style.display = "inline-block";
	          }
	        }
	      }
	      if (opts.overflow) {
	        style.overflow = "hidden";
	        anim.always(function () {
	          style.overflow = opts.overflow[0];
	          style.overflowX = opts.overflow[1];
	          style.overflowY = opts.overflow[2];
	        });
	      }

	      // Implement show/hide animations
	      propTween = false;
	      for (prop in orig) {
	        // General show/hide setup for this element animation
	        if (!propTween) {
	          if (dataShow) {
	            if ("hidden" in dataShow) {
	              hidden = dataShow.hidden;
	            }
	          } else {
	            dataShow = dataPriv.access(elem, "fxshow", {
	              display: restoreDisplay
	            });
	          }

	          // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
	          if (toggle) {
	            dataShow.hidden = !hidden;
	          }

	          // Show elements before animating them
	          if (hidden) {
	            showHide([elem], true);
	          }

	          /* eslint-disable no-loop-func */

	          anim.done(function () {
	            /* eslint-enable no-loop-func */

	            // The final step of a "hide" animation is actually hiding the element
	            if (!hidden) {
	              showHide([elem]);
	            }
	            dataPriv.remove(elem, "fxshow");
	            for (prop in orig) {
	              jQuery.style(elem, prop, orig[prop]);
	            }
	          });
	        }

	        // Per-property setup
	        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
	        if (!(prop in dataShow)) {
	          dataShow[prop] = propTween.start;
	          if (hidden) {
	            propTween.end = propTween.start;
	            propTween.start = 0;
	          }
	        }
	      }
	    }
	    function propFilter(props, specialEasing) {
	      var index, name, easing, value, hooks;

	      // camelCase, specialEasing and expand cssHook pass
	      for (index in props) {
	        name = jQuery.camelCase(index);
	        easing = specialEasing[name];
	        value = props[index];
	        if (Array.isArray(value)) {
	          easing = value[1];
	          value = props[index] = value[0];
	        }
	        if (index !== name) {
	          props[name] = value;
	          delete props[index];
	        }
	        hooks = jQuery.cssHooks[name];
	        if (hooks && "expand" in hooks) {
	          value = hooks.expand(value);
	          delete props[name];

	          // Not quite $.extend, this won't overwrite existing keys.
	          // Reusing 'index' because we have the correct "name"
	          for (index in value) {
	            if (!(index in props)) {
	              props[index] = value[index];
	              specialEasing[index] = easing;
	            }
	          }
	        } else {
	          specialEasing[name] = easing;
	        }
	      }
	    }
	    function Animation(elem, properties, options) {
	      var result,
	        stopped,
	        index = 0,
	        length = Animation.prefilters.length,
	        deferred = jQuery.Deferred().always(function () {
	          // Don't match elem in the :animated selector
	          delete tick.elem;
	        }),
	        tick = function () {
	          if (stopped) {
	            return false;
	          }
	          var currentTime = fxNow || createFxNow(),
	            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
	            // Support: Android 2.3 only
	            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
	            temp = remaining / animation.duration || 0,
	            percent = 1 - temp,
	            index = 0,
	            length = animation.tweens.length;
	          for (; index < length; index++) {
	            animation.tweens[index].run(percent);
	          }
	          deferred.notifyWith(elem, [animation, percent, remaining]);

	          // If there's more to do, yield
	          if (percent < 1 && length) {
	            return remaining;
	          }

	          // If this was an empty animation, synthesize a final progress notification
	          if (!length) {
	            deferred.notifyWith(elem, [animation, 1, 0]);
	          }

	          // Resolve the animation and report its conclusion
	          deferred.resolveWith(elem, [animation]);
	          return false;
	        },
	        animation = deferred.promise({
	          elem: elem,
	          props: jQuery.extend({}, properties),
	          opts: jQuery.extend(true, {
	            specialEasing: {},
	            easing: jQuery.easing._default
	          }, options),
	          originalProperties: properties,
	          originalOptions: options,
	          startTime: fxNow || createFxNow(),
	          duration: options.duration,
	          tweens: [],
	          createTween: function (prop, end) {
	            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
	            animation.tweens.push(tween);
	            return tween;
	          },
	          stop: function (gotoEnd) {
	            var index = 0,
	              // If we are going to the end, we want to run all the tweens
	              // otherwise we skip this part
	              length = gotoEnd ? animation.tweens.length : 0;
	            if (stopped) {
	              return this;
	            }
	            stopped = true;
	            for (; index < length; index++) {
	              animation.tweens[index].run(1);
	            }

	            // Resolve when we played the last frame; otherwise, reject
	            if (gotoEnd) {
	              deferred.notifyWith(elem, [animation, 1, 0]);
	              deferred.resolveWith(elem, [animation, gotoEnd]);
	            } else {
	              deferred.rejectWith(elem, [animation, gotoEnd]);
	            }
	            return this;
	          }
	        }),
	        props = animation.props;
	      propFilter(props, animation.opts.specialEasing);
	      for (; index < length; index++) {
	        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
	        if (result) {
	          if (jQuery.isFunction(result.stop)) {
	            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
	          }
	          return result;
	        }
	      }
	      jQuery.map(props, createTween, animation);
	      if (jQuery.isFunction(animation.opts.start)) {
	        animation.opts.start.call(elem, animation);
	      }

	      // Attach callbacks from options
	      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	      jQuery.fx.timer(jQuery.extend(tick, {
	        elem: elem,
	        anim: animation,
	        queue: animation.opts.queue
	      }));
	      return animation;
	    }
	    jQuery.Animation = jQuery.extend(Animation, {
	      tweeners: {
	        "*": [function (prop, value) {
	          var tween = this.createTween(prop, value);
	          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
	          return tween;
	        }]
	      },
	      tweener: function (props, callback) {
	        if (jQuery.isFunction(props)) {
	          callback = props;
	          props = ["*"];
	        } else {
	          props = props.match(rnothtmlwhite);
	        }
	        var prop,
	          index = 0,
	          length = props.length;
	        for (; index < length; index++) {
	          prop = props[index];
	          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
	          Animation.tweeners[prop].unshift(callback);
	        }
	      },
	      prefilters: [defaultPrefilter],
	      prefilter: function (callback, prepend) {
	        if (prepend) {
	          Animation.prefilters.unshift(callback);
	        } else {
	          Animation.prefilters.push(callback);
	        }
	      }
	    });
	    jQuery.speed = function (speed, easing, fn) {
	      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
	        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
	        duration: speed,
	        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
	      };

	      // Go to the end state if fx are off
	      if (jQuery.fx.off) {
	        opt.duration = 0;
	      } else {
	        if (typeof opt.duration !== "number") {
	          if (opt.duration in jQuery.fx.speeds) {
	            opt.duration = jQuery.fx.speeds[opt.duration];
	          } else {
	            opt.duration = jQuery.fx.speeds._default;
	          }
	        }
	      }

	      // Normalize opt.queue - true/undefined/null -> "fx"
	      if (opt.queue == null || opt.queue === true) {
	        opt.queue = "fx";
	      }

	      // Queueing
	      opt.old = opt.complete;
	      opt.complete = function () {
	        if (jQuery.isFunction(opt.old)) {
	          opt.old.call(this);
	        }
	        if (opt.queue) {
	          jQuery.dequeue(this, opt.queue);
	        }
	      };
	      return opt;
	    };
	    jQuery.fn.extend({
	      fadeTo: function (speed, to, easing, callback) {
	        // Show any hidden elements after setting opacity to 0
	        return this.filter(isHiddenWithinTree).css("opacity", 0).show()

	        // Animate to the value specified
	        .end().animate({
	          opacity: to
	        }, speed, easing, callback);
	      },
	      animate: function (prop, speed, easing, callback) {
	        var empty = jQuery.isEmptyObject(prop),
	          optall = jQuery.speed(speed, easing, callback),
	          doAnimation = function () {
	            // Operate on a copy of prop so per-property easing won't be lost
	            var anim = Animation(this, jQuery.extend({}, prop), optall);

	            // Empty animations, or finishing resolves immediately
	            if (empty || dataPriv.get(this, "finish")) {
	              anim.stop(true);
	            }
	          };
	        doAnimation.finish = doAnimation;
	        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
	      },
	      stop: function (type, clearQueue, gotoEnd) {
	        var stopQueue = function (hooks) {
	          var stop = hooks.stop;
	          delete hooks.stop;
	          stop(gotoEnd);
	        };
	        if (typeof type !== "string") {
	          gotoEnd = clearQueue;
	          clearQueue = type;
	          type = undefined;
	        }
	        if (clearQueue && type !== false) {
	          this.queue(type || "fx", []);
	        }
	        return this.each(function () {
	          var dequeue = true,
	            index = type != null && type + "queueHooks",
	            timers = jQuery.timers,
	            data = dataPriv.get(this);
	          if (index) {
	            if (data[index] && data[index].stop) {
	              stopQueue(data[index]);
	            }
	          } else {
	            for (index in data) {
	              if (data[index] && data[index].stop && rrun.test(index)) {
	                stopQueue(data[index]);
	              }
	            }
	          }
	          for (index = timers.length; index--;) {
	            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
	              timers[index].anim.stop(gotoEnd);
	              dequeue = false;
	              timers.splice(index, 1);
	            }
	          }

	          // Start the next in the queue if the last step wasn't forced.
	          // Timers currently will call their complete callbacks, which
	          // will dequeue but only if they were gotoEnd.
	          if (dequeue || !gotoEnd) {
	            jQuery.dequeue(this, type);
	          }
	        });
	      },
	      finish: function (type) {
	        if (type !== false) {
	          type = type || "fx";
	        }
	        return this.each(function () {
	          var index,
	            data = dataPriv.get(this),
	            queue = data[type + "queue"],
	            hooks = data[type + "queueHooks"],
	            timers = jQuery.timers,
	            length = queue ? queue.length : 0;

	          // Enable finishing flag on private data
	          data.finish = true;

	          // Empty the queue first
	          jQuery.queue(this, type, []);
	          if (hooks && hooks.stop) {
	            hooks.stop.call(this, true);
	          }

	          // Look for any active animations, and finish them
	          for (index = timers.length; index--;) {
	            if (timers[index].elem === this && timers[index].queue === type) {
	              timers[index].anim.stop(true);
	              timers.splice(index, 1);
	            }
	          }

	          // Look for any animations in the old queue and finish them
	          for (index = 0; index < length; index++) {
	            if (queue[index] && queue[index].finish) {
	              queue[index].finish.call(this);
	            }
	          }

	          // Turn off finishing flag
	          delete data.finish;
	        });
	      }
	    });
	    jQuery.each(["toggle", "show", "hide"], function (i, name) {
	      var cssFn = jQuery.fn[name];
	      jQuery.fn[name] = function (speed, easing, callback) {
	        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
	      };
	    });

	    // Generate shortcuts for custom animations
	    jQuery.each({
	      slideDown: genFx("show"),
	      slideUp: genFx("hide"),
	      slideToggle: genFx("toggle"),
	      fadeIn: {
	        opacity: "show"
	      },
	      fadeOut: {
	        opacity: "hide"
	      },
	      fadeToggle: {
	        opacity: "toggle"
	      }
	    }, function (name, props) {
	      jQuery.fn[name] = function (speed, easing, callback) {
	        return this.animate(props, speed, easing, callback);
	      };
	    });
	    jQuery.timers = [];
	    jQuery.fx.tick = function () {
	      var timer,
	        i = 0,
	        timers = jQuery.timers;
	      fxNow = jQuery.now();
	      for (; i < timers.length; i++) {
	        timer = timers[i];

	        // Run the timer and safely remove it when done (allowing for external removal)
	        if (!timer() && timers[i] === timer) {
	          timers.splice(i--, 1);
	        }
	      }
	      if (!timers.length) {
	        jQuery.fx.stop();
	      }
	      fxNow = undefined;
	    };
	    jQuery.fx.timer = function (timer) {
	      jQuery.timers.push(timer);
	      jQuery.fx.start();
	    };
	    jQuery.fx.interval = 13;
	    jQuery.fx.start = function () {
	      if (inProgress) {
	        return;
	      }
	      inProgress = true;
	      schedule();
	    };
	    jQuery.fx.stop = function () {
	      inProgress = null;
	    };
	    jQuery.fx.speeds = {
	      slow: 600,
	      fast: 200,
	      // Default speed
	      _default: 400
	    };

	    // Based off of the plugin by Clint Helfers, with permission.
	    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	    jQuery.fn.delay = function (time, type) {
	      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
	      type = type || "fx";
	      return this.queue(type, function (next, hooks) {
	        var timeout = window.setTimeout(next, time);
	        hooks.stop = function () {
	          window.clearTimeout(timeout);
	        };
	      });
	    };
	    (function () {
	      var input = document.createElement("input"),
	        select = document.createElement("select"),
	        opt = select.appendChild(document.createElement("option"));
	      input.type = "checkbox";

	      // Support: Android <=4.3 only
	      // Default value for a checkbox should be "on"
	      support.checkOn = input.value !== "";

	      // Support: IE <=11 only
	      // Must access selectedIndex to make default options select
	      support.optSelected = opt.selected;

	      // Support: IE <=11 only
	      // An input loses its value after becoming a radio
	      input = document.createElement("input");
	      input.value = "t";
	      input.type = "radio";
	      support.radioValue = input.value === "t";
	    })();
	    var boolHook,
	      attrHandle = jQuery.expr.attrHandle;
	    jQuery.fn.extend({
	      attr: function (name, value) {
	        return access(this, jQuery.attr, name, value, arguments.length > 1);
	      },
	      removeAttr: function (name) {
	        return this.each(function () {
	          jQuery.removeAttr(this, name);
	        });
	      }
	    });
	    jQuery.extend({
	      attr: function (elem, name, value) {
	        var ret,
	          hooks,
	          nType = elem.nodeType;

	        // Don't get/set attributes on text, comment and attribute nodes
	        if (nType === 3 || nType === 8 || nType === 2) {
	          return;
	        }

	        // Fallback to prop when attributes are not supported
	        if (typeof elem.getAttribute === "undefined") {
	          return jQuery.prop(elem, name, value);
	        }

	        // Attribute hooks are determined by the lowercase version
	        // Grab necessary hook if one is defined
	        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
	        }
	        if (value !== undefined) {
	          if (value === null) {
	            jQuery.removeAttr(elem, name);
	            return;
	          }
	          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	            return ret;
	          }
	          elem.setAttribute(name, value + "");
	          return value;
	        }
	        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	          return ret;
	        }
	        ret = jQuery.find.attr(elem, name);

	        // Non-existent attributes return null, we normalize to undefined
	        return ret == null ? undefined : ret;
	      },
	      attrHooks: {
	        type: {
	          set: function (elem, value) {
	            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
	              var val = elem.value;
	              elem.setAttribute("type", value);
	              if (val) {
	                elem.value = val;
	              }
	              return value;
	            }
	          }
	        }
	      },
	      removeAttr: function (elem, value) {
	        var name,
	          i = 0,
	          // Attribute names can contain non-HTML whitespace characters
	          // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	          attrNames = value && value.match(rnothtmlwhite);
	        if (attrNames && elem.nodeType === 1) {
	          while (name = attrNames[i++]) {
	            elem.removeAttribute(name);
	          }
	        }
	      }
	    });

	    // Hooks for boolean attributes
	    boolHook = {
	      set: function (elem, value, name) {
	        if (value === false) {
	          // Remove boolean attributes when set to false
	          jQuery.removeAttr(elem, name);
	        } else {
	          elem.setAttribute(name, name);
	        }
	        return name;
	      }
	    };
	    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
	      var getter = attrHandle[name] || jQuery.find.attr;
	      attrHandle[name] = function (elem, name, isXML) {
	        var ret,
	          handle,
	          lowercaseName = name.toLowerCase();
	        if (!isXML) {
	          // Avoid an infinite loop by temporarily removing this function from the getter
	          handle = attrHandle[lowercaseName];
	          attrHandle[lowercaseName] = ret;
	          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
	          attrHandle[lowercaseName] = handle;
	        }
	        return ret;
	      };
	    });
	    var rfocusable = /^(?:input|select|textarea|button)$/i,
	      rclickable = /^(?:a|area)$/i;
	    jQuery.fn.extend({
	      prop: function (name, value) {
	        return access(this, jQuery.prop, name, value, arguments.length > 1);
	      },
	      removeProp: function (name) {
	        return this.each(function () {
	          delete this[jQuery.propFix[name] || name];
	        });
	      }
	    });
	    jQuery.extend({
	      prop: function (elem, name, value) {
	        var ret,
	          hooks,
	          nType = elem.nodeType;

	        // Don't get/set properties on text, comment and attribute nodes
	        if (nType === 3 || nType === 8 || nType === 2) {
	          return;
	        }
	        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	          // Fix name and attach hooks
	          name = jQuery.propFix[name] || name;
	          hooks = jQuery.propHooks[name];
	        }
	        if (value !== undefined) {
	          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
	            return ret;
	          }
	          return elem[name] = value;
	        }
	        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
	          return ret;
	        }
	        return elem[name];
	      },
	      propHooks: {
	        tabIndex: {
	          get: function (elem) {
	            // Support: IE <=9 - 11 only
	            // elem.tabIndex doesn't always return the
	            // correct value when it hasn't been explicitly set
	            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
	            // Use proper attribute retrieval(#12072)
	            var tabindex = jQuery.find.attr(elem, "tabindex");
	            if (tabindex) {
	              return parseInt(tabindex, 10);
	            }
	            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
	              return 0;
	            }
	            return -1;
	          }
	        }
	      },
	      propFix: {
	        "for": "htmlFor",
	        "class": "className"
	      }
	    });

	    // Support: IE <=11 only
	    // Accessing the selectedIndex property
	    // forces the browser to respect setting selected
	    // on the option
	    // The getter ensures a default option is selected
	    // when in an optgroup
	    // eslint rule "no-unused-expressions" is disabled for this code
	    // since it considers such accessions noop
	    if (!support.optSelected) {
	      jQuery.propHooks.selected = {
	        get: function (elem) {
	          /* eslint no-unused-expressions: "off" */

	          var parent = elem.parentNode;
	          if (parent && parent.parentNode) {
	            parent.parentNode.selectedIndex;
	          }
	          return null;
	        },
	        set: function (elem) {
	          /* eslint no-unused-expressions: "off" */

	          var parent = elem.parentNode;
	          if (parent) {
	            parent.selectedIndex;
	            if (parent.parentNode) {
	              parent.parentNode.selectedIndex;
	            }
	          }
	        }
	      };
	    }
	    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
	      jQuery.propFix[this.toLowerCase()] = this;
	    });

	    // Strip and collapse whitespace according to HTML spec
	    // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	    function stripAndCollapse(value) {
	      var tokens = value.match(rnothtmlwhite) || [];
	      return tokens.join(" ");
	    }
	    function getClass(elem) {
	      return elem.getAttribute && elem.getAttribute("class") || "";
	    }
	    jQuery.fn.extend({
	      addClass: function (value) {
	        var classes,
	          elem,
	          cur,
	          curValue,
	          clazz,
	          j,
	          finalValue,
	          i = 0;
	        if (jQuery.isFunction(value)) {
	          return this.each(function (j) {
	            jQuery(this).addClass(value.call(this, j, getClass(this)));
	          });
	        }
	        if (typeof value === "string" && value) {
	          classes = value.match(rnothtmlwhite) || [];
	          while (elem = this[i++]) {
	            curValue = getClass(elem);
	            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
	            if (cur) {
	              j = 0;
	              while (clazz = classes[j++]) {
	                if (cur.indexOf(" " + clazz + " ") < 0) {
	                  cur += clazz + " ";
	                }
	              }

	              // Only assign if different to avoid unneeded rendering.
	              finalValue = stripAndCollapse(cur);
	              if (curValue !== finalValue) {
	                elem.setAttribute("class", finalValue);
	              }
	            }
	          }
	        }
	        return this;
	      },
	      removeClass: function (value) {
	        var classes,
	          elem,
	          cur,
	          curValue,
	          clazz,
	          j,
	          finalValue,
	          i = 0;
	        if (jQuery.isFunction(value)) {
	          return this.each(function (j) {
	            jQuery(this).removeClass(value.call(this, j, getClass(this)));
	          });
	        }
	        if (!arguments.length) {
	          return this.attr("class", "");
	        }
	        if (typeof value === "string" && value) {
	          classes = value.match(rnothtmlwhite) || [];
	          while (elem = this[i++]) {
	            curValue = getClass(elem);

	            // This expression is here for better compressibility (see addClass)
	            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
	            if (cur) {
	              j = 0;
	              while (clazz = classes[j++]) {
	                // Remove *all* instances
	                while (cur.indexOf(" " + clazz + " ") > -1) {
	                  cur = cur.replace(" " + clazz + " ", " ");
	                }
	              }

	              // Only assign if different to avoid unneeded rendering.
	              finalValue = stripAndCollapse(cur);
	              if (curValue !== finalValue) {
	                elem.setAttribute("class", finalValue);
	              }
	            }
	          }
	        }
	        return this;
	      },
	      toggleClass: function (value, stateVal) {
	        var type = typeof value;
	        if (typeof stateVal === "boolean" && type === "string") {
	          return stateVal ? this.addClass(value) : this.removeClass(value);
	        }
	        if (jQuery.isFunction(value)) {
	          return this.each(function (i) {
	            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
	          });
	        }
	        return this.each(function () {
	          var className, i, self, classNames;
	          if (type === "string") {
	            // Toggle individual class names
	            i = 0;
	            self = jQuery(this);
	            classNames = value.match(rnothtmlwhite) || [];
	            while (className = classNames[i++]) {
	              // Check each className given, space separated list
	              if (self.hasClass(className)) {
	                self.removeClass(className);
	              } else {
	                self.addClass(className);
	              }
	            }

	            // Toggle whole class name
	          } else if (value === undefined || type === "boolean") {
	            className = getClass(this);
	            if (className) {
	              // Store className if set
	              dataPriv.set(this, "__className__", className);
	            }

	            // If the element has a class name or if we're passed `false`,
	            // then remove the whole classname (if there was one, the above saved it).
	            // Otherwise bring back whatever was previously saved (if anything),
	            // falling back to the empty string if nothing was stored.
	            if (this.setAttribute) {
	              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
	            }
	          }
	        });
	      },
	      hasClass: function (selector) {
	        var className,
	          elem,
	          i = 0;
	        className = " " + selector + " ";
	        while (elem = this[i++]) {
	          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
	            return true;
	          }
	        }
	        return false;
	      }
	    });
	    var rreturn = /\r/g;
	    jQuery.fn.extend({
	      val: function (value) {
	        var hooks,
	          ret,
	          isFunction,
	          elem = this[0];
	        if (!arguments.length) {
	          if (elem) {
	            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
	            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
	              return ret;
	            }
	            ret = elem.value;

	            // Handle most common string cases
	            if (typeof ret === "string") {
	              return ret.replace(rreturn, "");
	            }

	            // Handle cases where value is null/undef or number
	            return ret == null ? "" : ret;
	          }
	          return;
	        }
	        isFunction = jQuery.isFunction(value);
	        return this.each(function (i) {
	          var val;
	          if (this.nodeType !== 1) {
	            return;
	          }
	          if (isFunction) {
	            val = value.call(this, i, jQuery(this).val());
	          } else {
	            val = value;
	          }

	          // Treat null/undefined as ""; convert numbers to string
	          if (val == null) {
	            val = "";
	          } else if (typeof val === "number") {
	            val += "";
	          } else if (Array.isArray(val)) {
	            val = jQuery.map(val, function (value) {
	              return value == null ? "" : value + "";
	            });
	          }
	          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

	          // If set returns undefined, fall back to normal setting
	          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
	            this.value = val;
	          }
	        });
	      }
	    });
	    jQuery.extend({
	      valHooks: {
	        option: {
	          get: function (elem) {
	            var val = jQuery.find.attr(elem, "value");
	            return val != null ? val :
	            // Support: IE <=10 - 11 only
	            // option.text throws exceptions (#14686, #14858)
	            // Strip and collapse whitespace
	            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
	            stripAndCollapse(jQuery.text(elem));
	          }
	        },
	        select: {
	          get: function (elem) {
	            var value,
	              option,
	              i,
	              options = elem.options,
	              index = elem.selectedIndex,
	              one = elem.type === "select-one",
	              values = one ? null : [],
	              max = one ? index + 1 : options.length;
	            if (index < 0) {
	              i = max;
	            } else {
	              i = one ? index : 0;
	            }

	            // Loop through all the selected options
	            for (; i < max; i++) {
	              option = options[i];

	              // Support: IE <=9 only
	              // IE8-9 doesn't update selected after form reset (#2551)
	              if ((option.selected || i === index) &&
	              // Don't return options that are disabled or in a disabled optgroup
	              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
	                // Get the specific value for the option
	                value = jQuery(option).val();

	                // We don't need an array for one selects
	                if (one) {
	                  return value;
	                }

	                // Multi-Selects return an array
	                values.push(value);
	              }
	            }
	            return values;
	          },
	          set: function (elem, value) {
	            var optionSet,
	              option,
	              options = elem.options,
	              values = jQuery.makeArray(value),
	              i = options.length;
	            while (i--) {
	              option = options[i];

	              /* eslint-disable no-cond-assign */

	              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
	                optionSet = true;
	              }

	              /* eslint-enable no-cond-assign */
	            }

	            // Force browsers to behave consistently when non-matching value is set
	            if (!optionSet) {
	              elem.selectedIndex = -1;
	            }
	            return values;
	          }
	        }
	      }
	    });

	    // Radios and checkboxes getter/setter
	    jQuery.each(["radio", "checkbox"], function () {
	      jQuery.valHooks[this] = {
	        set: function (elem, value) {
	          if (Array.isArray(value)) {
	            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
	          }
	        }
	      };
	      if (!support.checkOn) {
	        jQuery.valHooks[this].get = function (elem) {
	          return elem.getAttribute("value") === null ? "on" : elem.value;
	        };
	      }
	    });

	    // Return jQuery for attributes-only inclusion

	    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	    jQuery.extend(jQuery.event, {
	      trigger: function (event, data, elem, onlyHandlers) {
	        var i,
	          cur,
	          tmp,
	          bubbleType,
	          ontype,
	          handle,
	          special,
	          eventPath = [elem || document],
	          type = hasOwn.call(event, "type") ? event.type : event,
	          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
	        cur = tmp = elem = elem || document;

	        // Don't do events on text and comment nodes
	        if (elem.nodeType === 3 || elem.nodeType === 8) {
	          return;
	        }

	        // focus/blur morphs to focusin/out; ensure we're not firing them right now
	        if (rfocusMorph.test(type + jQuery.event.triggered)) {
	          return;
	        }
	        if (type.indexOf(".") > -1) {
	          // Namespaced trigger; create a regexp to match event type in handle()
	          namespaces = type.split(".");
	          type = namespaces.shift();
	          namespaces.sort();
	        }
	        ontype = type.indexOf(":") < 0 && "on" + type;

	        // Caller can pass in a jQuery.Event object, Object, or just an event type string
	        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

	        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
	        event.isTrigger = onlyHandlers ? 2 : 3;
	        event.namespace = namespaces.join(".");
	        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

	        // Clean up the event in case it is being reused
	        event.result = undefined;
	        if (!event.target) {
	          event.target = elem;
	        }

	        // Clone any incoming data and prepend the event, creating the handler arg list
	        data = data == null ? [event] : jQuery.makeArray(data, [event]);

	        // Allow special events to draw outside the lines
	        special = jQuery.event.special[type] || {};
	        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
	          return;
	        }

	        // Determine event propagation path in advance, per W3C events spec (#9951)
	        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	        if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
	          bubbleType = special.delegateType || type;
	          if (!rfocusMorph.test(bubbleType + type)) {
	            cur = cur.parentNode;
	          }
	          for (; cur; cur = cur.parentNode) {
	            eventPath.push(cur);
	            tmp = cur;
	          }

	          // Only add window if we got to document (e.g., not plain obj or detached DOM)
	          if (tmp === (elem.ownerDocument || document)) {
	            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
	          }
	        }

	        // Fire handlers on the event path
	        i = 0;
	        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
	          event.type = i > 1 ? bubbleType : special.bindType || type;

	          // jQuery handler
	          handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
	          if (handle) {
	            handle.apply(cur, data);
	          }

	          // Native handler
	          handle = ontype && cur[ontype];
	          if (handle && handle.apply && acceptData(cur)) {
	            event.result = handle.apply(cur, data);
	            if (event.result === false) {
	              event.preventDefault();
	            }
	          }
	        }
	        event.type = type;

	        // If nobody prevented the default action, do it now
	        if (!onlyHandlers && !event.isDefaultPrevented()) {
	          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
	            // Call a native DOM method on the target with the same name as the event.
	            // Don't do default actions on window, that's where global variables be (#6170)
	            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
	              // Don't re-trigger an onFOO event when we call its FOO() method
	              tmp = elem[ontype];
	              if (tmp) {
	                elem[ontype] = null;
	              }

	              // Prevent re-triggering of the same event, since we already bubbled it above
	              jQuery.event.triggered = type;
	              elem[type]();
	              jQuery.event.triggered = undefined;
	              if (tmp) {
	                elem[ontype] = tmp;
	              }
	            }
	          }
	        }
	        return event.result;
	      },
	      // Piggyback on a donor event to simulate a different one
	      // Used only for `focus(in | out)` events
	      simulate: function (type, elem, event) {
	        var e = jQuery.extend(new jQuery.Event(), event, {
	          type: type,
	          isSimulated: true
	        });
	        jQuery.event.trigger(e, null, elem);
	      }
	    });
	    jQuery.fn.extend({
	      trigger: function (type, data) {
	        return this.each(function () {
	          jQuery.event.trigger(type, data, this);
	        });
	      },
	      triggerHandler: function (type, data) {
	        var elem = this[0];
	        if (elem) {
	          return jQuery.event.trigger(type, data, elem, true);
	        }
	      }
	    });
	    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
	      // Handle event binding
	      jQuery.fn[name] = function (data, fn) {
	        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
	      };
	    });
	    jQuery.fn.extend({
	      hover: function (fnOver, fnOut) {
	        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
	      }
	    });
	    support.focusin = "onfocusin" in window;

	    // Support: Firefox <=44
	    // Firefox doesn't have focus(in | out) events
	    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	    //
	    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	    // focus(in | out) events fire after focus & blur events,
	    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	    if (!support.focusin) {
	      jQuery.each({
	        focus: "focusin",
	        blur: "focusout"
	      }, function (orig, fix) {
	        // Attach a single capturing handler on the document while someone wants focusin/focusout
	        var handler = function (event) {
	          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
	        };
	        jQuery.event.special[fix] = {
	          setup: function () {
	            var doc = this.ownerDocument || this,
	              attaches = dataPriv.access(doc, fix);
	            if (!attaches) {
	              doc.addEventListener(orig, handler, true);
	            }
	            dataPriv.access(doc, fix, (attaches || 0) + 1);
	          },
	          teardown: function () {
	            var doc = this.ownerDocument || this,
	              attaches = dataPriv.access(doc, fix) - 1;
	            if (!attaches) {
	              doc.removeEventListener(orig, handler, true);
	              dataPriv.remove(doc, fix);
	            } else {
	              dataPriv.access(doc, fix, attaches);
	            }
	          }
	        };
	      });
	    }
	    var location = window.location;
	    var nonce = jQuery.now();
	    var rquery = /\?/;

	    // Cross-browser xml parsing
	    jQuery.parseXML = function (data) {
	      var xml;
	      if (!data || typeof data !== "string") {
	        return null;
	      }

	      // Support: IE 9 - 11 only
	      // IE throws on parseFromString with invalid input.
	      try {
	        xml = new window.DOMParser().parseFromString(data, "text/xml");
	      } catch (e) {
	        xml = undefined;
	      }
	      if (!xml || xml.getElementsByTagName("parsererror").length) {
	        jQuery.error("Invalid XML: " + data);
	      }
	      return xml;
	    };
	    var rbracket = /\[\]$/,
	      rCRLF = /\r?\n/g,
	      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	      rsubmittable = /^(?:input|select|textarea|keygen)/i;
	    function buildParams(prefix, obj, traditional, add) {
	      var name;
	      if (Array.isArray(obj)) {
	        // Serialize array item.
	        jQuery.each(obj, function (i, v) {
	          if (traditional || rbracket.test(prefix)) {
	            // Treat each array item as a scalar.
	            add(prefix, v);
	          } else {
	            // Item is non-scalar (array or object), encode its numeric index.
	            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
	          }
	        });
	      } else if (!traditional && jQuery.type(obj) === "object") {
	        // Serialize object item.
	        for (name in obj) {
	          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
	        }
	      } else {
	        // Serialize scalar item.
	        add(prefix, obj);
	      }
	    }

	    // Serialize an array of form elements or a set of
	    // key/values into a query string
	    jQuery.param = function (a, traditional) {
	      var prefix,
	        s = [],
	        add = function (key, valueOrFunction) {
	          // If value is a function, invoke it and use its return value
	          var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
	          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
	        };

	      // If an array was passed in, assume that it is an array of form elements.
	      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
	        // Serialize the form elements
	        jQuery.each(a, function () {
	          add(this.name, this.value);
	        });
	      } else {
	        // If traditional, encode the "old" way (the way 1.3.2 or older
	        // did it), otherwise encode params recursively.
	        for (prefix in a) {
	          buildParams(prefix, a[prefix], traditional, add);
	        }
	      }

	      // Return the resulting serialization
	      return s.join("&");
	    };
	    jQuery.fn.extend({
	      serialize: function () {
	        return jQuery.param(this.serializeArray());
	      },
	      serializeArray: function () {
	        return this.map(function () {
	          // Can add propHook for "elements" to filter or add form elements
	          var elements = jQuery.prop(this, "elements");
	          return elements ? jQuery.makeArray(elements) : this;
	        }).filter(function () {
	          var type = this.type;

	          // Use .is( ":disabled" ) so that fieldset[disabled] works
	          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
	        }).map(function (i, elem) {
	          var val = jQuery(this).val();
	          if (val == null) {
	            return null;
	          }
	          if (Array.isArray(val)) {
	            return jQuery.map(val, function (val) {
	              return {
	                name: elem.name,
	                value: val.replace(rCRLF, "\r\n")
	              };
	            });
	          }
	          return {
	            name: elem.name,
	            value: val.replace(rCRLF, "\r\n")
	          };
	        }).get();
	      }
	    });
	    var r20 = /%20/g,
	      rhash = /#.*$/,
	      rantiCache = /([?&])_=[^&]*/,
	      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	      // #7653, #8125, #8152: local protocol detection
	      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	      rnoContent = /^(?:GET|HEAD)$/,
	      rprotocol = /^\/\//,
	      /* Prefilters
	       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	       * 2) These are called:
	       *    - BEFORE asking for a transport
	       *    - AFTER param serialization (s.data is a string if s.processData is true)
	       * 3) key is the dataType
	       * 4) the catchall symbol "*" can be used
	       * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	       */
	      prefilters = {},
	      /* Transports bindings
	       * 1) key is the dataType
	       * 2) the catchall symbol "*" can be used
	       * 3) selection will start with transport dataType and THEN go to "*" if needed
	       */
	      transports = {},
	      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	      allTypes = "*/".concat("*"),
	      // Anchor tag for parsing the document origin
	      originAnchor = document.createElement("a");
	    originAnchor.href = location.href;

	    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	    function addToPrefiltersOrTransports(structure) {
	      // dataTypeExpression is optional and defaults to "*"
	      return function (dataTypeExpression, func) {
	        if (typeof dataTypeExpression !== "string") {
	          func = dataTypeExpression;
	          dataTypeExpression = "*";
	        }
	        var dataType,
	          i = 0,
	          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
	        if (jQuery.isFunction(func)) {
	          // For each dataType in the dataTypeExpression
	          while (dataType = dataTypes[i++]) {
	            // Prepend if requested
	            if (dataType[0] === "+") {
	              dataType = dataType.slice(1) || "*";
	              (structure[dataType] = structure[dataType] || []).unshift(func);

	              // Otherwise append
	            } else {
	              (structure[dataType] = structure[dataType] || []).push(func);
	            }
	          }
	        }
	      };
	    }

	    // Base inspection function for prefilters and transports
	    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
	      var inspected = {},
	        seekingTransport = structure === transports;
	      function inspect(dataType) {
	        var selected;
	        inspected[dataType] = true;
	        jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
	          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
	          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
	            options.dataTypes.unshift(dataTypeOrTransport);
	            inspect(dataTypeOrTransport);
	            return false;
	          } else if (seekingTransport) {
	            return !(selected = dataTypeOrTransport);
	          }
	        });
	        return selected;
	      }
	      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	    }

	    // A special extend for ajax options
	    // that takes "flat" options (not to be deep extended)
	    // Fixes #9887
	    function ajaxExtend(target, src) {
	      var key,
	        deep,
	        flatOptions = jQuery.ajaxSettings.flatOptions || {};
	      for (key in src) {
	        if (src[key] !== undefined) {
	          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
	        }
	      }
	      if (deep) {
	        jQuery.extend(true, target, deep);
	      }
	      return target;
	    }

	    /* Handles responses to an ajax request:
	     * - finds the right dataType (mediates between content-type and expected dataType)
	     * - returns the corresponding response
	     */
	    function ajaxHandleResponses(s, jqXHR, responses) {
	      var ct,
	        type,
	        finalDataType,
	        firstDataType,
	        contents = s.contents,
	        dataTypes = s.dataTypes;

	      // Remove auto dataType and get content-type in the process
	      while (dataTypes[0] === "*") {
	        dataTypes.shift();
	        if (ct === undefined) {
	          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
	        }
	      }

	      // Check if we're dealing with a known content-type
	      if (ct) {
	        for (type in contents) {
	          if (contents[type] && contents[type].test(ct)) {
	            dataTypes.unshift(type);
	            break;
	          }
	        }
	      }

	      // Check to see if we have a response for the expected dataType
	      if (dataTypes[0] in responses) {
	        finalDataType = dataTypes[0];
	      } else {
	        // Try convertible dataTypes
	        for (type in responses) {
	          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
	            finalDataType = type;
	            break;
	          }
	          if (!firstDataType) {
	            firstDataType = type;
	          }
	        }

	        // Or just use first one
	        finalDataType = finalDataType || firstDataType;
	      }

	      // If we found a dataType
	      // We add the dataType to the list if needed
	      // and return the corresponding response
	      if (finalDataType) {
	        if (finalDataType !== dataTypes[0]) {
	          dataTypes.unshift(finalDataType);
	        }
	        return responses[finalDataType];
	      }
	    }

	    /* Chain conversions given the request and the original response
	     * Also sets the responseXXX fields on the jqXHR instance
	     */
	    function ajaxConvert(s, response, jqXHR, isSuccess) {
	      var conv2,
	        current,
	        conv,
	        tmp,
	        prev,
	        converters = {},
	        // Work with a copy of dataTypes in case we need to modify it for conversion
	        dataTypes = s.dataTypes.slice();

	      // Create converters map with lowercased keys
	      if (dataTypes[1]) {
	        for (conv in s.converters) {
	          converters[conv.toLowerCase()] = s.converters[conv];
	        }
	      }
	      current = dataTypes.shift();

	      // Convert to each sequential dataType
	      while (current) {
	        if (s.responseFields[current]) {
	          jqXHR[s.responseFields[current]] = response;
	        }

	        // Apply the dataFilter if provided
	        if (!prev && isSuccess && s.dataFilter) {
	          response = s.dataFilter(response, s.dataType);
	        }
	        prev = current;
	        current = dataTypes.shift();
	        if (current) {
	          // There's only work to do if current dataType is non-auto
	          if (current === "*") {
	            current = prev;

	            // Convert response if prev dataType is non-auto and differs from current
	          } else if (prev !== "*" && prev !== current) {
	            // Seek a direct converter
	            conv = converters[prev + " " + current] || converters["* " + current];

	            // If none found, seek a pair
	            if (!conv) {
	              for (conv2 in converters) {
	                // If conv2 outputs current
	                tmp = conv2.split(" ");
	                if (tmp[1] === current) {
	                  // If prev can be converted to accepted input
	                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
	                  if (conv) {
	                    // Condense equivalence converters
	                    if (conv === true) {
	                      conv = converters[conv2];

	                      // Otherwise, insert the intermediate dataType
	                    } else if (converters[conv2] !== true) {
	                      current = tmp[0];
	                      dataTypes.unshift(tmp[1]);
	                    }
	                    break;
	                  }
	                }
	              }
	            }

	            // Apply converter (if not an equivalence)
	            if (conv !== true) {
	              // Unless errors are allowed to bubble, catch and return them
	              if (conv && s.throws) {
	                response = conv(response);
	              } else {
	                try {
	                  response = conv(response);
	                } catch (e) {
	                  return {
	                    state: "parsererror",
	                    error: conv ? e : "No conversion from " + prev + " to " + current
	                  };
	                }
	              }
	            }
	          }
	        }
	      }
	      return {
	        state: "success",
	        data: response
	      };
	    }
	    jQuery.extend({
	      // Counter for holding the number of active queries
	      active: 0,
	      // Last-Modified header cache for next request
	      lastModified: {},
	      etag: {},
	      ajaxSettings: {
	        url: location.href,
	        type: "GET",
	        isLocal: rlocalProtocol.test(location.protocol),
	        global: true,
	        processData: true,
	        async: true,
	        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	        /*
	        timeout: 0,
	        data: null,
	        dataType: null,
	        username: null,
	        password: null,
	        cache: null,
	        throws: false,
	        traditional: false,
	        headers: {},
	        */

	        accepts: {
	          "*": allTypes,
	          text: "text/plain",
	          html: "text/html",
	          xml: "application/xml, text/xml",
	          json: "application/json, text/javascript"
	        },
	        contents: {
	          xml: /\bxml\b/,
	          html: /\bhtml/,
	          json: /\bjson\b/
	        },
	        responseFields: {
	          xml: "responseXML",
	          text: "responseText",
	          json: "responseJSON"
	        },
	        // Data converters
	        // Keys separate source (or catchall "*") and destination types with a single space
	        converters: {
	          // Convert anything to text
	          "* text": String,
	          // Text to html (true = no transformation)
	          "text html": true,
	          // Evaluate text as a json expression
	          "text json": JSON.parse,
	          // Parse text as xml
	          "text xml": jQuery.parseXML
	        },
	        // For options that shouldn't be deep extended:
	        // you can add your own custom options here if
	        // and when you create one that shouldn't be
	        // deep extended (see ajaxExtend)
	        flatOptions: {
	          url: true,
	          context: true
	        }
	      },
	      // Creates a full fledged settings object into target
	      // with both ajaxSettings and settings fields.
	      // If target is omitted, writes into ajaxSettings.
	      ajaxSetup: function (target, settings) {
	        return settings ?
	        // Building a settings object
	        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
	        // Extending ajaxSettings
	        ajaxExtend(jQuery.ajaxSettings, target);
	      },
	      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
	      ajaxTransport: addToPrefiltersOrTransports(transports),
	      // Main method
	      ajax: function (url, options) {
	        // If url is an object, simulate pre-1.5 signature
	        if (typeof url === "object") {
	          options = url;
	          url = undefined;
	        }

	        // Force options to be an object
	        options = options || {};
	        var transport,
	          // URL without anti-cache param
	          cacheURL,
	          // Response headers
	          responseHeadersString,
	          responseHeaders,
	          // timeout handle
	          timeoutTimer,
	          // Url cleanup var
	          urlAnchor,
	          // Request state (becomes false upon send and true upon completion)
	          completed,
	          // To know if global events are to be dispatched
	          fireGlobals,
	          // Loop variable
	          i,
	          // uncached part of the url
	          uncached,
	          // Create the final options object
	          s = jQuery.ajaxSetup({}, options),
	          // Callbacks context
	          callbackContext = s.context || s,
	          // Context for global events is callbackContext if it is a DOM node or jQuery collection
	          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
	          // Deferreds
	          deferred = jQuery.Deferred(),
	          completeDeferred = jQuery.Callbacks("once memory"),
	          // Status-dependent callbacks
	          statusCode = s.statusCode || {},
	          // Headers (they are sent all at once)
	          requestHeaders = {},
	          requestHeadersNames = {},
	          // Default abort message
	          strAbort = "canceled",
	          // Fake xhr
	          jqXHR = {
	            readyState: 0,
	            // Builds headers hashtable if needed
	            getResponseHeader: function (key) {
	              var match;
	              if (completed) {
	                if (!responseHeaders) {
	                  responseHeaders = {};
	                  while (match = rheaders.exec(responseHeadersString)) {
	                    responseHeaders[match[1].toLowerCase()] = match[2];
	                  }
	                }
	                match = responseHeaders[key.toLowerCase()];
	              }
	              return match == null ? null : match;
	            },
	            // Raw string
	            getAllResponseHeaders: function () {
	              return completed ? responseHeadersString : null;
	            },
	            // Caches the header
	            setRequestHeader: function (name, value) {
	              if (completed == null) {
	                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
	                requestHeaders[name] = value;
	              }
	              return this;
	            },
	            // Overrides response content-type header
	            overrideMimeType: function (type) {
	              if (completed == null) {
	                s.mimeType = type;
	              }
	              return this;
	            },
	            // Status-dependent callbacks
	            statusCode: function (map) {
	              var code;
	              if (map) {
	                if (completed) {
	                  // Execute the appropriate callbacks
	                  jqXHR.always(map[jqXHR.status]);
	                } else {
	                  // Lazy-add the new callbacks in a way that preserves old ones
	                  for (code in map) {
	                    statusCode[code] = [statusCode[code], map[code]];
	                  }
	                }
	              }
	              return this;
	            },
	            // Cancel the request
	            abort: function (statusText) {
	              var finalText = statusText || strAbort;
	              if (transport) {
	                transport.abort(finalText);
	              }
	              done(0, finalText);
	              return this;
	            }
	          };

	        // Attach deferreds
	        deferred.promise(jqXHR);

	        // Add protocol if not provided (prefilters might expect it)
	        // Handle falsy url in the settings object (#10093: consistency with old signature)
	        // We also use the url parameter if available
	        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");

	        // Alias method option to type as per ticket #12004
	        s.type = options.method || options.type || s.method || s.type;

	        // Extract dataTypes list
	        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

	        // A cross-domain request is in order when the origin doesn't match the current origin.
	        if (s.crossDomain == null) {
	          urlAnchor = document.createElement("a");

	          // Support: IE <=8 - 11, Edge 12 - 13
	          // IE throws exception on accessing the href property if url is malformed,
	          // e.g. http://example.com:80x/
	          try {
	            urlAnchor.href = s.url;

	            // Support: IE <=8 - 11 only
	            // Anchor's host property isn't correctly set when s.url is relative
	            urlAnchor.href = urlAnchor.href;
	            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
	          } catch (e) {
	            // If there is an error parsing the URL, assume it is crossDomain,
	            // it can be rejected by the transport if it is invalid
	            s.crossDomain = true;
	          }
	        }

	        // Convert data if not already a string
	        if (s.data && s.processData && typeof s.data !== "string") {
	          s.data = jQuery.param(s.data, s.traditional);
	        }

	        // Apply prefilters
	        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

	        // If request was aborted inside a prefilter, stop there
	        if (completed) {
	          return jqXHR;
	        }

	        // We can fire global events as of now if asked to
	        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
	        fireGlobals = jQuery.event && s.global;

	        // Watch for a new set of requests
	        if (fireGlobals && jQuery.active++ === 0) {
	          jQuery.event.trigger("ajaxStart");
	        }

	        // Uppercase the type
	        s.type = s.type.toUpperCase();

	        // Determine if request has content
	        s.hasContent = !rnoContent.test(s.type);

	        // Save the URL in case we're toying with the If-Modified-Since
	        // and/or If-None-Match header later on
	        // Remove hash to simplify url manipulation
	        cacheURL = s.url.replace(rhash, "");

	        // More options handling for requests with no content
	        if (!s.hasContent) {
	          // Remember the hash so we can put it back
	          uncached = s.url.slice(cacheURL.length);

	          // If data is available, append data to url
	          if (s.data) {
	            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

	            // #9682: remove data so that it's not used in an eventual retry
	            delete s.data;
	          }

	          // Add or update anti-cache param if needed
	          if (s.cache === false) {
	            cacheURL = cacheURL.replace(rantiCache, "$1");
	            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
	          }

	          // Put hash and anti-cache on the URL that will be requested (gh-1732)
	          s.url = cacheURL + uncached;

	          // Change '%20' to '+' if this is encoded form body content (gh-2658)
	        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
	          s.data = s.data.replace(r20, "+");
	        }

	        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	        if (s.ifModified) {
	          if (jQuery.lastModified[cacheURL]) {
	            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
	          }
	          if (jQuery.etag[cacheURL]) {
	            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
	          }
	        }

	        // Set the correct header, if data is being sent
	        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
	          jqXHR.setRequestHeader("Content-Type", s.contentType);
	        }

	        // Set the Accepts header for the server, depending on the dataType
	        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

	        // Check for headers option
	        for (i in s.headers) {
	          jqXHR.setRequestHeader(i, s.headers[i]);
	        }

	        // Allow custom headers/mimetypes and early abort
	        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
	          // Abort if not done already and return
	          return jqXHR.abort();
	        }

	        // Aborting is no longer a cancellation
	        strAbort = "abort";

	        // Install callbacks on deferreds
	        completeDeferred.add(s.complete);
	        jqXHR.done(s.success);
	        jqXHR.fail(s.error);

	        // Get transport
	        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

	        // If no transport, we auto-abort
	        if (!transport) {
	          done(-1, "No Transport");
	        } else {
	          jqXHR.readyState = 1;

	          // Send global event
	          if (fireGlobals) {
	            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
	          }

	          // If request was aborted inside ajaxSend, stop there
	          if (completed) {
	            return jqXHR;
	          }

	          // Timeout
	          if (s.async && s.timeout > 0) {
	            timeoutTimer = window.setTimeout(function () {
	              jqXHR.abort("timeout");
	            }, s.timeout);
	          }
	          try {
	            completed = false;
	            transport.send(requestHeaders, done);
	          } catch (e) {
	            // Rethrow post-completion exceptions
	            if (completed) {
	              throw e;
	            }

	            // Propagate others as results
	            done(-1, e);
	          }
	        }

	        // Callback for when everything is done
	        function done(status, nativeStatusText, responses, headers) {
	          var isSuccess,
	            success,
	            error,
	            response,
	            modified,
	            statusText = nativeStatusText;

	          // Ignore repeat invocations
	          if (completed) {
	            return;
	          }
	          completed = true;

	          // Clear timeout if it exists
	          if (timeoutTimer) {
	            window.clearTimeout(timeoutTimer);
	          }

	          // Dereference transport for early garbage collection
	          // (no matter how long the jqXHR object will be used)
	          transport = undefined;

	          // Cache response headers
	          responseHeadersString = headers || "";

	          // Set readyState
	          jqXHR.readyState = status > 0 ? 4 : 0;

	          // Determine if successful
	          isSuccess = status >= 200 && status < 300 || status === 304;

	          // Get response data
	          if (responses) {
	            response = ajaxHandleResponses(s, jqXHR, responses);
	          }

	          // Convert no matter what (that way responseXXX fields are always set)
	          response = ajaxConvert(s, response, jqXHR, isSuccess);

	          // If successful, handle type chaining
	          if (isSuccess) {
	            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	            if (s.ifModified) {
	              modified = jqXHR.getResponseHeader("Last-Modified");
	              if (modified) {
	                jQuery.lastModified[cacheURL] = modified;
	              }
	              modified = jqXHR.getResponseHeader("etag");
	              if (modified) {
	                jQuery.etag[cacheURL] = modified;
	              }
	            }

	            // if no content
	            if (status === 204 || s.type === "HEAD") {
	              statusText = "nocontent";

	              // if not modified
	            } else if (status === 304) {
	              statusText = "notmodified";

	              // If we have data, let's convert it
	            } else {
	              statusText = response.state;
	              success = response.data;
	              error = response.error;
	              isSuccess = !error;
	            }
	          } else {
	            // Extract error from statusText and normalize for non-aborts
	            error = statusText;
	            if (status || !statusText) {
	              statusText = "error";
	              if (status < 0) {
	                status = 0;
	              }
	            }
	          }

	          // Set data for the fake xhr object
	          jqXHR.status = status;
	          jqXHR.statusText = (nativeStatusText || statusText) + "";

	          // Success/Error
	          if (isSuccess) {
	            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
	          } else {
	            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
	          }

	          // Status-dependent callbacks
	          jqXHR.statusCode(statusCode);
	          statusCode = undefined;
	          if (fireGlobals) {
	            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
	          }

	          // Complete
	          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
	          if (fireGlobals) {
	            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

	            // Handle the global AJAX counter
	            if (! --jQuery.active) {
	              jQuery.event.trigger("ajaxStop");
	            }
	          }
	        }
	        return jqXHR;
	      },
	      getJSON: function (url, data, callback) {
	        return jQuery.get(url, data, callback, "json");
	      },
	      getScript: function (url, callback) {
	        return jQuery.get(url, undefined, callback, "script");
	      }
	    });
	    jQuery.each(["get", "post"], function (i, method) {
	      jQuery[method] = function (url, data, callback, type) {
	        // Shift arguments if data argument was omitted
	        if (jQuery.isFunction(data)) {
	          type = type || callback;
	          callback = data;
	          data = undefined;
	        }

	        // The url can be an options object (which then must have .url)
	        return jQuery.ajax(jQuery.extend({
	          url: url,
	          type: method,
	          dataType: type,
	          data: data,
	          success: callback
	        }, jQuery.isPlainObject(url) && url));
	      };
	    });
	    jQuery._evalUrl = function (url) {
	      return jQuery.ajax({
	        url: url,
	        // Make this explicit, since user can override this through ajaxSetup (#11264)
	        type: "GET",
	        dataType: "script",
	        cache: true,
	        async: false,
	        global: false,
	        "throws": true
	      });
	    };
	    jQuery.fn.extend({
	      wrapAll: function (html) {
	        var wrap;
	        if (this[0]) {
	          if (jQuery.isFunction(html)) {
	            html = html.call(this[0]);
	          }

	          // The elements to wrap the target around
	          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
	          if (this[0].parentNode) {
	            wrap.insertBefore(this[0]);
	          }
	          wrap.map(function () {
	            var elem = this;
	            while (elem.firstElementChild) {
	              elem = elem.firstElementChild;
	            }
	            return elem;
	          }).append(this);
	        }
	        return this;
	      },
	      wrapInner: function (html) {
	        if (jQuery.isFunction(html)) {
	          return this.each(function (i) {
	            jQuery(this).wrapInner(html.call(this, i));
	          });
	        }
	        return this.each(function () {
	          var self = jQuery(this),
	            contents = self.contents();
	          if (contents.length) {
	            contents.wrapAll(html);
	          } else {
	            self.append(html);
	          }
	        });
	      },
	      wrap: function (html) {
	        var isFunction = jQuery.isFunction(html);
	        return this.each(function (i) {
	          jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
	        });
	      },
	      unwrap: function (selector) {
	        this.parent(selector).not("body").each(function () {
	          jQuery(this).replaceWith(this.childNodes);
	        });
	        return this;
	      }
	    });
	    jQuery.expr.pseudos.hidden = function (elem) {
	      return !jQuery.expr.pseudos.visible(elem);
	    };
	    jQuery.expr.pseudos.visible = function (elem) {
	      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
	    };
	    jQuery.ajaxSettings.xhr = function () {
	      try {
	        return new window.XMLHttpRequest();
	      } catch (e) {}
	    };
	    var xhrSuccessStatus = {
	        // File protocol always yields status code 0, assume 200
	        0: 200,
	        // Support: IE <=9 only
	        // #1450: sometimes IE returns 1223 when it should be 204
	        1223: 204
	      },
	      xhrSupported = jQuery.ajaxSettings.xhr();
	    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	    support.ajax = xhrSupported = !!xhrSupported;
	    jQuery.ajaxTransport(function (options) {
	      var callback, errorCallback;

	      // Cross domain only allowed if supported through XMLHttpRequest
	      if (support.cors || xhrSupported && !options.crossDomain) {
	        return {
	          send: function (headers, complete) {
	            var i,
	              xhr = options.xhr();
	            xhr.open(options.type, options.url, options.async, options.username, options.password);

	            // Apply custom fields if provided
	            if (options.xhrFields) {
	              for (i in options.xhrFields) {
	                xhr[i] = options.xhrFields[i];
	              }
	            }

	            // Override mime type if needed
	            if (options.mimeType && xhr.overrideMimeType) {
	              xhr.overrideMimeType(options.mimeType);
	            }

	            // X-Requested-With header
	            // For cross-domain requests, seeing as conditions for a preflight are
	            // akin to a jigsaw puzzle, we simply never set it to be sure.
	            // (it can always be set on a per-request basis or even using ajaxSetup)
	            // For same-domain requests, won't change header if already provided.
	            if (!options.crossDomain && !headers["X-Requested-With"]) {
	              headers["X-Requested-With"] = "XMLHttpRequest";
	            }

	            // Set headers
	            for (i in headers) {
	              xhr.setRequestHeader(i, headers[i]);
	            }

	            // Callback
	            callback = function (type) {
	              return function () {
	                if (callback) {
	                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	                  if (type === "abort") {
	                    xhr.abort();
	                  } else if (type === "error") {
	                    // Support: IE <=9 only
	                    // On a manual native abort, IE9 throws
	                    // errors on any property access that is not readyState
	                    if (typeof xhr.status !== "number") {
	                      complete(0, "error");
	                    } else {
	                      complete(
	                      // File: protocol always yields status 0; see #8605, #14207
	                      xhr.status, xhr.statusText);
	                    }
	                  } else {
	                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
	                    // Support: IE <=9 only
	                    // IE9 has no XHR2 but throws on binary (trac-11426)
	                    // For XHR2 non-text, let the caller handle it (gh-2498)
	                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
	                      binary: xhr.response
	                    } : {
	                      text: xhr.responseText
	                    }, xhr.getAllResponseHeaders());
	                  }
	                }
	              };
	            };

	            // Listen to events
	            xhr.onload = callback();
	            errorCallback = xhr.onerror = callback("error");

	            // Support: IE 9 only
	            // Use onreadystatechange to replace onabort
	            // to handle uncaught aborts
	            if (xhr.onabort !== undefined) {
	              xhr.onabort = errorCallback;
	            } else {
	              xhr.onreadystatechange = function () {
	                // Check readyState before timeout as it changes
	                if (xhr.readyState === 4) {
	                  // Allow onerror to be called first,
	                  // but that will not handle a native abort
	                  // Also, save errorCallback to a variable
	                  // as xhr.onerror cannot be accessed
	                  window.setTimeout(function () {
	                    if (callback) {
	                      errorCallback();
	                    }
	                  });
	                }
	              };
	            }

	            // Create the abort callback
	            callback = callback("abort");
	            try {
	              // Do send the request (this may raise an exception)
	              xhr.send(options.hasContent && options.data || null);
	            } catch (e) {
	              // #14683: Only rethrow if this hasn't been notified as an error yet
	              if (callback) {
	                throw e;
	              }
	            }
	          },
	          abort: function () {
	            if (callback) {
	              callback();
	            }
	          }
	        };
	      }
	    });

	    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	    jQuery.ajaxPrefilter(function (s) {
	      if (s.crossDomain) {
	        s.contents.script = false;
	      }
	    });

	    // Install script dataType
	    jQuery.ajaxSetup({
	      accepts: {
	        script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
	      },
	      contents: {
	        script: /\b(?:java|ecma)script\b/
	      },
	      converters: {
	        "text script": function (text) {
	          jQuery.globalEval(text);
	          return text;
	        }
	      }
	    });

	    // Handle cache's special case and crossDomain
	    jQuery.ajaxPrefilter("script", function (s) {
	      if (s.cache === undefined) {
	        s.cache = false;
	      }
	      if (s.crossDomain) {
	        s.type = "GET";
	      }
	    });

	    // Bind script tag hack transport
	    jQuery.ajaxTransport("script", function (s) {
	      // This transport only deals with cross domain requests
	      if (s.crossDomain) {
	        var script, callback;
	        return {
	          send: function (_, complete) {
	            script = jQuery("<script>").prop({
	              charset: s.scriptCharset,
	              src: s.url
	            }).on("load error", callback = function (evt) {
	              script.remove();
	              callback = null;
	              if (evt) {
	                complete(evt.type === "error" ? 404 : 200, evt.type);
	              }
	            });

	            // Use native DOM manipulation to avoid our domManip AJAX trickery
	            document.head.appendChild(script[0]);
	          },
	          abort: function () {
	            if (callback) {
	              callback();
	            }
	          }
	        };
	      }
	    });
	    var oldCallbacks = [],
	      rjsonp = /(=)\?(?=&|$)|\?\?/;

	    // Default jsonp settings
	    jQuery.ajaxSetup({
	      jsonp: "callback",
	      jsonpCallback: function () {
	        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
	        this[callback] = true;
	        return callback;
	      }
	    });

	    // Detect, normalize options and install callbacks for jsonp requests
	    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
	      var callbackName,
	        overwritten,
	        responseContainer,
	        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

	      // Handle iff the expected data type is "jsonp" or we have a parameter to set
	      if (jsonProp || s.dataTypes[0] === "jsonp") {
	        // Get callback name, remembering preexisting value associated with it
	        callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

	        // Insert callback into url or form data
	        if (jsonProp) {
	          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
	        } else if (s.jsonp !== false) {
	          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
	        }

	        // Use data converter to retrieve json after script execution
	        s.converters["script json"] = function () {
	          if (!responseContainer) {
	            jQuery.error(callbackName + " was not called");
	          }
	          return responseContainer[0];
	        };

	        // Force json dataType
	        s.dataTypes[0] = "json";

	        // Install callback
	        overwritten = window[callbackName];
	        window[callbackName] = function () {
	          responseContainer = arguments;
	        };

	        // Clean-up function (fires after converters)
	        jqXHR.always(function () {
	          // If previous value didn't exist - remove it
	          if (overwritten === undefined) {
	            jQuery(window).removeProp(callbackName);

	            // Otherwise restore preexisting value
	          } else {
	            window[callbackName] = overwritten;
	          }

	          // Save back as free
	          if (s[callbackName]) {
	            // Make sure that re-using the options doesn't screw things around
	            s.jsonpCallback = originalSettings.jsonpCallback;

	            // Save the callback name for future use
	            oldCallbacks.push(callbackName);
	          }

	          // Call if it was a function and we have a response
	          if (responseContainer && jQuery.isFunction(overwritten)) {
	            overwritten(responseContainer[0]);
	          }
	          responseContainer = overwritten = undefined;
	        });

	        // Delegate to script
	        return "script";
	      }
	    });

	    // Support: Safari 8 only
	    // In Safari 8 documents created via document.implementation.createHTMLDocument
	    // collapse sibling forms: the second one becomes a child of the first one.
	    // Because of that, this security measure has to be disabled in Safari 8.
	    // https://bugs.webkit.org/show_bug.cgi?id=137337
	    support.createHTMLDocument = function () {
	      var body = document.implementation.createHTMLDocument("").body;
	      body.innerHTML = "<form></form><form></form>";
	      return body.childNodes.length === 2;
	    }();

	    // Argument "data" should be string of html
	    // context (optional): If specified, the fragment will be created in this context,
	    // defaults to document
	    // keepScripts (optional): If true, will include scripts passed in the html string
	    jQuery.parseHTML = function (data, context, keepScripts) {
	      if (typeof data !== "string") {
	        return [];
	      }
	      if (typeof context === "boolean") {
	        keepScripts = context;
	        context = false;
	      }
	      var base, parsed, scripts;
	      if (!context) {
	        // Stop scripts or inline event handlers from being executed immediately
	        // by using document.implementation
	        if (support.createHTMLDocument) {
	          context = document.implementation.createHTMLDocument("");

	          // Set the base href for the created document
	          // so any parsed elements with URLs
	          // are based on the document's URL (gh-2965)
	          base = context.createElement("base");
	          base.href = document.location.href;
	          context.head.appendChild(base);
	        } else {
	          context = document;
	        }
	      }
	      parsed = rsingleTag.exec(data);
	      scripts = !keepScripts && [];

	      // Single tag
	      if (parsed) {
	        return [context.createElement(parsed[1])];
	      }
	      parsed = buildFragment([data], context, scripts);
	      if (scripts && scripts.length) {
	        jQuery(scripts).remove();
	      }
	      return jQuery.merge([], parsed.childNodes);
	    };

	    /**
	     * Load a url into a page
	     */
	    jQuery.fn.load = function (url, params, callback) {
	      var selector,
	        type,
	        response,
	        self = this,
	        off = url.indexOf(" ");
	      if (off > -1) {
	        selector = stripAndCollapse(url.slice(off));
	        url = url.slice(0, off);
	      }

	      // If it's a function
	      if (jQuery.isFunction(params)) {
	        // We assume that it's the callback
	        callback = params;
	        params = undefined;

	        // Otherwise, build a param string
	      } else if (params && typeof params === "object") {
	        type = "POST";
	      }

	      // If we have elements to modify, make the request
	      if (self.length > 0) {
	        jQuery.ajax({
	          url: url,
	          // If "type" variable is undefined, then "GET" method will be used.
	          // Make value of this field explicit since
	          // user can override it through ajaxSetup method
	          type: type || "GET",
	          dataType: "html",
	          data: params
	        }).done(function (responseText) {
	          // Save response for use in complete callback
	          response = arguments;
	          self.html(selector ?
	          // If a selector was specified, locate the right elements in a dummy div
	          // Exclude scripts to avoid IE 'Permission Denied' errors
	          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
	          // Otherwise use the full result
	          responseText);

	          // If the request succeeds, this function gets "data", "status", "jqXHR"
	          // but they are ignored because response was set above.
	          // If it fails, this function gets "jqXHR", "status", "error"
	        }).always(callback && function (jqXHR, status) {
	          self.each(function () {
	            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
	          });
	        });
	      }
	      return this;
	    };

	    // Attach a bunch of functions for handling common AJAX events
	    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
	      jQuery.fn[type] = function (fn) {
	        return this.on(type, fn);
	      };
	    });
	    jQuery.expr.pseudos.animated = function (elem) {
	      return jQuery.grep(jQuery.timers, function (fn) {
	        return elem === fn.elem;
	      }).length;
	    };
	    jQuery.offset = {
	      setOffset: function (elem, options, i) {
	        var curPosition,
	          curLeft,
	          curCSSTop,
	          curTop,
	          curOffset,
	          curCSSLeft,
	          calculatePosition,
	          position = jQuery.css(elem, "position"),
	          curElem = jQuery(elem),
	          props = {};

	        // Set position first, in-case top/left are set even on static elem
	        if (position === "static") {
	          elem.style.position = "relative";
	        }
	        curOffset = curElem.offset();
	        curCSSTop = jQuery.css(elem, "top");
	        curCSSLeft = jQuery.css(elem, "left");
	        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

	        // Need to be able to calculate position if either
	        // top or left is auto and position is either absolute or fixed
	        if (calculatePosition) {
	          curPosition = curElem.position();
	          curTop = curPosition.top;
	          curLeft = curPosition.left;
	        } else {
	          curTop = parseFloat(curCSSTop) || 0;
	          curLeft = parseFloat(curCSSLeft) || 0;
	        }
	        if (jQuery.isFunction(options)) {
	          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
	          options = options.call(elem, i, jQuery.extend({}, curOffset));
	        }
	        if (options.top != null) {
	          props.top = options.top - curOffset.top + curTop;
	        }
	        if (options.left != null) {
	          props.left = options.left - curOffset.left + curLeft;
	        }
	        if ("using" in options) {
	          options.using.call(elem, props);
	        } else {
	          curElem.css(props);
	        }
	      }
	    };
	    jQuery.fn.extend({
	      offset: function (options) {
	        // Preserve chaining for setter
	        if (arguments.length) {
	          return options === undefined ? this : this.each(function (i) {
	            jQuery.offset.setOffset(this, options, i);
	          });
	        }
	        var doc,
	          docElem,
	          rect,
	          win,
	          elem = this[0];
	        if (!elem) {
	          return;
	        }

	        // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
	        // Support: IE <=11 only
	        // Running getBoundingClientRect on a
	        // disconnected node in IE throws an error
	        if (!elem.getClientRects().length) {
	          return {
	            top: 0,
	            left: 0
	          };
	        }
	        rect = elem.getBoundingClientRect();
	        doc = elem.ownerDocument;
	        docElem = doc.documentElement;
	        win = doc.defaultView;
	        return {
	          top: rect.top + win.pageYOffset - docElem.clientTop,
	          left: rect.left + win.pageXOffset - docElem.clientLeft
	        };
	      },
	      position: function () {
	        if (!this[0]) {
	          return;
	        }
	        var offsetParent,
	          offset,
	          elem = this[0],
	          parentOffset = {
	            top: 0,
	            left: 0
	          };

	        // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
	        // because it is its only offset parent
	        if (jQuery.css(elem, "position") === "fixed") {
	          // Assume getBoundingClientRect is there when computed position is fixed
	          offset = elem.getBoundingClientRect();
	        } else {
	          // Get *real* offsetParent
	          offsetParent = this.offsetParent();

	          // Get correct offsets
	          offset = this.offset();
	          if (!nodeName(offsetParent[0], "html")) {
	            parentOffset = offsetParent.offset();
	          }

	          // Add offsetParent borders
	          parentOffset = {
	            top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
	            left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
	          };
	        }

	        // Subtract parent offsets and element margins
	        return {
	          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
	          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
	        };
	      },
	      // This method will return documentElement in the following cases:
	      // 1) For the element inside the iframe without offsetParent, this method will return
	      //    documentElement of the parent window
	      // 2) For the hidden or detached element
	      // 3) For body or html element, i.e. in case of the html node - it will return itself
	      //
	      // but those exceptions were never presented as a real life use-cases
	      // and might be considered as more preferable results.
	      //
	      // This logic, however, is not guaranteed and can change at any point in the future
	      offsetParent: function () {
	        return this.map(function () {
	          var offsetParent = this.offsetParent;
	          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
	            offsetParent = offsetParent.offsetParent;
	          }
	          return offsetParent || documentElement;
	        });
	      }
	    });

	    // Create scrollLeft and scrollTop methods
	    jQuery.each({
	      scrollLeft: "pageXOffset",
	      scrollTop: "pageYOffset"
	    }, function (method, prop) {
	      var top = "pageYOffset" === prop;
	      jQuery.fn[method] = function (val) {
	        return access(this, function (elem, method, val) {
	          // Coalesce documents and windows
	          var win;
	          if (jQuery.isWindow(elem)) {
	            win = elem;
	          } else if (elem.nodeType === 9) {
	            win = elem.defaultView;
	          }
	          if (val === undefined) {
	            return win ? win[prop] : elem[method];
	          }
	          if (win) {
	            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
	          } else {
	            elem[method] = val;
	          }
	        }, method, val, arguments.length);
	      };
	    });

	    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
	    // Add the top/left cssHooks using jQuery.fn.position
	    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	    // getComputedStyle returns percent when specified for top/left/bottom/right;
	    // rather than make the css module depend on the offset module, just check for it here
	    jQuery.each(["top", "left"], function (i, prop) {
	      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
	        if (computed) {
	          computed = curCSS(elem, prop);

	          // If curCSS returns percentage, fallback to offset
	          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
	        }
	      });
	    });

	    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	    jQuery.each({
	      Height: "height",
	      Width: "width"
	    }, function (name, type) {
	      jQuery.each({
	        padding: "inner" + name,
	        content: type,
	        "": "outer" + name
	      }, function (defaultExtra, funcName) {
	        // Margin is only for outerHeight, outerWidth
	        jQuery.fn[funcName] = function (margin, value) {
	          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
	            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
	          return access(this, function (elem, type, value) {
	            var doc;
	            if (jQuery.isWindow(elem)) {
	              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
	              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
	            }

	            // Get document width or height
	            if (elem.nodeType === 9) {
	              doc = elem.documentElement;

	              // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
	              // whichever is greatest
	              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
	            }
	            return value === undefined ?
	            // Get width or height on the element, requesting but not forcing parseFloat
	            jQuery.css(elem, type, extra) :
	            // Set width or height on the element
	            jQuery.style(elem, type, value, extra);
	          }, type, chainable ? margin : undefined, chainable);
	        };
	      });
	    });
	    jQuery.fn.extend({
	      bind: function (types, data, fn) {
	        return this.on(types, null, data, fn);
	      },
	      unbind: function (types, fn) {
	        return this.off(types, null, fn);
	      },
	      delegate: function (selector, types, data, fn) {
	        return this.on(types, selector, data, fn);
	      },
	      undelegate: function (selector, types, fn) {
	        // ( namespace ) or ( selector, types [, fn] )
	        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
	      }
	    });
	    jQuery.holdReady = function (hold) {
	      if (hold) {
	        jQuery.readyWait++;
	      } else {
	        jQuery.ready(true);
	      }
	    };
	    jQuery.isArray = Array.isArray;
	    jQuery.parseJSON = JSON.parse;
	    jQuery.nodeName = nodeName;
	    var
	      // Map over jQuery in case of overwrite
	      _jQuery = window.jQuery,
	      // Map over the $ in case of overwrite
	      _$ = window.$;
	    jQuery.noConflict = function (deep) {
	      if (window.$ === jQuery) {
	        window.$ = _$;
	      }
	      if (deep && window.jQuery === jQuery) {
	        window.jQuery = _jQuery;
	      }
	      return jQuery;
	    };

	    // Expose jQuery and $ identifiers, even in AMD
	    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	    // and CommonJS for browser emulators (#13566)
	    if (!noGlobal) {
	      window.jQuery = window.$ = jQuery;
	    }
	    return jQuery;
	  });
	})(jquery);
	var jqueryExports = jquery.exports;
	var $$2 = /*@__PURE__*/getDefaultExportFromCjs(jqueryExports);

	/**
	 * Animation Helper Functions / constants
	 * -----------------------------------------------------------------------------
	 * A collection of functions that help with animations in javascript
	 *
	 */

	// Match those set in variables.scss
	const transitionTimingDurations = {
	  base: 300,
	  fast: 150,
	  fastest: 50,
	  slow: 600,
	  medium: 400,
	  none: 0
	};
	const transitionTimingFunctions = {
	  base: 'ease-in-out',
	  in: 'ease-out',
	  out: 'ease-in',
	  inOutUI: 'cubic-bezier(0.42, 0, 0.13, 1.04)'
	};

	/**
	* Get one of the durations stored in the variable defined above
	* If the requested duration doesn't exist, fallback to the base
	*
	* @param {string} key - string matching one of the key names
	* @return {int} - duration in ms
	*/
	function getTransitionTimingDuration(key) {
	  let k = 'base';
	  if (transitionTimingDurations.hasOwnProperty(key)) {
	    k = key;
	  }
	  return transitionTimingDurations[k];
	}

	/**
	* Get one of the timing functions stored in the variable defined above
	* If the requested function doesn't exist, fallback to the base
	*
	* @param {string} key - string matching one of the key names
	* @return {string} - valid css timing function
	*/
	function getTransitionTimingFunction(key) {
	  let k = 'base';
	  if (transitionTimingFunctions.hasOwnProperty(key)) {
	    k = key;
	  }
	  return transitionTimingFunctions[k];
	}
	/* eslint-enable */

	/* eslint-disable no-undefined,no-param-reassign,no-shadow */

	/**
	 * Throttle execution of a function. Especially useful for rate limiting
	 * execution of handlers on events like resize and scroll.
	 *
	 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
	 *                                            are most useful.
	 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
	 *                                            as-is, to `callback` when the throttled-function is executed.
	 * @param {object} [options] -              An object to configure options.
	 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
	 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
	 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
	 *                                            `delay` milliseconds, the internal counter is reset).
	 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
	 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
	 *                                            callback will never executed if both noLeading = true and noTrailing = true.
	 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
	 *                                            false (at end), schedule `callback` to execute after `delay` ms.
	 *
	 * @returns {Function} A new, throttled, function.
	 */
	function throttle(delay, callback, options) {
	  var _ref = options || {},
	    _ref$noTrailing = _ref.noTrailing,
	    noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
	    _ref$noLeading = _ref.noLeading,
	    noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
	    _ref$debounceMode = _ref.debounceMode,
	    debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
	  /*
	   * After wrapper has stopped being called, this timeout ensures that
	   * `callback` is executed at the proper times in `throttle` and `end`
	   * debounce modes.
	   */

	  var timeoutID;
	  var cancelled = false; // Keep track of the last time `callback` was executed.

	  var lastExec = 0; // Function to clear existing timeout

	  function clearExistingTimeout() {
	    if (timeoutID) {
	      clearTimeout(timeoutID);
	    }
	  } // Function to cancel next exec

	  function cancel(options) {
	    var _ref2 = options || {},
	      _ref2$upcomingOnly = _ref2.upcomingOnly,
	      upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
	    clearExistingTimeout();
	    cancelled = !upcomingOnly;
	  }
	  /*
	   * The `wrapper` function encapsulates all of the throttling / debouncing
	   * functionality and when executed will limit the rate at which `callback`
	   * is executed.
	   */

	  function wrapper() {
	    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
	      arguments_[_key] = arguments[_key];
	    }
	    var self = this;
	    var elapsed = Date.now() - lastExec;
	    if (cancelled) {
	      return;
	    } // Execute `callback` and update the `lastExec` timestamp.

	    function exec() {
	      lastExec = Date.now();
	      callback.apply(self, arguments_);
	    }
	    /*
	     * If `debounceMode` is true (at begin) this is used to clear the flag
	     * to allow future `callback` executions.
	     */

	    function clear() {
	      timeoutID = undefined;
	    }
	    if (!noLeading && debounceMode && !timeoutID) {
	      /*
	       * Since `wrapper` is being called for the first time and
	       * `debounceMode` is true (at begin), execute `callback`
	       * and noLeading != true.
	       */
	      exec();
	    }
	    clearExistingTimeout();
	    if (debounceMode === undefined && elapsed > delay) {
	      if (noLeading) {
	        /*
	         * In throttle mode with noLeading, if `delay` time has
	         * been exceeded, update `lastExec` and schedule `callback`
	         * to execute after `delay` ms.
	         */
	        lastExec = Date.now();
	        if (!noTrailing) {
	          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
	        }
	      } else {
	        /*
	         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
	         * `callback`.
	         */
	        exec();
	      }
	    } else if (noTrailing !== true) {
	      /*
	       * In trailing throttle mode, since `delay` time has not been
	       * exceeded, schedule `callback` to execute `delay` ms after most
	       * recent execution.
	       *
	       * If `debounceMode` is true (at begin), schedule `clear` to execute
	       * after `delay` ms.
	       *
	       * If `debounceMode` is false (at end), schedule `callback` to
	       * execute after `delay` ms.
	       */
	      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
	    }
	  }
	  wrapper.cancel = cancel; // Return the wrapper function.

	  return wrapper;
	}

	/**
	 * Breakpoint Helper Functions / constants
	 * -----------------------------------------------------------------------------
	 * A collection of functions that help with dealing with site breakpoints in JS
	 * All breakpoint properties should be defined here
	 *
	 */

	const $window$2 = $$2(window);
	$window$2.width();

	// Match those set in variables.scss
	const breakpointMinWidths = {
	  xs: 576,
	  sm: 768,
	  md: 992,
	  lg: 1200,
	  xl: 1480
	};

	/**
	 * Get one of the widths stored in the variable defined above
	 *
	 * @param {string} key - string matching one of the key names
	 * @return {int} - pixel width
	 */
	function getBreakpointMinWidth(key) {
	  let w;
	  if (breakpointMinWidths.hasOwnProperty(key)) {
	    w = breakpointMinWidths[key];
	  }
	  return w;
	}

	/**
	 * Currency Helpers
	 * -----------------------------------------------------------------------------
	 * A collection of useful functions that help with currency formatting
	 *
	 * Current contents
	 * - formatMoney - Takes an amount in cents and returns it as a formatted dollar value.
	 *
	 */

	const moneyFormat = '${{amount}}'; // eslint-disable-line no-template-curly-in-string

	/**
	 * Format money values based on your shop currency settings
	 * @param  {Number|string} cents - value in cents or dollar amount e.g. 300 cents
	 * or 3.00 dollars
	 * @param  {String} format - shop money_format setting
	 * @return {String} value - formatted value
	 */
	function formatMoney(cents, format) {
	  if (typeof cents === 'string') {
	    cents = cents.replace('.', '');
	  }
	  let value = '';
	  const placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
	  const formatString = format || moneyFormat;
	  function formatWithDelimiters(number) {
	    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
	    let thousands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
	    let decimal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
	    if (Number.isNaN(number) || number == null) {
	      return 0;
	    }
	    number = (number / 100.0).toFixed(precision);
	    const parts = number.split('.');
	    const dollarsAmount = parts[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, `$1${thousands}`);
	    const centsAmount = parts[1] ? decimal + parts[1] : '';
	    return dollarsAmount + centsAmount;
	  }
	  switch (formatString.match(placeholderRegex)[1]) {
	    case 'amount':
	      value = formatWithDelimiters(cents, 2);
	      break;
	    case 'amount_no_decimals':
	      value = formatWithDelimiters(cents, 0);
	      break;
	    case 'amount_with_space_separator':
	      value = formatWithDelimiters(cents, 2, ' ', '.');
	      break;
	    case 'amount_no_decimals_with_comma_separator':
	      value = formatWithDelimiters(cents, 0, ',', '.');
	      break;
	    case 'amount_no_decimals_with_space_separator':
	      value = formatWithDelimiters(cents, 0, ' ');
	      break;
	  }
	  return formatString.replace(placeholderRegex, value);
	}

	/**
	 * Removes '.00' if found at the end of the string
	 *
	 * @param  {string} value - formatted price (see above)
	 * @return {string} value - formatted value
	 */
	function stripZeroCents(string) {
	  return string.replace(/\.00$/, '');
	}

	/**
	 * Image Helper Functions
	 * -----------------------------------------------------------------------------
	 * A collection of functions that help with basic image operations.
	 *
	 */

	/**
	 * Adds a Shopify size attribute to a URL
	 *
	 * @param src
	 * @param size
	 * @returns {*}
	 */
	function getSizedImageUrl(src, size) {
	  if (size === null) {
	    return src;
	  }
	  if (size === 'master') {
	    return this.removeProtocol(src);
	  }
	  const match = src.match(/\.(jpg|jpeg|gif|png|bmp|bitmap|tiff|tif)(\?v=\d+)?$/i);
	  let url = null;
	  if (match) {
	    const prefix = src.split(match[0]);
	    const suffix = match[0];
	    url = this.removeProtocol(prefix[0] + '_' + size + suffix);
	  }
	  return url;
	}

	class CartAPI {
	  constructor() {
	    this.name = 'cartAPI';
	    this.cart = {}; // Keep a reference to the cart at all times - this can either be the default shopify JSON representation for our custom one

	    this.getCart(); // Fetches the latest cart and updates this.cart;
	  }

	  /**
	   * Formats the cart object to be consumed by the handlebars template
	   *
	   * @param {object} cart - JSON representation of the cart.  See https://help.shopify.com/themes/development/getting-started/using-ajax-api#get-cart
	   * @return {object}
	   */
	  formatCart(cart) {
	    if (cart && cart.is_formatted) {
	      return cart;
	    }

	    // Make adjustments to the cart object contents before we pass it off to the handlebars template
	    cart.total_price = formatMoney(cart.total_price, theme.moneyFormat);
	    cart.total_price = stripZeroCents(cart.total_price);
	    cart.items.map(item => {
	      if (item.image !== null) {
	        item.image = getSizedImageUrl(item.image, '200x');
	      }
	      item.price = formatMoney(item.price, theme.moneyFormat);
	      item.price = stripZeroCents(item.price);

	      // Adjust the item's variant options to add "name" and "value" properties
	      if (item.hasOwnProperty('product')) {
	        const product = item.product;
	        for (let i = item.variant_options.length - 1; i >= 0; i--) {
	          const name = product.options[i];
	          const value = item.variant_options[i];
	          item.variant_options[i] = {
	            name,
	            value
	          };

	          // Don't show this info if it's the default variant that Shopify creates
	          if (value === 'Default Title') {
	            delete item.variant_options[i];
	          }
	        }
	      } else {
	        delete item.variant_options; // skip it and use the variant title instead
	      }
	      return item;
	    });
	    cart.is_formatted = true;
	    return cart;
	  }

	  /**
	   * Gets the index of the cart line item based on the line item key
	   * This is helpful because the line item changes any time products are added or removed from the cart whereas the key does not
	   * The issue is that the actual Shopify AJAX API relies on index to make cart modifications.
	   * Use this method to retrieve the line index immediately before making cart changes.
	   *
	   * @param {String} key - line_item.key
	   * @return {Integer} line
	   */
	  getCartLineByItemKey(key) {
	    if (Object.keys(this.cart).length === 0) {
	      console.warn(`[${this.name}] - this.cart data required to pull line item by key`);
	    }
	    let line;
	    for (let i = this.cart.items.length - 1; i >= 0; i--) {
	      if (key === this.cart.items[i].key) {
	        line = i + 1;
	        break;
	      }
	    }
	    return line;
	  }

	  /**
	   * Retrieve a JSON respresentation of the users cart
	   *
	   * @return {Promise} - JSON cart
	   */
	  getCart() {
	    const promise = $$2.Deferred();
	    $$2.ajax({
	      type: 'get',
	      url: '/cart?view=json',
	      success: data => {
	        // Theme editor adds HTML comments to JSON response, strip these
	        data = data.replace(/<\/?[^>]+>/gi, '');
	        const cart = JSON.parse(data);
	        this.cart = this.formatCart(cart);
	        promise.resolve(this.cart);
	      },
	      error: () => {
	        promise.reject({
	          message: 'Could not retrieve cart items'
	        });
	      }
	    });
	    return promise;
	  }

	  /**
	   * AJAX submit an 'add to cart' form
	   *
	   * @param {jQuery} $form - jQuery instance of the form
	   * @return {Promise} - Resolve returns JSON cart | Reject returns an error message
	   */
	  addItemFromForm($form) {
	    const promise = $$2.Deferred();
	    $$2.ajax({
	      type: 'post',
	      dataType: 'json',
	      url: '/cart/add.js',
	      data: $form.serialize(),
	      success: () => {
	        this.getCart().then(cart => {
	          promise.resolve(cart);
	        });
	      },
	      error: () => {
	        promise.reject({
	          message: 'The quantity you entered is not available.'
	        });
	      }
	    });
	    return promise;
	  }

	  /**
	   * Retrieve a JSON respresentation of a specific product
	   *
	   * @return {Promise} - JSON product
	   */
	  getProduct(handle) {
	    return $$2.getJSON(`/products/${handle}.js`);
	  }

	  /**
	   * Change the quantity of an item in the users cart
	   * Item is specified by line_item index (Shopify index which starts at 1 not 0)
	   *
	   * @param {Integer} line - Cart line
	   * @param {Integer} qty - New quantity of the variant
	   * @return {Promise} - JSON cart
	   */
	  changeLineItemQuantity(line, qty) {
	    const promise = $$2.Deferred();
	    $$2.ajax({
	      type: 'post',
	      dataType: 'json',
	      url: '/cart/change.js',
	      data: `quantity=${qty}&line=${line}`,
	      success: cart => {
	        this.cart = cart;
	        this.getCart().then(data => {
	          promise.resolve(data);
	        });
	      },
	      error: () => {
	        const data = {
	          message: 'Something went wrong.'
	        };
	        promise.reject(data);
	      }
	    });
	    return promise;
	  }

	  /**
	   * Change the quantity of an item in the users cart
	   * Item is specified by line_item.key
	   *
	   * @param {String} key - Line item key
	   * @param {Integer} qty - New quantity for the line item
	   * @return {Promise} - JSON cart
	   */
	  changeLineItemQuantityByKey(key, qty) {
	    return this.changeLineItemQuantity(this.getCartLineByItemKey(key), qty);
	  }
	}
	var CartAPI$1 = new CartAPI();

	Number.isNaN = Number.isNaN || function (value) {
	  // eslint-disable-next-line no-self-compare
	  return value !== null && (value !== value || +value !== value);
	};
	if (Number.parseInt === undefined) {
	  Number.parseInt = window.parseInt;
	}

	$(document).ready(function () {
	  //adds empty alt attribute just in case any images don't have an alt attribute at all
	  $('img').each(function () {
	    if (!$(this).attr('alt')) {
	      $(this).attr('alt', '');
	    }
	  });

	  //menu stuff
	  $('.main-menu .menu-items-container > .menu-item-wrapper:first-child > p > a').on('click', function (e) {
	    e.preventDefault();
	    $(this).toggleClass("active");
	    $(this).parent().next().toggleClass("active");
	  });
	  $('.main-menu .menu-items-container > .menu-item-wrapper:first-child > p > a').on('keypress', function (e) {
	    var keycode = e.keyCode ? e.keyCode : e.which;
	    if (keycode == '13') {
	      $(this).addClass("active");
	      $(this).parent().next().addClass("active");
	    }
	  });
	  $(document).on('keydown', function (e) {
	    var keycode = e.keyCode ? e.keyCode : e.which;
	    if (keycode == '27') {
	      //close mobile menu
	      $('.main-menu .menu-items-container > .menu-item-wrapper:first-child > p > a').removeClass("active");
	      $('.main-menu .menu-items-container > .menu-item-wrapper:first-child > .menu-blocks__block').removeClass("active");
	      //close search modal
	      $('.header .search-overlay').removeClass("is-visible");
	      $('.ajax-cart-container').removeClass("is-open");
	      $('.ajax-cart-backdrop').removeClass("is-visible");
	    }
	  });

	  //Swiper
	  var mySwiper = document.querySelector('.swiper-container').swiper;
	  mySwiper.autoplay.stop();
	  $(".swiper-container").mouseenter(function () {
	    mySwiper.autoplay.stop();
	  });
	  $(".swiper-container").mouseleave(function () {
	    mySwiper.autoplay.start();
	  });
	  $(".swiper-container").focusin(function () {
	    $(this).addClass('focused');
	    mySwiper.autoplay.stop();
	  });
	  $(".swiper-container").focusout(function () {
	    $(this).removeClass('focused');
	    mySwiper.autoplay.start();
	  });
	  $(".swiper-slide-duplicate, .swiper-slide-duplicate-active, .swiper-slide-duplicate-next").each(function () {
	    $(this).attr('aria-hidden', 'true');
	    $(this).attr('tabindex', '-1');
	  });
	  $(".swiper-slide-duplicate a, .swiper-slide-duplicate-active a, .swiper-slide-duplicate-next a").each(function () {
	    $(this).attr('aria-hidden', 'true');
	    $(this).attr('tabindex', '-1');
	  });

	  //$('.dots .dot').on('keypress', function(e) {
	  //var variantname = $(this).data('variant-option-value');
	  //if(e.which == 13 && !$(this).hasClass('is-active') ) {
	  //$('.dots .dot').removeClass('is-active');
	  //$(this).addClass('is-active');
	  //$('.option-name-span').html(variantname);
	  //}
	  //});
	});

	/*! js-cookie v3.0.5 | MIT */
	/* eslint-disable no-var */
	function assign(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      target[key] = source[key];
	    }
	  }
	  return target;
	}
	/* eslint-enable no-var */

	/* eslint-disable no-var */
	var defaultConverter = {
	  read: function (value) {
	    if (value[0] === '"') {
	      value = value.slice(1, -1);
	    }
	    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
	  },
	  write: function (value) {
	    return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
	  }
	};
	/* eslint-enable no-var */

	/* eslint-disable no-var */

	function init(converter, defaultAttributes) {
	  function set(name, value, attributes) {
	    if (typeof document === 'undefined') {
	      return;
	    }
	    attributes = assign({}, defaultAttributes, attributes);
	    if (typeof attributes.expires === 'number') {
	      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
	    }
	    if (attributes.expires) {
	      attributes.expires = attributes.expires.toUTCString();
	    }
	    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
	    var stringifiedAttributes = '';
	    for (var attributeName in attributes) {
	      if (!attributes[attributeName]) {
	        continue;
	      }
	      stringifiedAttributes += '; ' + attributeName;
	      if (attributes[attributeName] === true) {
	        continue;
	      }

	      // Considers RFC 6265 section 5.2:
	      // ...
	      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
	      //     character:
	      // Consume the characters of the unparsed-attributes up to,
	      // not including, the first %x3B (";") character.
	      // ...
	      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
	    }
	    return document.cookie = name + '=' + converter.write(value, name) + stringifiedAttributes;
	  }
	  function get(name) {
	    if (typeof document === 'undefined' || arguments.length && !name) {
	      return;
	    }

	    // To prevent the for loop in the first place assign an empty array
	    // in case there are no cookies at all.
	    var cookies = document.cookie ? document.cookie.split('; ') : [];
	    var jar = {};
	    for (var i = 0; i < cookies.length; i++) {
	      var parts = cookies[i].split('=');
	      var value = parts.slice(1).join('=');
	      try {
	        var found = decodeURIComponent(parts[0]);
	        jar[found] = converter.read(value, found);
	        if (name === found) {
	          break;
	        }
	      } catch (e) {}
	    }
	    return name ? jar[name] : jar;
	  }
	  return Object.create({
	    set,
	    get,
	    remove: function (name, attributes) {
	      set(name, '', assign({}, attributes, {
	        expires: -1
	      }));
	    },
	    withAttributes: function (attributes) {
	      return init(this.converter, assign({}, this.attributes, attributes));
	    },
	    withConverter: function (converter) {
	      return init(assign({}, this.converter, converter), this.attributes);
	    }
	  }, {
	    attributes: {
	      value: Object.freeze(defaultAttributes)
	    },
	    converter: {
	      value: Object.freeze(converter)
	    }
	  });
	}
	var api = init(defaultConverter, {
	  path: '/'
	});

	const prefix = '_ztheme_';
	const cookies = {
	  siteVisit: {
	    name: 'site_visit',
	    value: true
	  },
	  newsletterSlideupSeen: {
	    name: 'newsletterSlideup_seen',
	    value: true
	  },
	  newsletterModalSeen: {
	    name: 'newsletterModal_seen',
	    value: true
	  },
	  emailCollected: {
	    name: 'emailCollected',
	    value: true
	  }
	};

	/**
	 * Creates and returns a copy of one of the cookies available above
	 *
	 * @param {String} key
	 * @return {Object | undefined}
	 */
	function generateCookie(key) {
	  let c = {};
	  if (cookies.hasOwnProperty(key)) {
	    c = $$2.extend(true, {}, cookies[key]);
	    c.name = prefix + c.name;
	  } else {
	    console.warn(`[User] - Cannot create cookie.  Key ${key} not found.`);
	  }
	  return c;
	}

	/**
	 * Checks for the presence of a browser cookie by name (doesn't check for value equality)
	 *
	 * @param {String} cookieName
	 * @return {boolean}
	 */
	function hasCookie(cookieName) {
	  return typeof api.get(cookieName) !== 'undefined';
	}

	/**
	 * Returns value of browser cookie by name
	 *
	 * @param {String} cookieName
	 * @return {String | Undefined}
	 */
	function getCookieValue(cookieName) {
	  return hasCookie(cookieName) ? api.get(cookieName) : undefined;
	}

	/**
	 * Removes a cookie by name
	 *
	 * @param {String} cookieName
	 */
	function removeCookie(cookieName) {
	  api.remove(cookieName);
	}

	/**
	 * Sets a browser cookie
	 *
	 * @param {Object} cookie
	 * @param {String} cookie.name
	 * @param {String} cookie.value
	 * @param {Number} cookie.expiration - Time to expire in days, expires after session if left blank
	 */
	function setCookie(cookie) {
	  if (hasCookie(cookie.name) && getCookieValue(cookie.name) !== cookie.value) {
	    removeCookie(cookie.name);
	  }
	  const opts = cookie.hasOwnProperty('expiration') ? {
	    expires: cookie.expiration
	  } : {};
	  api.set(cookie.name, cookie.value, opts);
	}

	/**
	 * Return an object from an array of objects that matches the provided key and value
	 *
	 * @param {array} array - Array of objects
	 * @param {string} key - Key to match the value against
	 * @param {string} value - Value to get match of
	 */
	function find$1(array, key, value) {
	  let found;
	  for (let i = 0; i < array.length; i++) {
	    if (array[i][key] === value) {
	      found = array[i];
	      break;
	    }
	  }
	  return found;
	}

	/**
	 * _.compact from lodash
	 * Remove empty/false items from array
	 * Source: https://github.com/lodash/lodash/blob/master/compact.js
	 *
	 * @param {array} array
	 */
	function compact(array) {
	  let index = -1;
	  let resIndex = 0;
	  const length = array == null ? 0 : array.length;
	  const result = [];
	  while (++index < length) {
	    const value = array[index];
	    if (value) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Constructs a version of the current URL with the passed in key value pair as part of the query string
	 * Will also remove the key if an empty value is passed in
	 * See: https://gist.github.com/niyazpk/f8ac616f181f6042d1e0
	 *
	 * @param {String} key
	 * @param {String} value
	 * @param {String} uri - optional, defaults to window.location.href
	 * @return {String}
	 */
	function getUrlWithUpdatedQueryStringParameter(key, value, _uri) {
	  let uri = _uri || window.location.href;

	  // remove the hash part before operating on the uri
	  const i = uri.indexOf('#');
	  const hash = i === -1 ? '' : uri.substr(i);
	  uri = i === -1 ? uri : uri.substr(0, i); // eslint-disable-line no-param-reassign

	  const re = new RegExp('([?&])' + key + '=.*?(&|$)', 'i'); // eslint-disable-line prefer-template
	  const separator = uri.indexOf('?') !== -1 ? '&' : '?';
	  if (!value) {
	    // remove key-value pair if value is empty
	    uri = uri.replace(new RegExp('([?&]?)' + key + '=[^&]*', 'i'), ''); // eslint-disable-line prefer-template
	    if (uri.slice(-1) === '?') {
	      uri = uri.slice(0, -1);
	    }
	    // replace first occurrence of & by ? if no ? is present
	    if (uri.indexOf('?') === -1) uri = uri.replace(/&/, '?');
	  } else if (uri.match(re)) {
	    uri = uri.replace(re, '$1' + key + '=' + value + '$2'); // eslint-disable-line prefer-template
	  } else {
	    uri = uri + separator + key + '=' + value; // eslint-disable-line prefer-template
	  }
	  return uri + hash;
	}

	/**
	 * Check if we're running the theme inside the theme editor
	 *
	 * @return {bool}
	 */
	function isThemeEditor() {
	  return window.Shopify && window.Shopify.designMode;
	}

	/**
	 * Get the name of the correct 'transitionend' event for the browser we're in
	 *
	 * @return {string}
	 */
	function whichTransitionEnd() {
	  const el = document.createElement('fakeelement');
	  const transitions = {
	    transition: 'transitionend',
	    OTransition: 'oTransitionEnd',
	    MozTransition: 'transitionend',
	    WebkitTransition: 'webkitTransitionEnd'
	  };
	  let name;
	  Object.keys(transitions).forEach(t => {
	    if (el.style[t] !== undefined) {
	      name = transitions[t];
	    }
	  });
	  return name;
	}
	function chosenSelects($container) {
	  const $selects = $container ? $$2('select.form-control', $container) : $$2('select.form-control');
	  // This is the code I commented out  
	  // $selects.not('[data-no-chosen]').chosen();

	  // Allows browser autofill to function properly
	  $selects.on('change', () => {
	    $$2(this).trigger('chosen:updated');
	  });
	}

	/**
	 * Retrieves an object property by the passed in string
	 * i.e. this.getPropByString(window, 'property.subproperty'); => window.property.subproperty
	 *
	 * @param {Object} o
	 * @return {String} s
	 */
	function getPropByString(o, s) {
	  // See: https://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key
	  s = s.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
	  s = s.replace(/^\./, ''); // strip a leading dot
	  const a = s.split('.');
	  for (let i = 0, n = a.length; i < n; ++i) {
	    const k = a[i];
	    if (k in o) {
	      o = o[k];
	    } else {
	      return null;
	    }
	  }
	  return o;
	}

	/**
	 * Yotpo API Wrapper
	 * -----------------------------------------------------------------------------
	 * Library for interacting with the Yotpo API
	 * Wraps all API calls with a promise interface
	 * see: https://apidocs.yotpo.com/reference
	 *
	 * - Requires:
	 *   - window.yotpoConfig - object with valid `apiKey` property
	 */

	const API_ORIGIN = 'https://api.yotpo.com';
	class YotpoAPI {
	  constructor() {
	    this.name = 'yotpoAPI';
	    this.namespace = `.${this.name}`;
	    if (!window.yotpoConfig || !window.yotpoConfig.hasOwnProperty('appKey')) {
	      console.warn(`[${this.name}] - App key required to initialize.  If Yotpo isn\'t required, please remove this file.`);
	      return;
	    }
	    this.appKey = window.yotpoConfig.appKey;
	  }

	  /**
	   * Makes a request to the Yotpo API
	   * Returns the data as shown in the API docs
	   *
	   * @param {string} endpoint - combines with the API_ORIGIN to create a full URL
	   * @returns {promise}
	   * @resolve {object}
	   * @rejects {object}
	   */
	  _makeRequest(endpoint) {
	    const promise = $$2.Deferred();
	    const url = API_ORIGIN + endpoint;
	    $$2.get(url).done(data => {
	      promise.resolve(data);
	    }).fail(data => {
	      promise.reject(data.responseJSON);
	    });
	    return promise;
	  }

	  /**
	   * Retrieves all images generated from product reviews and/or Instagram.
	   * See: https://apidocs.yotpo.com/reference#get-all-images
	   *
	   * @param {string} source - optional - must be "instagram" or "yotpo_reviews", defaults to "instagram";
	   * @param {object} params - plain object of key values mapping to optional query parameters defined in the docs.
	   * @returns {promise} - see this._makeRequest
	   */
	  getAllImages(source, params) {
	    const baseParams = {
	      source: 'instagram'
	    };
	    if (source === 'yotpo_reviews') {
	      baseParams.source = 'yotpo_reviews';
	    }
	    params = params || {};
	    const endpoint = `/v1/widget/${this.appKey}/images/all.json?`;
	    const url = endpoint + $$2.param($$2.extend(baseParams, params));
	    return this._makeRequest(url);
	  }

	  /**
	   * Retrieves images for specific products by product_id
	   * See: https://apidocs.yotpo.com/reference#get-all-images
	   *
	   * @param {integer} id
	   * @param {object} params - plain object of key values mapping to optional query parameters defined in the docs.    
	   * @returns {promise} - see this._makeRequest
	   */
	  getProductImages(id, params) {
	    if (!id) {
	      console.warn(`[${this.name}] - product id required.`);
	      return false;
	    }
	    params = params || {};
	    const endpoint = `/v1/widget/${this.appKey}/albums/product/${id}`;
	    const url = endpoint + $$2.param(params);
	    return this._makeRequest(url);
	  }

	  /**
	   * Retrieve an album by name
	   * See: https://apidocs.yotpo.com/v1.0/reference?showHidden=dfd93#custom-albums
	   *
	   * @param {string} album name
	   * @param {object} params - plain object of key values mapping to optional query parameters defined in the docs.    
	   * @returns {promise} - see this._makeRequest
	   */
	  getCustomAlbum(albumName, params) {
	    if (!albumName) {
	      console.warn(`[${this.name}] - album name required.`);
	      return false;
	    }
	    params = params || {};
	    let endpoint = `/v1/widget/${this.appKey}/albums/by_name?album_name=${encodeURI(albumName)}`;
	    endpoint += `&${$$2.param(params)}`;
	    return this._makeRequest(endpoint);
	  }

	  /**
	   * Retrieve Reviews for a Product
	   * See: https://apidocs.yotpo.com/reference#retrieve-a-review-by-review-id
	   *
	   * @param {integer} id
	   * @param {object} params - plain object of key values mapping to optional query parameters defined in the docs.    
	   * @returns {promise} - see this._makeRequest
	   */
	  getReviewsForProduct(id, params) {
	    if (!id) {
	      console.warn(`[${this.name}] - product id required.`);
	      return false;
	    }
	    params = params || {};
	    const endpoint = `/v1/widget/${this.appKey}/products/${id}/reviews.json?`;
	    const url = endpoint + $$2.param(params);
	    return this._makeRequest(url);
	  }

	  /**
	   * Retrieve Bottom Line (Total Reviews and Average Score) for a Specific Product
	   * See: https://apidocs.yotpo.com/reference#get-bottom-line-total-reviews-and-average-score-fo-1
	   *
	   * @param {integer} id
	   * @returns {promise} - see this._makeRequest
	   */
	  getBottomLineForProduct(id) {
	    if (!id) {
	      console.warn(`[${this.name}] - product id required.`);
	      return false;
	    }
	    const endpoint = `/products/${this.appKey}/${id}/bottomline`;
	    return this._makeRequest(endpoint);
	  }

	  /**
	   * Retrieve Bottom Line (Total Reviews and Average Score) for All Site Reviews
	   * See: https://apidocs.yotpo.com/reference#retrieve-bottom-line-for-all-site-reviews
	   *
	   * @returns {promise} - see this._makeRequest
	   */
	  getBottomLineForAllReviews() {
	    const endpoint = `/products/${this.appKey}/yotpo_site_reviews/bottomline`;
	    return this._makeRequest(endpoint);
	  }
	}
	new YotpoAPI();

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var handlebars$1 = {exports: {}};

	var handlebars_runtime = {exports: {}};

	var base$1 = {};

	var utils = {};

	utils.__esModule = true;
	utils.extend = extend$1;
	utils.indexOf = indexOf;
	utils.escapeExpression = escapeExpression;
	utils.isEmpty = isEmpty;
	utils.createFrame = createFrame;
	utils.blockParams = blockParams;
	utils.appendContextPath = appendContextPath;
	var escape$1 = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};
	var badChars = /[&<>"'`=]/g,
	  possible = /[&<>"'`=]/;
	function escapeChar(chr) {
	  return escape$1[chr];
	}
	function extend$1(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }
	  return obj;
	}
	var toString = Object.prototype.toString;
	utils.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  utils.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	utils.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};
	utils.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}
	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }
	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}
	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}
	function createFrame(object) {
	  var frame = extend$1({}, object);
	  frame._parent = object;
	  return frame;
	}
	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}
	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

	var exception = {exports: {}};

	exception.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
	  function Exception(message, node) {
	    var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	    if (loc) {
	      line = loc.start.line;
	      column = loc.start.column;
	      message += ' - ' + line + ':' + column;
	    }
	    var tmp = Error.prototype.constructor.call(this, message);

	    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	    for (var idx = 0; idx < errorProps.length; idx++) {
	      this[errorProps[idx]] = tmp[errorProps[idx]];
	    }

	    /* istanbul ignore else */
	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, Exception);
	    }
	    try {
	      if (loc) {
	        this.lineNumber = line;

	        // Work around issue under safari where we can't directly set the column value
	        /* istanbul ignore next */
	        if (Object.defineProperty) {
	          Object.defineProperty(this, 'column', {
	            value: column,
	            enumerable: true
	          });
	        } else {
	          this.column = column;
	        }
	      }
	    } catch (nop) {
	      /* Ignore if the browser is very particular */
	    }
	  }
	  Exception.prototype = new Error();
	  exports['default'] = Exception;
	  module.exports = exports['default'];
	})(exception, exception.exports);
	var exceptionExports = exception.exports;

	var helpers$1 = {};

	var blockHelperMissing = {exports: {}};

	blockHelperMissing.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  exports['default'] = function (instance) {
	    instance.registerHelper('blockHelperMissing', function (context, options) {
	      var inverse = options.inverse,
	        fn = options.fn;
	      if (context === true) {
	        return fn(this);
	      } else if (context === false || context == null) {
	        return inverse(this);
	      } else if (_utils.isArray(context)) {
	        if (context.length > 0) {
	          if (options.ids) {
	            options.ids = [options.name];
	          }
	          return instance.helpers.each(context, options);
	        } else {
	          return inverse(this);
	        }
	      } else {
	        if (options.data && options.ids) {
	          var data = _utils.createFrame(options.data);
	          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	          options = {
	            data: data
	          };
	        }
	        return fn(context, options);
	      }
	    });
	  };
	  module.exports = exports['default'];
	})(blockHelperMissing, blockHelperMissing.exports);
	var blockHelperMissingExports = blockHelperMissing.exports;

	var each$1 = {exports: {}};

	each$1.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _utils = utils;
	  var _exception = exceptionExports;
	  var _exception2 = _interopRequireDefault(_exception);
	  exports['default'] = function (instance) {
	    instance.registerHelper('each', function (context, options) {
	      if (!options) {
	        throw new _exception2['default']('Must pass iterator to #each');
	      }
	      var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;
	      if (options.data && options.ids) {
	        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	      }
	      if (_utils.isFunction(context)) {
	        context = context.call(this);
	      }
	      if (options.data) {
	        data = _utils.createFrame(options.data);
	      }
	      function execIteration(field, index, last) {
	        if (data) {
	          data.key = field;
	          data.index = index;
	          data.first = index === 0;
	          data.last = !!last;
	          if (contextPath) {
	            data.contextPath = contextPath + field;
	          }
	        }
	        ret = ret + fn(context[field], {
	          data: data,
	          blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	        });
	      }
	      if (context && typeof context === 'object') {
	        if (_utils.isArray(context)) {
	          for (var j = context.length; i < j; i++) {
	            if (i in context) {
	              execIteration(i, i, i === context.length - 1);
	            }
	          }
	        } else {
	          var priorKey = undefined;
	          for (var key in context) {
	            if (context.hasOwnProperty(key)) {
	              // We're running the iterations one step out of sync so we can detect
	              // the last iteration without have to scan the object twice and create
	              // an itermediate keys array.
	              if (priorKey !== undefined) {
	                execIteration(priorKey, i - 1);
	              }
	              priorKey = key;
	              i++;
	            }
	          }
	          if (priorKey !== undefined) {
	            execIteration(priorKey, i - 1, true);
	          }
	        }
	      }
	      if (i === 0) {
	        ret = inverse(this);
	      }
	      return ret;
	    });
	  };
	  module.exports = exports['default'];
	})(each$1, each$1.exports);
	var eachExports = each$1.exports;

	var helperMissing = {exports: {}};

	helperMissing.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _exception = exceptionExports;
	  var _exception2 = _interopRequireDefault(_exception);
	  exports['default'] = function (instance) {
	    instance.registerHelper('helperMissing', function () /* [args, ]options */{
	      if (arguments.length === 1) {
	        // A missing field in a {{foo}} construct.
	        return undefined;
	      } else {
	        // Someone is actually trying to call something, blow up.
	        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	      }
	    });
	  };
	  module.exports = exports['default'];
	})(helperMissing, helperMissing.exports);
	var helperMissingExports = helperMissing.exports;

	var _if = {exports: {}};

	_if.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  exports['default'] = function (instance) {
	    instance.registerHelper('if', function (conditional, options) {
	      if (_utils.isFunction(conditional)) {
	        conditional = conditional.call(this);
	      }

	      // Default behavior is to render the positive path if the value is truthy and not empty.
	      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	      if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	        return options.inverse(this);
	      } else {
	        return options.fn(this);
	      }
	    });
	    instance.registerHelper('unless', function (conditional, options) {
	      return instance.helpers['if'].call(this, conditional, {
	        fn: options.inverse,
	        inverse: options.fn,
	        hash: options.hash
	      });
	    });
	  };
	  module.exports = exports['default'];
	})(_if, _if.exports);
	var _ifExports = _if.exports;

	var log$1 = {exports: {}};

	log$1.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  exports['default'] = function (instance) {
	    instance.registerHelper('log', function () /* message, options */{
	      var args = [undefined],
	        options = arguments[arguments.length - 1];
	      for (var i = 0; i < arguments.length - 1; i++) {
	        args.push(arguments[i]);
	      }
	      var level = 1;
	      if (options.hash.level != null) {
	        level = options.hash.level;
	      } else if (options.data && options.data.level != null) {
	        level = options.data.level;
	      }
	      args[0] = level;
	      instance.log.apply(instance, args);
	    });
	  };
	  module.exports = exports['default'];
	})(log$1, log$1.exports);
	var logExports = log$1.exports;

	var lookup = {exports: {}};

	lookup.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  exports['default'] = function (instance) {
	    instance.registerHelper('lookup', function (obj, field) {
	      return obj && obj[field];
	    });
	  };
	  module.exports = exports['default'];
	})(lookup, lookup.exports);
	var lookupExports = lookup.exports;

	var _with = {exports: {}};

	_with.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  exports['default'] = function (instance) {
	    instance.registerHelper('with', function (context, options) {
	      if (_utils.isFunction(context)) {
	        context = context.call(this);
	      }
	      var fn = options.fn;
	      if (!_utils.isEmpty(context)) {
	        var data = options.data;
	        if (options.data && options.ids) {
	          data = _utils.createFrame(options.data);
	          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	        }
	        return fn(context, {
	          data: data,
	          blockParams: _utils.blockParams([context], [data && data.contextPath])
	        });
	      } else {
	        return options.inverse(this);
	      }
	    });
	  };
	  module.exports = exports['default'];
	})(_with, _with.exports);
	var _withExports = _with.exports;

	helpers$1.__esModule = true;
	helpers$1.registerDefaultHelpers = registerDefaultHelpers;
	// istanbul ignore next

	function _interopRequireDefault$7(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _helpersBlockHelperMissing = blockHelperMissingExports;
	var _helpersBlockHelperMissing2 = _interopRequireDefault$7(_helpersBlockHelperMissing);
	var _helpersEach = eachExports;
	var _helpersEach2 = _interopRequireDefault$7(_helpersEach);
	var _helpersHelperMissing = helperMissingExports;
	var _helpersHelperMissing2 = _interopRequireDefault$7(_helpersHelperMissing);
	var _helpersIf = _ifExports;
	var _helpersIf2 = _interopRequireDefault$7(_helpersIf);
	var _helpersLog = logExports;
	var _helpersLog2 = _interopRequireDefault$7(_helpersLog);
	var _helpersLookup = lookupExports;
	var _helpersLookup2 = _interopRequireDefault$7(_helpersLookup);
	var _helpersWith = _withExports;
	var _helpersWith2 = _interopRequireDefault$7(_helpersWith);
	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

	var decorators = {};

	var inline = {exports: {}};

	inline.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  exports['default'] = function (instance) {
	    instance.registerDecorator('inline', function (fn, props, container, options) {
	      var ret = fn;
	      if (!props.partials) {
	        props.partials = {};
	        ret = function (context, options) {
	          // Create a new partials stack frame prior to exec.
	          var original = container.partials;
	          container.partials = _utils.extend({}, original, props.partials);
	          var ret = fn(context, options);
	          container.partials = original;
	          return ret;
	        };
	      }
	      props.partials[options.args[0]] = options.fn;
	      return ret;
	    });
	  };
	  module.exports = exports['default'];
	})(inline, inline.exports);
	var inlineExports = inline.exports;

	decorators.__esModule = true;
	decorators.registerDefaultDecorators = registerDefaultDecorators;
	// istanbul ignore next

	function _interopRequireDefault$6(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _decoratorsInline = inlineExports;
	var _decoratorsInline2 = _interopRequireDefault$6(_decoratorsInline);
	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

	var logger = {exports: {}};

	logger.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  var logger = {
	    methodMap: ['debug', 'info', 'warn', 'error'],
	    level: 'info',
	    // Maps a given level value to the `methodMap` indexes above.
	    lookupLevel: function lookupLevel(level) {
	      if (typeof level === 'string') {
	        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	        if (levelMap >= 0) {
	          level = levelMap;
	        } else {
	          level = parseInt(level, 10);
	        }
	      }
	      return level;
	    },
	    // Can be overridden in the host environment
	    log: function log(level) {
	      level = logger.lookupLevel(level);
	      if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	        var method = logger.methodMap[level];
	        if (!console[method]) {
	          // eslint-disable-line no-console
	          method = 'log';
	        }
	        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          message[_key - 1] = arguments[_key];
	        }
	        console[method].apply(console, message); // eslint-disable-line no-console
	      }
	    }
	  };
	  exports['default'] = logger;
	  module.exports = exports['default'];
	})(logger, logger.exports);
	var loggerExports = logger.exports;

	base$1.__esModule = true;
	base$1.HandlebarsEnvironment = HandlebarsEnvironment;
	// istanbul ignore next

	function _interopRequireDefault$5(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _utils$3 = utils;
	var _exception$3 = exceptionExports;
	var _exception2$3 = _interopRequireDefault$5(_exception$3);
	var _helpers$1 = helpers$1;
	var _decorators = decorators;
	var _logger = loggerExports;
	var _logger2 = _interopRequireDefault$5(_logger);
	var VERSION = '4.1.0';
	base$1.VERSION = VERSION;
	var COMPILER_REVISION = 7;
	base$1.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2',
	  // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};
	base$1.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';
	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};
	  _helpers$1.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}
	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,
	  logger: _logger2['default'],
	  log: _logger2['default'].log,
	  registerHelper: function registerHelper(name, fn) {
	    if (_utils$3.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2$3['default']('Arg not supported with multiple helpers');
	      }
	      _utils$3.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },
	  registerPartial: function registerPartial(name, partial) {
	    if (_utils$3.toString.call(name) === objectType) {
	      _utils$3.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2$3['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },
	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils$3.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2$3['default']('Arg not supported with multiple decorators');
	      }
	      _utils$3.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};
	var log = _logger2['default'].log;
	base$1.log = log;
	base$1.createFrame = _utils$3.createFrame;
	base$1.logger = _logger2['default'];

	var safeString = {exports: {}};

	safeString.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  function SafeString(string) {
	    this.string = string;
	  }
	  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	    return '' + this.string;
	  };
	  exports['default'] = SafeString;
	  module.exports = exports['default'];
	})(safeString, safeString.exports);
	var safeStringExports = safeString.exports;

	var runtime = {};

	runtime.__esModule = true;
	runtime.checkRevision = checkRevision;
	runtime.template = template;
	runtime.wrapProgram = wrapProgram;
	runtime.resolvePartial = resolvePartial;
	runtime.invokePartial = invokePartial;
	runtime.noop = noop;
	// istanbul ignore next

	function _interopRequireDefault$4(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}

	// istanbul ignore next

	function _interopRequireWildcard$1(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};
	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }
	    newObj['default'] = obj;
	    return newObj;
	  }
	}
	var _utils$2 = utils;
	var Utils$1 = _interopRequireWildcard$1(_utils$2);
	var _exception$2 = exceptionExports;
	var _exception2$2 = _interopRequireDefault$4(_exception$2);
	var _base = base$1;
	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	    currentRevision = _base.COMPILER_REVISION;
	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	        compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2$2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2$2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}
	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2$2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2$2['default']('Unknown template object: ' + typeof templateSpec);
	  }
	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);
	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils$1.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }
	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);
	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }
	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2$2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2$2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },
	    escapeExpression: Utils$1.escapeExpression,
	    invokePartial: invokePartialWrapper,
	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },
	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	        fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },
	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;
	      if (param && common && param !== common) {
	        obj = Utils$1.extend({}, common, param);
	      }
	      return obj;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: Object.seal({}),
	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };
	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    var data = options.data;
	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	      blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }
	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;
	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);
	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2$2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2$2['default']('must pass parent depths');
	    }
	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}
	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }
	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }
	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);
	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}
	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}
	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }
	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = _base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = _base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils$1.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }
	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }
	  if (partial === undefined) {
	    throw new _exception2$2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}
	function noop() {
	  return '';
	}
	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}
	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils$1.extend(prog, props);
	  }
	  return prog;
	}

	var noConflict = {exports: {}};

	/* global window */
	noConflict.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  exports['default'] = function (Handlebars) {
	    /* istanbul ignore next */
	    var root = typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : window,
	      $Handlebars = root.Handlebars;
	    /* istanbul ignore next */
	    Handlebars.noConflict = function () {
	      if (root.Handlebars === Handlebars) {
	        root.Handlebars = $Handlebars;
	      }
	      return Handlebars;
	    };
	  };
	  module.exports = exports['default'];
	})(noConflict, noConflict.exports);
	var noConflictExports = noConflict.exports;

	handlebars_runtime.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }

	  // istanbul ignore next

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};
	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }
	      newObj['default'] = obj;
	      return newObj;
	    }
	  }
	  var _handlebarsBase = base$1;
	  var base = _interopRequireWildcard(_handlebarsBase);

	  // Each of these augment the Handlebars object. No need to setup here.
	  // (This is done to easily share code between commonjs and browse envs)

	  var _handlebarsSafeString = safeStringExports;
	  var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
	  var _handlebarsException = exceptionExports;
	  var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
	  var _handlebarsUtils = utils;
	  var Utils = _interopRequireWildcard(_handlebarsUtils);
	  var _handlebarsRuntime = runtime;
	  var runtime$1 = _interopRequireWildcard(_handlebarsRuntime);
	  var _handlebarsNoConflict = noConflictExports;
	  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
	  function create() {
	    var hb = new base.HandlebarsEnvironment();
	    Utils.extend(hb, base);
	    hb.SafeString = _handlebarsSafeString2['default'];
	    hb.Exception = _handlebarsException2['default'];
	    hb.Utils = Utils;
	    hb.escapeExpression = Utils.escapeExpression;
	    hb.VM = runtime$1;
	    hb.template = function (spec) {
	      return runtime$1.template(spec, hb);
	    };
	    return hb;
	  }
	  var inst = create();
	  inst.create = create;
	  _handlebarsNoConflict2['default'](inst);
	  inst['default'] = inst;
	  exports['default'] = inst;
	  module.exports = exports['default'];
	})(handlebars_runtime, handlebars_runtime.exports);
	var handlebars_runtimeExports = handlebars_runtime.exports;

	var ast = {exports: {}};

	ast.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var AST = {
	    // Public API used to evaluate derived attributes regarding AST nodes
	    helpers: {
	      // a mustache is definitely a helper if:
	      // * it is an eligible helper, and
	      // * it has at least one parameter or hash segment
	      helperExpression: function helperExpression(node) {
	        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	      },
	      scopedId: function scopedId(path) {
	        return /^\.|this\b/.test(path.original);
	      },
	      // an ID is simple if it only has one part, and that part is not
	      // `..` or `this`.
	      simpleId: function simpleId(path) {
	        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	      }
	    }
	  };

	  // Must be exported as an object rather than the root of the module as the jison lexer
	  // must modify the object to operate properly.
	  exports['default'] = AST;
	  module.exports = exports['default'];
	})(ast, ast.exports);
	var astExports = ast.exports;

	var base = {};

	var parser = {exports: {}};

	parser.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var handlebars = function () {
	    var parser = {
	      trace: function trace() {},
	      yy: {},
	      symbols_: {
	        "error": 2,
	        "root": 3,
	        "program": 4,
	        "EOF": 5,
	        "program_repetition0": 6,
	        "statement": 7,
	        "mustache": 8,
	        "block": 9,
	        "rawBlock": 10,
	        "partial": 11,
	        "partialBlock": 12,
	        "content": 13,
	        "COMMENT": 14,
	        "CONTENT": 15,
	        "openRawBlock": 16,
	        "rawBlock_repetition_plus0": 17,
	        "END_RAW_BLOCK": 18,
	        "OPEN_RAW_BLOCK": 19,
	        "helperName": 20,
	        "openRawBlock_repetition0": 21,
	        "openRawBlock_option0": 22,
	        "CLOSE_RAW_BLOCK": 23,
	        "openBlock": 24,
	        "block_option0": 25,
	        "closeBlock": 26,
	        "openInverse": 27,
	        "block_option1": 28,
	        "OPEN_BLOCK": 29,
	        "openBlock_repetition0": 30,
	        "openBlock_option0": 31,
	        "openBlock_option1": 32,
	        "CLOSE": 33,
	        "OPEN_INVERSE": 34,
	        "openInverse_repetition0": 35,
	        "openInverse_option0": 36,
	        "openInverse_option1": 37,
	        "openInverseChain": 38,
	        "OPEN_INVERSE_CHAIN": 39,
	        "openInverseChain_repetition0": 40,
	        "openInverseChain_option0": 41,
	        "openInverseChain_option1": 42,
	        "inverseAndProgram": 43,
	        "INVERSE": 44,
	        "inverseChain": 45,
	        "inverseChain_option0": 46,
	        "OPEN_ENDBLOCK": 47,
	        "OPEN": 48,
	        "mustache_repetition0": 49,
	        "mustache_option0": 50,
	        "OPEN_UNESCAPED": 51,
	        "mustache_repetition1": 52,
	        "mustache_option1": 53,
	        "CLOSE_UNESCAPED": 54,
	        "OPEN_PARTIAL": 55,
	        "partialName": 56,
	        "partial_repetition0": 57,
	        "partial_option0": 58,
	        "openPartialBlock": 59,
	        "OPEN_PARTIAL_BLOCK": 60,
	        "openPartialBlock_repetition0": 61,
	        "openPartialBlock_option0": 62,
	        "param": 63,
	        "sexpr": 64,
	        "OPEN_SEXPR": 65,
	        "sexpr_repetition0": 66,
	        "sexpr_option0": 67,
	        "CLOSE_SEXPR": 68,
	        "hash": 69,
	        "hash_repetition_plus0": 70,
	        "hashSegment": 71,
	        "ID": 72,
	        "EQUALS": 73,
	        "blockParams": 74,
	        "OPEN_BLOCK_PARAMS": 75,
	        "blockParams_repetition_plus0": 76,
	        "CLOSE_BLOCK_PARAMS": 77,
	        "path": 78,
	        "dataName": 79,
	        "STRING": 80,
	        "NUMBER": 81,
	        "BOOLEAN": 82,
	        "UNDEFINED": 83,
	        "NULL": 84,
	        "DATA": 85,
	        "pathSegments": 86,
	        "SEP": 87,
	        "$accept": 0,
	        "$end": 1
	      },
	      terminals_: {
	        2: "error",
	        5: "EOF",
	        14: "COMMENT",
	        15: "CONTENT",
	        18: "END_RAW_BLOCK",
	        19: "OPEN_RAW_BLOCK",
	        23: "CLOSE_RAW_BLOCK",
	        29: "OPEN_BLOCK",
	        33: "CLOSE",
	        34: "OPEN_INVERSE",
	        39: "OPEN_INVERSE_CHAIN",
	        44: "INVERSE",
	        47: "OPEN_ENDBLOCK",
	        48: "OPEN",
	        51: "OPEN_UNESCAPED",
	        54: "CLOSE_UNESCAPED",
	        55: "OPEN_PARTIAL",
	        60: "OPEN_PARTIAL_BLOCK",
	        65: "OPEN_SEXPR",
	        68: "CLOSE_SEXPR",
	        72: "ID",
	        73: "EQUALS",
	        75: "OPEN_BLOCK_PARAMS",
	        77: "CLOSE_BLOCK_PARAMS",
	        80: "STRING",
	        81: "NUMBER",
	        82: "BOOLEAN",
	        83: "UNDEFINED",
	        84: "NULL",
	        85: "DATA",
	        87: "SEP"
	      },
	      productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
	        var $0 = $$.length - 1;
	        switch (yystate) {
	          case 1:
	            return $$[$0 - 1];
	          case 2:
	            this.$ = yy.prepareProgram($$[$0]);
	            break;
	          case 3:
	            this.$ = $$[$0];
	            break;
	          case 4:
	            this.$ = $$[$0];
	            break;
	          case 5:
	            this.$ = $$[$0];
	            break;
	          case 6:
	            this.$ = $$[$0];
	            break;
	          case 7:
	            this.$ = $$[$0];
	            break;
	          case 8:
	            this.$ = $$[$0];
	            break;
	          case 9:
	            this.$ = {
	              type: 'CommentStatement',
	              value: yy.stripComment($$[$0]),
	              strip: yy.stripFlags($$[$0], $$[$0]),
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 10:
	            this.$ = {
	              type: 'ContentStatement',
	              original: $$[$0],
	              value: $$[$0],
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 11:
	            this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	            break;
	          case 12:
	            this.$ = {
	              path: $$[$0 - 3],
	              params: $$[$0 - 2],
	              hash: $$[$0 - 1]
	            };
	            break;
	          case 13:
	            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	            break;
	          case 14:
	            this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	            break;
	          case 15:
	            this.$ = {
	              open: $$[$0 - 5],
	              path: $$[$0 - 4],
	              params: $$[$0 - 3],
	              hash: $$[$0 - 2],
	              blockParams: $$[$0 - 1],
	              strip: yy.stripFlags($$[$0 - 5], $$[$0])
	            };
	            break;
	          case 16:
	            this.$ = {
	              path: $$[$0 - 4],
	              params: $$[$0 - 3],
	              hash: $$[$0 - 2],
	              blockParams: $$[$0 - 1],
	              strip: yy.stripFlags($$[$0 - 5], $$[$0])
	            };
	            break;
	          case 17:
	            this.$ = {
	              path: $$[$0 - 4],
	              params: $$[$0 - 3],
	              hash: $$[$0 - 2],
	              blockParams: $$[$0 - 1],
	              strip: yy.stripFlags($$[$0 - 5], $$[$0])
	            };
	            break;
	          case 18:
	            this.$ = {
	              strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
	              program: $$[$0]
	            };
	            break;
	          case 19:
	            var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	              program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	            program.chained = true;
	            this.$ = {
	              strip: $$[$0 - 2].strip,
	              program: program,
	              chain: true
	            };
	            break;
	          case 20:
	            this.$ = $$[$0];
	            break;
	          case 21:
	            this.$ = {
	              path: $$[$0 - 1],
	              strip: yy.stripFlags($$[$0 - 2], $$[$0])
	            };
	            break;
	          case 22:
	            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	            break;
	          case 23:
	            this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	            break;
	          case 24:
	            this.$ = {
	              type: 'PartialStatement',
	              name: $$[$0 - 3],
	              params: $$[$0 - 2],
	              hash: $$[$0 - 1],
	              indent: '',
	              strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 25:
	            this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	            break;
	          case 26:
	            this.$ = {
	              path: $$[$0 - 3],
	              params: $$[$0 - 2],
	              hash: $$[$0 - 1],
	              strip: yy.stripFlags($$[$0 - 4], $$[$0])
	            };
	            break;
	          case 27:
	            this.$ = $$[$0];
	            break;
	          case 28:
	            this.$ = $$[$0];
	            break;
	          case 29:
	            this.$ = {
	              type: 'SubExpression',
	              path: $$[$0 - 3],
	              params: $$[$0 - 2],
	              hash: $$[$0 - 1],
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 30:
	            this.$ = {
	              type: 'Hash',
	              pairs: $$[$0],
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 31:
	            this.$ = {
	              type: 'HashPair',
	              key: yy.id($$[$0 - 2]),
	              value: $$[$0],
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 32:
	            this.$ = yy.id($$[$0 - 1]);
	            break;
	          case 33:
	            this.$ = $$[$0];
	            break;
	          case 34:
	            this.$ = $$[$0];
	            break;
	          case 35:
	            this.$ = {
	              type: 'StringLiteral',
	              value: $$[$0],
	              original: $$[$0],
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 36:
	            this.$ = {
	              type: 'NumberLiteral',
	              value: Number($$[$0]),
	              original: Number($$[$0]),
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 37:
	            this.$ = {
	              type: 'BooleanLiteral',
	              value: $$[$0] === 'true',
	              original: $$[$0] === 'true',
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 38:
	            this.$ = {
	              type: 'UndefinedLiteral',
	              original: undefined,
	              value: undefined,
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 39:
	            this.$ = {
	              type: 'NullLiteral',
	              original: null,
	              value: null,
	              loc: yy.locInfo(this._$)
	            };
	            break;
	          case 40:
	            this.$ = $$[$0];
	            break;
	          case 41:
	            this.$ = $$[$0];
	            break;
	          case 42:
	            this.$ = yy.preparePath(true, $$[$0], this._$);
	            break;
	          case 43:
	            this.$ = yy.preparePath(false, $$[$0], this._$);
	            break;
	          case 44:
	            $$[$0 - 2].push({
	              part: yy.id($$[$0]),
	              original: $$[$0],
	              separator: $$[$0 - 1]
	            });
	            this.$ = $$[$0 - 2];
	            break;
	          case 45:
	            this.$ = [{
	              part: yy.id($$[$0]),
	              original: $$[$0]
	            }];
	            break;
	          case 46:
	            this.$ = [];
	            break;
	          case 47:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 48:
	            this.$ = [$$[$0]];
	            break;
	          case 49:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 50:
	            this.$ = [];
	            break;
	          case 51:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 58:
	            this.$ = [];
	            break;
	          case 59:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 64:
	            this.$ = [];
	            break;
	          case 65:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 70:
	            this.$ = [];
	            break;
	          case 71:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 78:
	            this.$ = [];
	            break;
	          case 79:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 82:
	            this.$ = [];
	            break;
	          case 83:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 86:
	            this.$ = [];
	            break;
	          case 87:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 90:
	            this.$ = [];
	            break;
	          case 91:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 94:
	            this.$ = [];
	            break;
	          case 95:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 98:
	            this.$ = [$$[$0]];
	            break;
	          case 99:
	            $$[$0 - 1].push($$[$0]);
	            break;
	          case 100:
	            this.$ = [$$[$0]];
	            break;
	          case 101:
	            $$[$0 - 1].push($$[$0]);
	            break;
	        }
	      },
	      table: [{
	        3: 1,
	        4: 2,
	        5: [2, 46],
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        1: [3]
	      }, {
	        5: [1, 4]
	      }, {
	        5: [2, 2],
	        7: 5,
	        8: 6,
	        9: 7,
	        10: 8,
	        11: 9,
	        12: 10,
	        13: 11,
	        14: [1, 12],
	        15: [1, 20],
	        16: 17,
	        19: [1, 23],
	        24: 15,
	        27: 16,
	        29: [1, 21],
	        34: [1, 22],
	        39: [2, 2],
	        44: [2, 2],
	        47: [2, 2],
	        48: [1, 13],
	        51: [1, 14],
	        55: [1, 18],
	        59: 19,
	        60: [1, 24]
	      }, {
	        1: [2, 1]
	      }, {
	        5: [2, 47],
	        14: [2, 47],
	        15: [2, 47],
	        19: [2, 47],
	        29: [2, 47],
	        34: [2, 47],
	        39: [2, 47],
	        44: [2, 47],
	        47: [2, 47],
	        48: [2, 47],
	        51: [2, 47],
	        55: [2, 47],
	        60: [2, 47]
	      }, {
	        5: [2, 3],
	        14: [2, 3],
	        15: [2, 3],
	        19: [2, 3],
	        29: [2, 3],
	        34: [2, 3],
	        39: [2, 3],
	        44: [2, 3],
	        47: [2, 3],
	        48: [2, 3],
	        51: [2, 3],
	        55: [2, 3],
	        60: [2, 3]
	      }, {
	        5: [2, 4],
	        14: [2, 4],
	        15: [2, 4],
	        19: [2, 4],
	        29: [2, 4],
	        34: [2, 4],
	        39: [2, 4],
	        44: [2, 4],
	        47: [2, 4],
	        48: [2, 4],
	        51: [2, 4],
	        55: [2, 4],
	        60: [2, 4]
	      }, {
	        5: [2, 5],
	        14: [2, 5],
	        15: [2, 5],
	        19: [2, 5],
	        29: [2, 5],
	        34: [2, 5],
	        39: [2, 5],
	        44: [2, 5],
	        47: [2, 5],
	        48: [2, 5],
	        51: [2, 5],
	        55: [2, 5],
	        60: [2, 5]
	      }, {
	        5: [2, 6],
	        14: [2, 6],
	        15: [2, 6],
	        19: [2, 6],
	        29: [2, 6],
	        34: [2, 6],
	        39: [2, 6],
	        44: [2, 6],
	        47: [2, 6],
	        48: [2, 6],
	        51: [2, 6],
	        55: [2, 6],
	        60: [2, 6]
	      }, {
	        5: [2, 7],
	        14: [2, 7],
	        15: [2, 7],
	        19: [2, 7],
	        29: [2, 7],
	        34: [2, 7],
	        39: [2, 7],
	        44: [2, 7],
	        47: [2, 7],
	        48: [2, 7],
	        51: [2, 7],
	        55: [2, 7],
	        60: [2, 7]
	      }, {
	        5: [2, 8],
	        14: [2, 8],
	        15: [2, 8],
	        19: [2, 8],
	        29: [2, 8],
	        34: [2, 8],
	        39: [2, 8],
	        44: [2, 8],
	        47: [2, 8],
	        48: [2, 8],
	        51: [2, 8],
	        55: [2, 8],
	        60: [2, 8]
	      }, {
	        5: [2, 9],
	        14: [2, 9],
	        15: [2, 9],
	        19: [2, 9],
	        29: [2, 9],
	        34: [2, 9],
	        39: [2, 9],
	        44: [2, 9],
	        47: [2, 9],
	        48: [2, 9],
	        51: [2, 9],
	        55: [2, 9],
	        60: [2, 9]
	      }, {
	        20: 25,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 36,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        4: 37,
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        39: [2, 46],
	        44: [2, 46],
	        47: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        4: 38,
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        44: [2, 46],
	        47: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        13: 40,
	        15: [1, 20],
	        17: 39
	      }, {
	        20: 42,
	        56: 41,
	        64: 43,
	        65: [1, 44],
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        4: 45,
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        47: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        5: [2, 10],
	        14: [2, 10],
	        15: [2, 10],
	        18: [2, 10],
	        19: [2, 10],
	        29: [2, 10],
	        34: [2, 10],
	        39: [2, 10],
	        44: [2, 10],
	        47: [2, 10],
	        48: [2, 10],
	        51: [2, 10],
	        55: [2, 10],
	        60: [2, 10]
	      }, {
	        20: 46,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 47,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 48,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 42,
	        56: 49,
	        64: 43,
	        65: [1, 44],
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        33: [2, 78],
	        49: 50,
	        65: [2, 78],
	        72: [2, 78],
	        80: [2, 78],
	        81: [2, 78],
	        82: [2, 78],
	        83: [2, 78],
	        84: [2, 78],
	        85: [2, 78]
	      }, {
	        23: [2, 33],
	        33: [2, 33],
	        54: [2, 33],
	        65: [2, 33],
	        68: [2, 33],
	        72: [2, 33],
	        75: [2, 33],
	        80: [2, 33],
	        81: [2, 33],
	        82: [2, 33],
	        83: [2, 33],
	        84: [2, 33],
	        85: [2, 33]
	      }, {
	        23: [2, 34],
	        33: [2, 34],
	        54: [2, 34],
	        65: [2, 34],
	        68: [2, 34],
	        72: [2, 34],
	        75: [2, 34],
	        80: [2, 34],
	        81: [2, 34],
	        82: [2, 34],
	        83: [2, 34],
	        84: [2, 34],
	        85: [2, 34]
	      }, {
	        23: [2, 35],
	        33: [2, 35],
	        54: [2, 35],
	        65: [2, 35],
	        68: [2, 35],
	        72: [2, 35],
	        75: [2, 35],
	        80: [2, 35],
	        81: [2, 35],
	        82: [2, 35],
	        83: [2, 35],
	        84: [2, 35],
	        85: [2, 35]
	      }, {
	        23: [2, 36],
	        33: [2, 36],
	        54: [2, 36],
	        65: [2, 36],
	        68: [2, 36],
	        72: [2, 36],
	        75: [2, 36],
	        80: [2, 36],
	        81: [2, 36],
	        82: [2, 36],
	        83: [2, 36],
	        84: [2, 36],
	        85: [2, 36]
	      }, {
	        23: [2, 37],
	        33: [2, 37],
	        54: [2, 37],
	        65: [2, 37],
	        68: [2, 37],
	        72: [2, 37],
	        75: [2, 37],
	        80: [2, 37],
	        81: [2, 37],
	        82: [2, 37],
	        83: [2, 37],
	        84: [2, 37],
	        85: [2, 37]
	      }, {
	        23: [2, 38],
	        33: [2, 38],
	        54: [2, 38],
	        65: [2, 38],
	        68: [2, 38],
	        72: [2, 38],
	        75: [2, 38],
	        80: [2, 38],
	        81: [2, 38],
	        82: [2, 38],
	        83: [2, 38],
	        84: [2, 38],
	        85: [2, 38]
	      }, {
	        23: [2, 39],
	        33: [2, 39],
	        54: [2, 39],
	        65: [2, 39],
	        68: [2, 39],
	        72: [2, 39],
	        75: [2, 39],
	        80: [2, 39],
	        81: [2, 39],
	        82: [2, 39],
	        83: [2, 39],
	        84: [2, 39],
	        85: [2, 39]
	      }, {
	        23: [2, 43],
	        33: [2, 43],
	        54: [2, 43],
	        65: [2, 43],
	        68: [2, 43],
	        72: [2, 43],
	        75: [2, 43],
	        80: [2, 43],
	        81: [2, 43],
	        82: [2, 43],
	        83: [2, 43],
	        84: [2, 43],
	        85: [2, 43],
	        87: [1, 51]
	      }, {
	        72: [1, 35],
	        86: 52
	      }, {
	        23: [2, 45],
	        33: [2, 45],
	        54: [2, 45],
	        65: [2, 45],
	        68: [2, 45],
	        72: [2, 45],
	        75: [2, 45],
	        80: [2, 45],
	        81: [2, 45],
	        82: [2, 45],
	        83: [2, 45],
	        84: [2, 45],
	        85: [2, 45],
	        87: [2, 45]
	      }, {
	        52: 53,
	        54: [2, 82],
	        65: [2, 82],
	        72: [2, 82],
	        80: [2, 82],
	        81: [2, 82],
	        82: [2, 82],
	        83: [2, 82],
	        84: [2, 82],
	        85: [2, 82]
	      }, {
	        25: 54,
	        38: 56,
	        39: [1, 58],
	        43: 57,
	        44: [1, 59],
	        45: 55,
	        47: [2, 54]
	      }, {
	        28: 60,
	        43: 61,
	        44: [1, 59],
	        47: [2, 56]
	      }, {
	        13: 63,
	        15: [1, 20],
	        18: [1, 62]
	      }, {
	        15: [2, 48],
	        18: [2, 48]
	      }, {
	        33: [2, 86],
	        57: 64,
	        65: [2, 86],
	        72: [2, 86],
	        80: [2, 86],
	        81: [2, 86],
	        82: [2, 86],
	        83: [2, 86],
	        84: [2, 86],
	        85: [2, 86]
	      }, {
	        33: [2, 40],
	        65: [2, 40],
	        72: [2, 40],
	        80: [2, 40],
	        81: [2, 40],
	        82: [2, 40],
	        83: [2, 40],
	        84: [2, 40],
	        85: [2, 40]
	      }, {
	        33: [2, 41],
	        65: [2, 41],
	        72: [2, 41],
	        80: [2, 41],
	        81: [2, 41],
	        82: [2, 41],
	        83: [2, 41],
	        84: [2, 41],
	        85: [2, 41]
	      }, {
	        20: 65,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        26: 66,
	        47: [1, 67]
	      }, {
	        30: 68,
	        33: [2, 58],
	        65: [2, 58],
	        72: [2, 58],
	        75: [2, 58],
	        80: [2, 58],
	        81: [2, 58],
	        82: [2, 58],
	        83: [2, 58],
	        84: [2, 58],
	        85: [2, 58]
	      }, {
	        33: [2, 64],
	        35: 69,
	        65: [2, 64],
	        72: [2, 64],
	        75: [2, 64],
	        80: [2, 64],
	        81: [2, 64],
	        82: [2, 64],
	        83: [2, 64],
	        84: [2, 64],
	        85: [2, 64]
	      }, {
	        21: 70,
	        23: [2, 50],
	        65: [2, 50],
	        72: [2, 50],
	        80: [2, 50],
	        81: [2, 50],
	        82: [2, 50],
	        83: [2, 50],
	        84: [2, 50],
	        85: [2, 50]
	      }, {
	        33: [2, 90],
	        61: 71,
	        65: [2, 90],
	        72: [2, 90],
	        80: [2, 90],
	        81: [2, 90],
	        82: [2, 90],
	        83: [2, 90],
	        84: [2, 90],
	        85: [2, 90]
	      }, {
	        20: 75,
	        33: [2, 80],
	        50: 72,
	        63: 73,
	        64: 76,
	        65: [1, 44],
	        69: 74,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        72: [1, 80]
	      }, {
	        23: [2, 42],
	        33: [2, 42],
	        54: [2, 42],
	        65: [2, 42],
	        68: [2, 42],
	        72: [2, 42],
	        75: [2, 42],
	        80: [2, 42],
	        81: [2, 42],
	        82: [2, 42],
	        83: [2, 42],
	        84: [2, 42],
	        85: [2, 42],
	        87: [1, 51]
	      }, {
	        20: 75,
	        53: 81,
	        54: [2, 84],
	        63: 82,
	        64: 76,
	        65: [1, 44],
	        69: 83,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        26: 84,
	        47: [1, 67]
	      }, {
	        47: [2, 55]
	      }, {
	        4: 85,
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        39: [2, 46],
	        44: [2, 46],
	        47: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        47: [2, 20]
	      }, {
	        20: 86,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        4: 87,
	        6: 3,
	        14: [2, 46],
	        15: [2, 46],
	        19: [2, 46],
	        29: [2, 46],
	        34: [2, 46],
	        47: [2, 46],
	        48: [2, 46],
	        51: [2, 46],
	        55: [2, 46],
	        60: [2, 46]
	      }, {
	        26: 88,
	        47: [1, 67]
	      }, {
	        47: [2, 57]
	      }, {
	        5: [2, 11],
	        14: [2, 11],
	        15: [2, 11],
	        19: [2, 11],
	        29: [2, 11],
	        34: [2, 11],
	        39: [2, 11],
	        44: [2, 11],
	        47: [2, 11],
	        48: [2, 11],
	        51: [2, 11],
	        55: [2, 11],
	        60: [2, 11]
	      }, {
	        15: [2, 49],
	        18: [2, 49]
	      }, {
	        20: 75,
	        33: [2, 88],
	        58: 89,
	        63: 90,
	        64: 76,
	        65: [1, 44],
	        69: 91,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        65: [2, 94],
	        66: 92,
	        68: [2, 94],
	        72: [2, 94],
	        80: [2, 94],
	        81: [2, 94],
	        82: [2, 94],
	        83: [2, 94],
	        84: [2, 94],
	        85: [2, 94]
	      }, {
	        5: [2, 25],
	        14: [2, 25],
	        15: [2, 25],
	        19: [2, 25],
	        29: [2, 25],
	        34: [2, 25],
	        39: [2, 25],
	        44: [2, 25],
	        47: [2, 25],
	        48: [2, 25],
	        51: [2, 25],
	        55: [2, 25],
	        60: [2, 25]
	      }, {
	        20: 93,
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 75,
	        31: 94,
	        33: [2, 60],
	        63: 95,
	        64: 76,
	        65: [1, 44],
	        69: 96,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        75: [2, 60],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 75,
	        33: [2, 66],
	        36: 97,
	        63: 98,
	        64: 76,
	        65: [1, 44],
	        69: 99,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        75: [2, 66],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 75,
	        22: 100,
	        23: [2, 52],
	        63: 101,
	        64: 76,
	        65: [1, 44],
	        69: 102,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        20: 75,
	        33: [2, 92],
	        62: 103,
	        63: 104,
	        64: 76,
	        65: [1, 44],
	        69: 105,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        33: [1, 106]
	      }, {
	        33: [2, 79],
	        65: [2, 79],
	        72: [2, 79],
	        80: [2, 79],
	        81: [2, 79],
	        82: [2, 79],
	        83: [2, 79],
	        84: [2, 79],
	        85: [2, 79]
	      }, {
	        33: [2, 81]
	      }, {
	        23: [2, 27],
	        33: [2, 27],
	        54: [2, 27],
	        65: [2, 27],
	        68: [2, 27],
	        72: [2, 27],
	        75: [2, 27],
	        80: [2, 27],
	        81: [2, 27],
	        82: [2, 27],
	        83: [2, 27],
	        84: [2, 27],
	        85: [2, 27]
	      }, {
	        23: [2, 28],
	        33: [2, 28],
	        54: [2, 28],
	        65: [2, 28],
	        68: [2, 28],
	        72: [2, 28],
	        75: [2, 28],
	        80: [2, 28],
	        81: [2, 28],
	        82: [2, 28],
	        83: [2, 28],
	        84: [2, 28],
	        85: [2, 28]
	      }, {
	        23: [2, 30],
	        33: [2, 30],
	        54: [2, 30],
	        68: [2, 30],
	        71: 107,
	        72: [1, 108],
	        75: [2, 30]
	      }, {
	        23: [2, 98],
	        33: [2, 98],
	        54: [2, 98],
	        68: [2, 98],
	        72: [2, 98],
	        75: [2, 98]
	      }, {
	        23: [2, 45],
	        33: [2, 45],
	        54: [2, 45],
	        65: [2, 45],
	        68: [2, 45],
	        72: [2, 45],
	        73: [1, 109],
	        75: [2, 45],
	        80: [2, 45],
	        81: [2, 45],
	        82: [2, 45],
	        83: [2, 45],
	        84: [2, 45],
	        85: [2, 45],
	        87: [2, 45]
	      }, {
	        23: [2, 44],
	        33: [2, 44],
	        54: [2, 44],
	        65: [2, 44],
	        68: [2, 44],
	        72: [2, 44],
	        75: [2, 44],
	        80: [2, 44],
	        81: [2, 44],
	        82: [2, 44],
	        83: [2, 44],
	        84: [2, 44],
	        85: [2, 44],
	        87: [2, 44]
	      }, {
	        54: [1, 110]
	      }, {
	        54: [2, 83],
	        65: [2, 83],
	        72: [2, 83],
	        80: [2, 83],
	        81: [2, 83],
	        82: [2, 83],
	        83: [2, 83],
	        84: [2, 83],
	        85: [2, 83]
	      }, {
	        54: [2, 85]
	      }, {
	        5: [2, 13],
	        14: [2, 13],
	        15: [2, 13],
	        19: [2, 13],
	        29: [2, 13],
	        34: [2, 13],
	        39: [2, 13],
	        44: [2, 13],
	        47: [2, 13],
	        48: [2, 13],
	        51: [2, 13],
	        55: [2, 13],
	        60: [2, 13]
	      }, {
	        38: 56,
	        39: [1, 58],
	        43: 57,
	        44: [1, 59],
	        45: 112,
	        46: 111,
	        47: [2, 76]
	      }, {
	        33: [2, 70],
	        40: 113,
	        65: [2, 70],
	        72: [2, 70],
	        75: [2, 70],
	        80: [2, 70],
	        81: [2, 70],
	        82: [2, 70],
	        83: [2, 70],
	        84: [2, 70],
	        85: [2, 70]
	      }, {
	        47: [2, 18]
	      }, {
	        5: [2, 14],
	        14: [2, 14],
	        15: [2, 14],
	        19: [2, 14],
	        29: [2, 14],
	        34: [2, 14],
	        39: [2, 14],
	        44: [2, 14],
	        47: [2, 14],
	        48: [2, 14],
	        51: [2, 14],
	        55: [2, 14],
	        60: [2, 14]
	      }, {
	        33: [1, 114]
	      }, {
	        33: [2, 87],
	        65: [2, 87],
	        72: [2, 87],
	        80: [2, 87],
	        81: [2, 87],
	        82: [2, 87],
	        83: [2, 87],
	        84: [2, 87],
	        85: [2, 87]
	      }, {
	        33: [2, 89]
	      }, {
	        20: 75,
	        63: 116,
	        64: 76,
	        65: [1, 44],
	        67: 115,
	        68: [2, 96],
	        69: 117,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        33: [1, 118]
	      }, {
	        32: 119,
	        33: [2, 62],
	        74: 120,
	        75: [1, 121]
	      }, {
	        33: [2, 59],
	        65: [2, 59],
	        72: [2, 59],
	        75: [2, 59],
	        80: [2, 59],
	        81: [2, 59],
	        82: [2, 59],
	        83: [2, 59],
	        84: [2, 59],
	        85: [2, 59]
	      }, {
	        33: [2, 61],
	        75: [2, 61]
	      }, {
	        33: [2, 68],
	        37: 122,
	        74: 123,
	        75: [1, 121]
	      }, {
	        33: [2, 65],
	        65: [2, 65],
	        72: [2, 65],
	        75: [2, 65],
	        80: [2, 65],
	        81: [2, 65],
	        82: [2, 65],
	        83: [2, 65],
	        84: [2, 65],
	        85: [2, 65]
	      }, {
	        33: [2, 67],
	        75: [2, 67]
	      }, {
	        23: [1, 124]
	      }, {
	        23: [2, 51],
	        65: [2, 51],
	        72: [2, 51],
	        80: [2, 51],
	        81: [2, 51],
	        82: [2, 51],
	        83: [2, 51],
	        84: [2, 51],
	        85: [2, 51]
	      }, {
	        23: [2, 53]
	      }, {
	        33: [1, 125]
	      }, {
	        33: [2, 91],
	        65: [2, 91],
	        72: [2, 91],
	        80: [2, 91],
	        81: [2, 91],
	        82: [2, 91],
	        83: [2, 91],
	        84: [2, 91],
	        85: [2, 91]
	      }, {
	        33: [2, 93]
	      }, {
	        5: [2, 22],
	        14: [2, 22],
	        15: [2, 22],
	        19: [2, 22],
	        29: [2, 22],
	        34: [2, 22],
	        39: [2, 22],
	        44: [2, 22],
	        47: [2, 22],
	        48: [2, 22],
	        51: [2, 22],
	        55: [2, 22],
	        60: [2, 22]
	      }, {
	        23: [2, 99],
	        33: [2, 99],
	        54: [2, 99],
	        68: [2, 99],
	        72: [2, 99],
	        75: [2, 99]
	      }, {
	        73: [1, 109]
	      }, {
	        20: 75,
	        63: 126,
	        64: 76,
	        65: [1, 44],
	        72: [1, 35],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        5: [2, 23],
	        14: [2, 23],
	        15: [2, 23],
	        19: [2, 23],
	        29: [2, 23],
	        34: [2, 23],
	        39: [2, 23],
	        44: [2, 23],
	        47: [2, 23],
	        48: [2, 23],
	        51: [2, 23],
	        55: [2, 23],
	        60: [2, 23]
	      }, {
	        47: [2, 19]
	      }, {
	        47: [2, 77]
	      }, {
	        20: 75,
	        33: [2, 72],
	        41: 127,
	        63: 128,
	        64: 76,
	        65: [1, 44],
	        69: 129,
	        70: 77,
	        71: 78,
	        72: [1, 79],
	        75: [2, 72],
	        78: 26,
	        79: 27,
	        80: [1, 28],
	        81: [1, 29],
	        82: [1, 30],
	        83: [1, 31],
	        84: [1, 32],
	        85: [1, 34],
	        86: 33
	      }, {
	        5: [2, 24],
	        14: [2, 24],
	        15: [2, 24],
	        19: [2, 24],
	        29: [2, 24],
	        34: [2, 24],
	        39: [2, 24],
	        44: [2, 24],
	        47: [2, 24],
	        48: [2, 24],
	        51: [2, 24],
	        55: [2, 24],
	        60: [2, 24]
	      }, {
	        68: [1, 130]
	      }, {
	        65: [2, 95],
	        68: [2, 95],
	        72: [2, 95],
	        80: [2, 95],
	        81: [2, 95],
	        82: [2, 95],
	        83: [2, 95],
	        84: [2, 95],
	        85: [2, 95]
	      }, {
	        68: [2, 97]
	      }, {
	        5: [2, 21],
	        14: [2, 21],
	        15: [2, 21],
	        19: [2, 21],
	        29: [2, 21],
	        34: [2, 21],
	        39: [2, 21],
	        44: [2, 21],
	        47: [2, 21],
	        48: [2, 21],
	        51: [2, 21],
	        55: [2, 21],
	        60: [2, 21]
	      }, {
	        33: [1, 131]
	      }, {
	        33: [2, 63]
	      }, {
	        72: [1, 133],
	        76: 132
	      }, {
	        33: [1, 134]
	      }, {
	        33: [2, 69]
	      }, {
	        15: [2, 12]
	      }, {
	        14: [2, 26],
	        15: [2, 26],
	        19: [2, 26],
	        29: [2, 26],
	        34: [2, 26],
	        47: [2, 26],
	        48: [2, 26],
	        51: [2, 26],
	        55: [2, 26],
	        60: [2, 26]
	      }, {
	        23: [2, 31],
	        33: [2, 31],
	        54: [2, 31],
	        68: [2, 31],
	        72: [2, 31],
	        75: [2, 31]
	      }, {
	        33: [2, 74],
	        42: 135,
	        74: 136,
	        75: [1, 121]
	      }, {
	        33: [2, 71],
	        65: [2, 71],
	        72: [2, 71],
	        75: [2, 71],
	        80: [2, 71],
	        81: [2, 71],
	        82: [2, 71],
	        83: [2, 71],
	        84: [2, 71],
	        85: [2, 71]
	      }, {
	        33: [2, 73],
	        75: [2, 73]
	      }, {
	        23: [2, 29],
	        33: [2, 29],
	        54: [2, 29],
	        65: [2, 29],
	        68: [2, 29],
	        72: [2, 29],
	        75: [2, 29],
	        80: [2, 29],
	        81: [2, 29],
	        82: [2, 29],
	        83: [2, 29],
	        84: [2, 29],
	        85: [2, 29]
	      }, {
	        14: [2, 15],
	        15: [2, 15],
	        19: [2, 15],
	        29: [2, 15],
	        34: [2, 15],
	        39: [2, 15],
	        44: [2, 15],
	        47: [2, 15],
	        48: [2, 15],
	        51: [2, 15],
	        55: [2, 15],
	        60: [2, 15]
	      }, {
	        72: [1, 138],
	        77: [1, 137]
	      }, {
	        72: [2, 100],
	        77: [2, 100]
	      }, {
	        14: [2, 16],
	        15: [2, 16],
	        19: [2, 16],
	        29: [2, 16],
	        34: [2, 16],
	        44: [2, 16],
	        47: [2, 16],
	        48: [2, 16],
	        51: [2, 16],
	        55: [2, 16],
	        60: [2, 16]
	      }, {
	        33: [1, 139]
	      }, {
	        33: [2, 75]
	      }, {
	        33: [2, 32]
	      }, {
	        72: [2, 101],
	        77: [2, 101]
	      }, {
	        14: [2, 17],
	        15: [2, 17],
	        19: [2, 17],
	        29: [2, 17],
	        34: [2, 17],
	        39: [2, 17],
	        44: [2, 17],
	        47: [2, 17],
	        48: [2, 17],
	        51: [2, 17],
	        55: [2, 17],
	        60: [2, 17]
	      }],
	      defaultActions: {
	        4: [2, 1],
	        55: [2, 55],
	        57: [2, 20],
	        61: [2, 57],
	        74: [2, 81],
	        83: [2, 85],
	        87: [2, 18],
	        91: [2, 89],
	        102: [2, 53],
	        105: [2, 93],
	        111: [2, 19],
	        112: [2, 77],
	        117: [2, 97],
	        120: [2, 63],
	        123: [2, 69],
	        124: [2, 12],
	        136: [2, 75],
	        137: [2, 32]
	      },
	      parseError: function parseError(str, hash) {
	        throw new Error(str);
	      },
	      parse: function parse(input) {
	        var self = this,
	          stack = [0],
	          vstack = [null],
	          lstack = [],
	          table = this.table,
	          yytext = "",
	          yylineno = 0,
	          yyleng = 0;
	        this.lexer.setInput(input);
	        this.lexer.yy = this.yy;
	        this.yy.lexer = this.lexer;
	        this.yy.parser = this;
	        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	        var yyloc = this.lexer.yylloc;
	        lstack.push(yyloc);
	        var ranges = this.lexer.options && this.lexer.options.ranges;
	        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	        function lex() {
	          var token;
	          token = self.lexer.lex() || 1;
	          if (typeof token !== "number") {
	            token = self.symbols_[token] || token;
	          }
	          return token;
	        }
	        var symbol,
	          state,
	          action,
	          r,
	          yyval = {},
	          p,
	          len,
	          newState,
	          expected;
	        while (true) {
	          state = stack[stack.length - 1];
	          if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	          } else {
	            if (symbol === null || typeof symbol == "undefined") {
	              symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	          }
	          if (typeof action === "undefined" || !action.length || !action[0]) {
	            var errStr = "";
	            {
	              expected = [];
	              for (p in table[state]) if (this.terminals_[p] && p > 2) {
	                expected.push("'" + this.terminals_[p] + "'");
	              }
	              if (this.lexer.showPosition) {
	                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	              } else {
	                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	              }
	              this.parseError(errStr, {
	                text: this.lexer.match,
	                token: this.terminals_[symbol] || symbol,
	                line: this.lexer.yylineno,
	                loc: yyloc,
	                expected: expected
	              });
	            }
	          }
	          if (action[0] instanceof Array && action.length > 1) {
	            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	          }
	          switch (action[0]) {
	            case 1:
	              stack.push(symbol);
	              vstack.push(this.lexer.yytext);
	              lstack.push(this.lexer.yylloc);
	              stack.push(action[1]);
	              symbol = null;
	              {
	                yyleng = this.lexer.yyleng;
	                yytext = this.lexer.yytext;
	                yylineno = this.lexer.yylineno;
	                yyloc = this.lexer.yylloc;
	              }
	              break;
	            case 2:
	              len = this.productions_[action[1]][1];
	              yyval.$ = vstack[vstack.length - len];
	              yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	              };
	              if (ranges) {
	                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	              }
	              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	              if (typeof r !== "undefined") {
	                return r;
	              }
	              if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	              }
	              stack.push(this.productions_[action[1]][0]);
	              vstack.push(yyval.$);
	              lstack.push(yyval._$);
	              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	              stack.push(newState);
	              break;
	            case 3:
	              return true;
	          }
	        }
	        return true;
	      }
	    };
	    /* Jison generated lexer */
	    var lexer = function () {
	      var lexer = {
	        EOF: 1,
	        parseError: function parseError(str, hash) {
	          if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	          } else {
	            throw new Error(str);
	          }
	        },
	        setInput: function setInput(input) {
	          this._input = input;
	          this._more = this._less = this.done = false;
	          this.yylineno = this.yyleng = 0;
	          this.yytext = this.matched = this.match = '';
	          this.conditionStack = ['INITIAL'];
	          this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	          };
	          if (this.options.ranges) this.yylloc.range = [0, 0];
	          this.offset = 0;
	          return this;
	        },
	        input: function input() {
	          var ch = this._input[0];
	          this.yytext += ch;
	          this.yyleng++;
	          this.offset++;
	          this.match += ch;
	          this.matched += ch;
	          var lines = ch.match(/(?:\r\n?|\n).*/g);
	          if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	          } else {
	            this.yylloc.last_column++;
	          }
	          if (this.options.ranges) this.yylloc.range[1]++;
	          this._input = this._input.slice(1);
	          return ch;
	        },
	        unput: function unput(ch) {
	          var len = ch.length;
	          var lines = ch.split(/(?:\r\n?|\n)/g);
	          this._input = ch + this._input;
	          this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	          //this.yyleng -= len;
	          this.offset -= len;
	          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	          this.match = this.match.substr(0, this.match.length - 1);
	          this.matched = this.matched.substr(0, this.matched.length - 1);
	          if (lines.length - 1) this.yylineno -= lines.length - 1;
	          var r = this.yylloc.range;
	          this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	          };
	          if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	          }
	          return this;
	        },
	        more: function more() {
	          this._more = true;
	          return this;
	        },
	        less: function less(n) {
	          this.unput(this.match.slice(n));
	        },
	        pastInput: function pastInput() {
	          var past = this.matched.substr(0, this.matched.length - this.match.length);
	          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	        },
	        upcomingInput: function upcomingInput() {
	          var next = this.match;
	          if (next.length < 20) {
	            next += this._input.substr(0, 20 - next.length);
	          }
	          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	        },
	        showPosition: function showPosition() {
	          var pre = this.pastInput();
	          var c = new Array(pre.length + 1).join("-");
	          return pre + this.upcomingInput() + "\n" + c + "^";
	        },
	        next: function next() {
	          if (this.done) {
	            return this.EOF;
	          }
	          if (!this._input) this.done = true;
	          var token, match, tempMatch, index, lines;
	          if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	          }
	          var rules = this._currentRules();
	          for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	              match = tempMatch;
	              index = i;
	              if (!this.options.flex) break;
	            }
	          }
	          if (match) {
	            lines = match[0].match(/(?:\r\n?|\n).*/g);
	            if (lines) this.yylineno += lines.length;
	            this.yylloc = {
	              first_line: this.yylloc.last_line,
	              last_line: this.yylineno + 1,
	              first_column: this.yylloc.last_column,
	              last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
	            };
	            this.yytext += match[0];
	            this.match += match[0];
	            this.matches = match;
	            this.yyleng = this.yytext.length;
	            if (this.options.ranges) {
	              this.yylloc.range = [this.offset, this.offset += this.yyleng];
	            }
	            this._more = false;
	            this._input = this._input.slice(match[0].length);
	            this.matched += match[0];
	            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	            if (this.done && this._input) this.done = false;
	            if (token) return token;else return;
	          }
	          if (this._input === "") {
	            return this.EOF;
	          } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	              text: "",
	              token: null,
	              line: this.yylineno
	            });
	          }
	        },
	        lex: function lex() {
	          var r = this.next();
	          if (typeof r !== 'undefined') {
	            return r;
	          } else {
	            return this.lex();
	          }
	        },
	        begin: function begin(condition) {
	          this.conditionStack.push(condition);
	        },
	        popState: function popState() {
	          return this.conditionStack.pop();
	        },
	        _currentRules: function _currentRules() {
	          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        },
	        topState: function topState() {
	          return this.conditionStack[this.conditionStack.length - 2];
	        },
	        pushState: function begin(condition) {
	          this.begin(condition);
	        }
	      };
	      lexer.options = {};
	      lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
	        function strip(start, end) {
	          return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
	        }
	        switch ($avoiding_name_collisions) {
	          case 0:
	            if (yy_.yytext.slice(-2) === "\\\\") {
	              strip(0, 1);
	              this.begin("mu");
	            } else if (yy_.yytext.slice(-1) === "\\") {
	              strip(0, 1);
	              this.begin("emu");
	            } else {
	              this.begin("mu");
	            }
	            if (yy_.yytext) return 15;
	            break;
	          case 1:
	            return 15;
	          case 2:
	            this.popState();
	            return 15;
	          case 3:
	            this.begin('raw');
	            return 15;
	          case 4:
	            this.popState();
	            // Should be using `this.topState()` below, but it currently
	            // returns the second top instead of the first top. Opened an
	            // issue about it at https://github.com/zaach/jison/issues/291
	            if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	              return 15;
	            } else {
	              yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
	              return 'END_RAW_BLOCK';
	            }
	          case 5:
	            return 15;
	          case 6:
	            this.popState();
	            return 14;
	          case 7:
	            return 65;
	          case 8:
	            return 68;
	          case 9:
	            return 19;
	          case 10:
	            this.popState();
	            this.begin('raw');
	            return 23;
	          case 11:
	            return 55;
	          case 12:
	            return 60;
	          case 13:
	            return 29;
	          case 14:
	            return 47;
	          case 15:
	            this.popState();
	            return 44;
	          case 16:
	            this.popState();
	            return 44;
	          case 17:
	            return 34;
	          case 18:
	            return 39;
	          case 19:
	            return 51;
	          case 20:
	            return 48;
	          case 21:
	            this.unput(yy_.yytext);
	            this.popState();
	            this.begin('com');
	            break;
	          case 22:
	            this.popState();
	            return 14;
	          case 23:
	            return 48;
	          case 24:
	            return 73;
	          case 25:
	            return 72;
	          case 26:
	            return 72;
	          case 27:
	            return 87;
	          case 28:
	            // ignore whitespace
	            break;
	          case 29:
	            this.popState();
	            return 54;
	          case 30:
	            this.popState();
	            return 33;
	          case 31:
	            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
	            return 80;
	          case 32:
	            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
	            return 80;
	          case 33:
	            return 85;
	          case 34:
	            return 82;
	          case 35:
	            return 82;
	          case 36:
	            return 83;
	          case 37:
	            return 84;
	          case 38:
	            return 81;
	          case 39:
	            return 75;
	          case 40:
	            return 77;
	          case 41:
	            return 72;
	          case 42:
	            yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
	            return 72;
	          case 43:
	            return 'INVALID';
	          case 44:
	            return 5;
	        }
	      };
	      lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	      lexer.conditions = {
	        "mu": {
	          "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
	          "inclusive": false
	        },
	        "emu": {
	          "rules": [2],
	          "inclusive": false
	        },
	        "com": {
	          "rules": [6],
	          "inclusive": false
	        },
	        "raw": {
	          "rules": [3, 4, 5],
	          "inclusive": false
	        },
	        "INITIAL": {
	          "rules": [0, 1, 44],
	          "inclusive": true
	        }
	      };
	      return lexer;
	    }();
	    parser.lexer = lexer;
	    function Parser() {
	      this.yy = {};
	    }
	    Parser.prototype = parser;
	    parser.Parser = Parser;
	    return new Parser();
	  }();
	  exports["default"] = handlebars;
	  module.exports = exports["default"];
	})(parser, parser.exports);
	var parserExports = parser.exports;

	var whitespaceControl = {exports: {}};

	var visitor = {exports: {}};

	visitor.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _exception = exceptionExports;
	  var _exception2 = _interopRequireDefault(_exception);
	  function Visitor() {
	    this.parents = [];
	  }
	  Visitor.prototype = {
	    constructor: Visitor,
	    mutating: false,
	    // Visits a given value. If mutating, will replace the value if necessary.
	    acceptKey: function acceptKey(node, name) {
	      var value = this.accept(node[name]);
	      if (this.mutating) {
	        // Hacky sanity check: This may have a few false positives for type for the helper
	        // methods but will generally do the right thing without a lot of overhead.
	        if (value && !Visitor.prototype[value.type]) {
	          throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	        }
	        node[name] = value;
	      }
	    },
	    // Performs an accept operation with added sanity check to ensure
	    // required keys are not removed.
	    acceptRequired: function acceptRequired(node, name) {
	      this.acceptKey(node, name);
	      if (!node[name]) {
	        throw new _exception2['default'](node.type + ' requires ' + name);
	      }
	    },
	    // Traverses a given array. If mutating, empty respnses will be removed
	    // for child elements.
	    acceptArray: function acceptArray(array) {
	      for (var i = 0, l = array.length; i < l; i++) {
	        this.acceptKey(array, i);
	        if (!array[i]) {
	          array.splice(i, 1);
	          i--;
	          l--;
	        }
	      }
	    },
	    accept: function accept(object) {
	      if (!object) {
	        return;
	      }

	      /* istanbul ignore next: Sanity code */
	      if (!this[object.type]) {
	        throw new _exception2['default']('Unknown type: ' + object.type, object);
	      }
	      if (this.current) {
	        this.parents.unshift(this.current);
	      }
	      this.current = object;
	      var ret = this[object.type](object);
	      this.current = this.parents.shift();
	      if (!this.mutating || ret) {
	        return ret;
	      } else if (ret !== false) {
	        return object;
	      }
	    },
	    Program: function Program(program) {
	      this.acceptArray(program.body);
	    },
	    MustacheStatement: visitSubExpression,
	    Decorator: visitSubExpression,
	    BlockStatement: visitBlock,
	    DecoratorBlock: visitBlock,
	    PartialStatement: visitPartial,
	    PartialBlockStatement: function PartialBlockStatement(partial) {
	      visitPartial.call(this, partial);
	      this.acceptKey(partial, 'program');
	    },
	    ContentStatement: function ContentStatement() /* content */{},
	    CommentStatement: function CommentStatement() /* comment */{},
	    SubExpression: visitSubExpression,
	    PathExpression: function PathExpression() /* path */{},
	    StringLiteral: function StringLiteral() /* string */{},
	    NumberLiteral: function NumberLiteral() /* number */{},
	    BooleanLiteral: function BooleanLiteral() /* bool */{},
	    UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	    NullLiteral: function NullLiteral() /* literal */{},
	    Hash: function Hash(hash) {
	      this.acceptArray(hash.pairs);
	    },
	    HashPair: function HashPair(pair) {
	      this.acceptRequired(pair, 'value');
	    }
	  };
	  function visitSubExpression(mustache) {
	    this.acceptRequired(mustache, 'path');
	    this.acceptArray(mustache.params);
	    this.acceptKey(mustache, 'hash');
	  }
	  function visitBlock(block) {
	    visitSubExpression.call(this, block);
	    this.acceptKey(block, 'program');
	    this.acceptKey(block, 'inverse');
	  }
	  function visitPartial(partial) {
	    this.acceptRequired(partial, 'name');
	    this.acceptArray(partial.params);
	    this.acceptKey(partial, 'hash');
	  }
	  exports['default'] = Visitor;
	  module.exports = exports['default'];
	})(visitor, visitor.exports);
	var visitorExports = visitor.exports;

	whitespaceControl.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _visitor = visitorExports;
	  var _visitor2 = _interopRequireDefault(_visitor);
	  function WhitespaceControl() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    this.options = options;
	  }
	  WhitespaceControl.prototype = new _visitor2['default']();
	  WhitespaceControl.prototype.Program = function (program) {
	    var doStandalone = !this.options.ignoreStandalone;
	    var isRoot = !this.isRootSeen;
	    this.isRootSeen = true;
	    var body = program.body;
	    for (var i = 0, l = body.length; i < l; i++) {
	      var current = body[i],
	        strip = this.accept(current);
	      if (!strip) {
	        continue;
	      }
	      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
	      if (strip.close) {
	        omitRight(body, i, true);
	      }
	      if (strip.open) {
	        omitLeft(body, i, true);
	      }
	      if (doStandalone && inlineStandalone) {
	        omitRight(body, i);
	        if (omitLeft(body, i)) {
	          // If we are on a standalone node, save the indent info for partials
	          if (current.type === 'PartialStatement') {
	            // Pull out the whitespace from the final line
	            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	          }
	        }
	      }
	      if (doStandalone && openStandalone) {
	        omitRight((current.program || current.inverse).body);

	        // Strip out the previous content node if it's whitespace only
	        omitLeft(body, i);
	      }
	      if (doStandalone && closeStandalone) {
	        // Always strip the next node
	        omitRight(body, i);
	        omitLeft((current.inverse || current.program).body);
	      }
	    }
	    return program;
	  };
	  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	    this.accept(block.program);
	    this.accept(block.inverse);

	    // Find the inverse program that is involed with whitespace stripping.
	    var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;
	    if (inverse && inverse.chained) {
	      firstInverse = inverse.body[0].program;

	      // Walk the inverse chain to find the last inverse that is actually in the chain.
	      while (lastInverse.chained) {
	        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	      }
	    }
	    var strip = {
	      open: block.openStrip.open,
	      close: block.closeStrip.close,
	      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	      // so our parent can determine if we actually are standalone
	      openStandalone: isNextWhitespace(program.body),
	      closeStandalone: isPrevWhitespace((firstInverse || program).body)
	    };
	    if (block.openStrip.close) {
	      omitRight(program.body, null, true);
	    }
	    if (inverse) {
	      var inverseStrip = block.inverseStrip;
	      if (inverseStrip.open) {
	        omitLeft(program.body, null, true);
	      }
	      if (inverseStrip.close) {
	        omitRight(firstInverse.body, null, true);
	      }
	      if (block.closeStrip.open) {
	        omitLeft(lastInverse.body, null, true);
	      }

	      // Find standalone else statments
	      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	        omitLeft(program.body);
	        omitRight(firstInverse.body);
	      }
	    } else if (block.closeStrip.open) {
	      omitLeft(program.body, null, true);
	    }
	    return strip;
	  };
	  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	    return mustache.strip;
	  };
	  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	    /* istanbul ignore next */
	    var strip = node.strip || {};
	    return {
	      inlineStandalone: true,
	      open: strip.open,
	      close: strip.close
	    };
	  };
	  function isPrevWhitespace(body, i, isRoot) {
	    if (i === undefined) {
	      i = body.length;
	    }

	    // Nodes that end with newlines are considered whitespace (but are special
	    // cased for strip operations)
	    var prev = body[i - 1],
	      sibling = body[i - 2];
	    if (!prev) {
	      return isRoot;
	    }
	    if (prev.type === 'ContentStatement') {
	      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	    }
	  }
	  function isNextWhitespace(body, i, isRoot) {
	    if (i === undefined) {
	      i = -1;
	    }
	    var next = body[i + 1],
	      sibling = body[i + 2];
	    if (!next) {
	      return isRoot;
	    }
	    if (next.type === 'ContentStatement') {
	      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	    }
	  }

	  // Marks the node to the right of the position as omitted.
	  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
	  //
	  // If i is undefined, then the first child will be marked as such.
	  //
	  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	  // content is met.
	  function omitRight(body, i, multiple) {
	    var current = body[i == null ? 0 : i + 1];
	    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	      return;
	    }
	    var original = current.value;
	    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	    current.rightStripped = current.value !== original;
	  }

	  // Marks the node to the left of the position as omitted.
	  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
	  //
	  // If i is undefined then the last child will be marked as such.
	  //
	  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	  // content is met.
	  function omitLeft(body, i, multiple) {
	    var current = body[i == null ? body.length - 1 : i - 1];
	    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	      return;
	    }

	    // We omit the last node if it's whitespace only and not preceeded by a non-content node.
	    var original = current.value;
	    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	    current.leftStripped = current.value !== original;
	    return current.leftStripped;
	  }
	  exports['default'] = WhitespaceControl;
	  module.exports = exports['default'];
	})(whitespaceControl, whitespaceControl.exports);
	var whitespaceControlExports = whitespaceControl.exports;

	var helpers = {};

	helpers.__esModule = true;
	helpers.SourceLocation = SourceLocation;
	helpers.id = id;
	helpers.stripFlags = stripFlags;
	helpers.stripComment = stripComment;
	helpers.preparePath = preparePath;
	helpers.prepareMustache = prepareMustache;
	helpers.prepareRawBlock = prepareRawBlock;
	helpers.prepareBlock = prepareBlock;
	helpers.prepareProgram = prepareProgram;
	helpers.preparePartialBlock = preparePartialBlock;
	// istanbul ignore next

	function _interopRequireDefault$3(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _exception$1 = exceptionExports;
	var _exception2$1 = _interopRequireDefault$3(_exception$1);
	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;
	  if (open.path.original !== close) {
	    var errorNode = {
	      loc: open.path.loc
	    };
	    throw new _exception2$1['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}
	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}
	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substr(1, token.length - 2);
	  } else {
	    return token;
	  }
	}
	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}
	function stripComment(comment) {
	  return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}
	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);
	  var original = data ? '@' : '',
	    dig = [],
	    depth = 0;
	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,
	      // If we have [] syntax then we do not treat path references as operators,
	      // i.e. foo.[this] resolves to approximately context.foo['this']
	      isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;
	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2$1['default']('Invalid path: ' + original, {
	          loc: loc
	        });
	      } else if (part === '..') {
	        depth++;
	      }
	    } else {
	      dig.push(part);
	    }
	  }
	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}
	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	    escaped = escapeFlag !== '{' && escapeFlag !== '&';
	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}
	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);
	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };
	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}
	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }
	  var decorator = /\*/.test(openBlock.open);
	  program.blockParams = openBlock.blockParams;
	  var inverse = undefined,
	    inverseStrip = undefined;
	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2$1['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }
	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }
	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }
	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }
	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}
	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	      lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }
	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}
	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);
	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	base.__esModule = true;
	base.parse = parse;
	// istanbul ignore next

	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};
	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }
	    newObj['default'] = obj;
	    return newObj;
	  }
	}

	// istanbul ignore next

	function _interopRequireDefault$2(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _parser = parserExports;
	var _parser2 = _interopRequireDefault$2(_parser);
	var _whitespaceControl = whitespaceControlExports;
	var _whitespaceControl2 = _interopRequireDefault$2(_whitespaceControl);
	var _helpers = helpers;
	var Helpers = _interopRequireWildcard(_helpers);
	var _utils$1 = utils;
	base.parser = _parser2['default'];
	var yy = {};
	_utils$1.extend(yy, Helpers);
	function parse(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }
	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };
	  var strip = new _whitespaceControl2['default'](options);
	  return strip.accept(_parser2['default'].parse(input));
	}

	var compiler = {};

	/* eslint-disable new-cap */
	compiler.__esModule = true;
	compiler.Compiler = Compiler;
	compiler.precompile = precompile;
	compiler.compile = compile;
	// istanbul ignore next

	function _interopRequireDefault$1(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _exception = exceptionExports;
	var _exception2 = _interopRequireDefault$1(_exception);
	var _utils = utils;
	var _ast = astExports;
	var _ast2 = _interopRequireDefault$1(_ast);
	var slice = [].slice;
	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,
	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }
	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	        otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }
	    return true;
	  },
	  guid: 0,
	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;
	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      // the next line should use "Object.keys", but the code has been like this a long time and changing it, might
	      // cause backwards-compatibility issues... It's an old library...
	      // eslint-disable-next-line guard-for-in
	      for (var _name in knownHelpers) {
	        this.options.knownHelpers[_name] = knownHelpers[_name];
	      }
	    }
	    return this.accept(program);
	  },
	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	      // eslint-disable-line new-cap
	      result = childCompiler.compile(program, this.options),
	      guid = this.guid++;
	    this.usePartial = this.usePartial || result.usePartial;
	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;
	    return guid;
	  },
	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }
	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },
	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);
	    var body = program.body,
	      bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }
	    this.options.blockParams.shift();
	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;
	    return this;
	  },
	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);
	    var program = block.program,
	      inverse = block.inverse;
	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);
	    var type = this.classifySexpr(block);
	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }
	    this.opcode('append');
	  },
	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	      path = decorator.path;
	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },
	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;
	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }
	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({
	          type: 'PathExpression',
	          parts: [],
	          depth: 0
	        });
	      }
	    }
	    var partialName = partial.name.original,
	      isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }
	    this.setupFullMustacheParams(partial, program, undefined, true);
	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }
	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },
	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);
	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },
	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },
	  CommentStatement: function CommentStatement() {},
	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);
	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	      name = path.parts[0],
	      isBlock = program != null || inverse != null;
	    this.opcode('getContext', path.depth);
	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);
	    path.strict = true;
	    this.accept(path);
	    this.opcode('invokeAmbiguous', name, isBlock);
	  },
	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },
	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	      path = sexpr.path,
	      name = path.parts[0];
	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;
	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },
	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);
	    var name = path.parts[0],
	      scoped = _ast2['default'].helpers.scopedId(path),
	      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },
	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },
	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },
	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },
	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },
	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },
	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	      i = 0,
	      l = pairs.length;
	    this.opcode('pushHash');
	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },
	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({
	      opcode: name,
	      args: slice.call(arguments, 1),
	      loc: this.sourceNode[0].loc
	    });
	  },
	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }
	    this.useDepths = true;
	  },
	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);
	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	        options = this.options;
	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }
	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },
	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },
	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';
	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }
	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);
	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }
	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },
	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);
	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);
	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }
	    return params;
	  },
	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	        param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};
	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }
	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }
	  var ast = env.parse(input, options),
	    environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}
	function compile(input, options, env) {
	  if (options === undefined) options = {};
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }
	  options = _utils.extend({}, options);
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }
	  var compiled = undefined;
	  function compileInput() {
	    var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options),
	      templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}
	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }
	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}
	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

	var javascriptCompiler = {exports: {}};

	var codeGen = {exports: {}};

	var sourceMap = {};

	var sourceMapGenerator = {};

	var base64Vlq = {};

	var base64 = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredBase64;
	function requireBase64() {
	  if (hasRequiredBase64) return base64;
	  hasRequiredBase64 = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  base64.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + number);
	  };

	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  base64.decode = function (charCode) {
	    var bigA = 65; // 'A'
	    var bigZ = 90; // 'Z'

	    var littleA = 97; // 'a'
	    var littleZ = 122; // 'z'

	    var zero = 48; // '0'
	    var nine = 57; // '9'

	    var plus = 43; // '+'
	    var slash = 47; // '/'

	    var littleOffset = 26;
	    var numberOffset = 52;

	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return charCode - bigA;
	    }

	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return charCode - littleA + littleOffset;
	    }

	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return charCode - zero + numberOffset;
	    }

	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }

	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }

	    // Invalid base64 digit.
	    return -1;
	  };
	  return base64;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredBase64Vlq;
	function requireBase64Vlq() {
	  if (hasRequiredBase64Vlq) return base64Vlq;
	  hasRequiredBase64Vlq = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   *
	   * Based on the Base 64 VLQ implementation in Closure Compiler:
	   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	   *
	   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	   * Redistribution and use in source and binary forms, with or without
	   * modification, are permitted provided that the following conditions are
	   * met:
	   *
	   *  * Redistributions of source code must retain the above copyright
	   *    notice, this list of conditions and the following disclaimer.
	   *  * Redistributions in binary form must reproduce the above
	   *    copyright notice, this list of conditions and the following
	   *    disclaimer in the documentation and/or other materials provided
	   *    with the distribution.
	   *  * Neither the name of Google Inc. nor the names of its
	   *    contributors may be used to endorse or promote products derived
	   *    from this software without specific prior written permission.
	   *
	   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	   */

	  var base64 = requireBase64();

	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011

	  var VLQ_BASE_SHIFT = 5;

	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;

	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;

	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	  }

	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative ? -shifted : shifted;
	  }

	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  base64Vlq.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	    var vlq = toVLQSigned(aValue);
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	    return encoded;
	  };

	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	  return base64Vlq;
	}

	var util = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredUtil;
	function requireUtil() {
	  if (hasRequiredUtil) return util;
	  hasRequiredUtil = 1;
	  (function (exports) {
	    /*
	     * Copyright 2011 Mozilla Foundation and contributors
	     * Licensed under the New BSD license. See LICENSE or:
	     * http://opensource.org/licenses/BSD-3-Clause
	     */

	    /**
	     * This is a helper function for getting values from parameter/options
	     * objects.
	     *
	     * @param args The object we are extracting values from
	     * @param name The name of the property we are getting.
	     * @param defaultValue An optional value to return if the property is missing
	     * from the object. If this is not specified and the property is missing, an
	     * error will be thrown.
	     */
	    function getArg(aArgs, aName, aDefaultValue) {
	      if (aName in aArgs) {
	        return aArgs[aName];
	      } else if (arguments.length === 3) {
	        return aDefaultValue;
	      } else {
	        throw new Error('"' + aName + '" is a required argument.');
	      }
	    }
	    exports.getArg = getArg;
	    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	    var dataUrlRegexp = /^data:.+\,.+$/;
	    function urlParse(aUrl) {
	      var match = aUrl.match(urlRegexp);
	      if (!match) {
	        return null;
	      }
	      return {
	        scheme: match[1],
	        auth: match[2],
	        host: match[3],
	        port: match[4],
	        path: match[5]
	      };
	    }
	    exports.urlParse = urlParse;
	    function urlGenerate(aParsedUrl) {
	      var url = '';
	      if (aParsedUrl.scheme) {
	        url += aParsedUrl.scheme + ':';
	      }
	      url += '//';
	      if (aParsedUrl.auth) {
	        url += aParsedUrl.auth + '@';
	      }
	      if (aParsedUrl.host) {
	        url += aParsedUrl.host;
	      }
	      if (aParsedUrl.port) {
	        url += ":" + aParsedUrl.port;
	      }
	      if (aParsedUrl.path) {
	        url += aParsedUrl.path;
	      }
	      return url;
	    }
	    exports.urlGenerate = urlGenerate;

	    /**
	     * Normalizes a path, or the path portion of a URL:
	     *
	     * - Replaces consecutive slashes with one slash.
	     * - Removes unnecessary '.' parts.
	     * - Removes unnecessary '<dir>/..' parts.
	     *
	     * Based on code in the Node.js 'path' core module.
	     *
	     * @param aPath The path or url to normalize.
	     */
	    function normalize(aPath) {
	      var path = aPath;
	      var url = urlParse(aPath);
	      if (url) {
	        if (!url.path) {
	          return aPath;
	        }
	        path = url.path;
	      }
	      var isAbsolute = exports.isAbsolute(path);
	      var parts = path.split(/\/+/);
	      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	        part = parts[i];
	        if (part === '.') {
	          parts.splice(i, 1);
	        } else if (part === '..') {
	          up++;
	        } else if (up > 0) {
	          if (part === '') {
	            // The first part is blank if the path is absolute. Trying to go
	            // above the root is a no-op. Therefore we can remove all '..' parts
	            // directly after the root.
	            parts.splice(i + 1, up);
	            up = 0;
	          } else {
	            parts.splice(i, 2);
	            up--;
	          }
	        }
	      }
	      path = parts.join('/');
	      if (path === '') {
	        path = isAbsolute ? '/' : '.';
	      }
	      if (url) {
	        url.path = path;
	        return urlGenerate(url);
	      }
	      return path;
	    }
	    exports.normalize = normalize;

	    /**
	     * Joins two paths/URLs.
	     *
	     * @param aRoot The root path or URL.
	     * @param aPath The path or URL to be joined with the root.
	     *
	     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	     *   first.
	     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	     *   is updated with the result and aRoot is returned. Otherwise the result
	     *   is returned.
	     *   - If aPath is absolute, the result is aPath.
	     *   - Otherwise the two paths are joined with a slash.
	     * - Joining for example 'http://' and 'www.example.com' is also supported.
	     */
	    function join(aRoot, aPath) {
	      if (aRoot === "") {
	        aRoot = ".";
	      }
	      if (aPath === "") {
	        aPath = ".";
	      }
	      var aPathUrl = urlParse(aPath);
	      var aRootUrl = urlParse(aRoot);
	      if (aRootUrl) {
	        aRoot = aRootUrl.path || '/';
	      }

	      // `join(foo, '//www.example.org')`
	      if (aPathUrl && !aPathUrl.scheme) {
	        if (aRootUrl) {
	          aPathUrl.scheme = aRootUrl.scheme;
	        }
	        return urlGenerate(aPathUrl);
	      }
	      if (aPathUrl || aPath.match(dataUrlRegexp)) {
	        return aPath;
	      }

	      // `join('http://', 'www.example.com')`
	      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	        aRootUrl.host = aPath;
	        return urlGenerate(aRootUrl);
	      }
	      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	      if (aRootUrl) {
	        aRootUrl.path = joined;
	        return urlGenerate(aRootUrl);
	      }
	      return joined;
	    }
	    exports.join = join;
	    exports.isAbsolute = function (aPath) {
	      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	    };

	    /**
	     * Make a path relative to a URL or another path.
	     *
	     * @param aRoot The root path or URL.
	     * @param aPath The path or URL to be made relative to aRoot.
	     */
	    function relative(aRoot, aPath) {
	      if (aRoot === "") {
	        aRoot = ".";
	      }
	      aRoot = aRoot.replace(/\/$/, '');

	      // It is possible for the path to be above the root. In this case, simply
	      // checking whether the root is a prefix of the path won't work. Instead, we
	      // need to remove components from the root one by one, until either we find
	      // a prefix that fits, or we run out of components to remove.
	      var level = 0;
	      while (aPath.indexOf(aRoot + '/') !== 0) {
	        var index = aRoot.lastIndexOf("/");
	        if (index < 0) {
	          return aPath;
	        }

	        // If the only part of the root that is left is the scheme (i.e. http://,
	        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	        // have exhausted all components, so the path is not relative to the root.
	        aRoot = aRoot.slice(0, index);
	        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	          return aPath;
	        }
	        ++level;
	      }

	      // Make sure we add a "../" for each component we removed from the root.
	      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	    }
	    exports.relative = relative;
	    var supportsNullProto = function () {
	      var obj = Object.create(null);
	      return !('__proto__' in obj);
	    }();
	    function identity(s) {
	      return s;
	    }

	    /**
	     * Because behavior goes wacky when you set `__proto__` on objects, we
	     * have to prefix all the strings in our set with an arbitrary character.
	     *
	     * See https://github.com/mozilla/source-map/pull/31 and
	     * https://github.com/mozilla/source-map/issues/30
	     *
	     * @param String aStr
	     */
	    function toSetString(aStr) {
	      if (isProtoString(aStr)) {
	        return '$' + aStr;
	      }
	      return aStr;
	    }
	    exports.toSetString = supportsNullProto ? identity : toSetString;
	    function fromSetString(aStr) {
	      if (isProtoString(aStr)) {
	        return aStr.slice(1);
	      }
	      return aStr;
	    }
	    exports.fromSetString = supportsNullProto ? identity : fromSetString;
	    function isProtoString(s) {
	      if (!s) {
	        return false;
	      }
	      var length = s.length;
	      if (length < 9 /* "__proto__".length */) {
	        return false;
	      }
	      if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
	        return false;
	      }
	      for (var i = length - 10; i >= 0; i--) {
	        if (s.charCodeAt(i) !== 36 /* '$' */) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Comparator between two mappings where the original positions are compared.
	     *
	     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	     * mappings with the same original source/line/column, but different generated
	     * line and column the same. Useful when searching for a mapping with a
	     * stubbed out mapping.
	     */
	    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	      var cmp = strcmp(mappingA.source, mappingB.source);
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalLine - mappingB.originalLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalColumn - mappingB.originalColumn;
	      if (cmp !== 0 || onlyCompareOriginal) {
	        return cmp;
	      }
	      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.generatedLine - mappingB.generatedLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      return strcmp(mappingA.name, mappingB.name);
	    }
	    exports.compareByOriginalPositions = compareByOriginalPositions;

	    /**
	     * Comparator between two mappings with deflated source and name indices where
	     * the generated positions are compared.
	     *
	     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	     * mappings with the same generated line and column, but different
	     * source/name/original line and column the same. Useful when searching for a
	     * mapping with a stubbed out mapping.
	     */
	    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	      var cmp = mappingA.generatedLine - mappingB.generatedLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	      if (cmp !== 0 || onlyCompareGenerated) {
	        return cmp;
	      }
	      cmp = strcmp(mappingA.source, mappingB.source);
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalLine - mappingB.originalLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalColumn - mappingB.originalColumn;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      return strcmp(mappingA.name, mappingB.name);
	    }
	    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	    function strcmp(aStr1, aStr2) {
	      if (aStr1 === aStr2) {
	        return 0;
	      }
	      if (aStr1 === null) {
	        return 1; // aStr2 !== null
	      }
	      if (aStr2 === null) {
	        return -1; // aStr1 !== null
	      }
	      if (aStr1 > aStr2) {
	        return 1;
	      }
	      return -1;
	    }

	    /**
	     * Comparator between two mappings with inflated source and name strings where
	     * the generated positions are compared.
	     */
	    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	      var cmp = mappingA.generatedLine - mappingB.generatedLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = strcmp(mappingA.source, mappingB.source);
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalLine - mappingB.originalLine;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      cmp = mappingA.originalColumn - mappingB.originalColumn;
	      if (cmp !== 0) {
	        return cmp;
	      }
	      return strcmp(mappingA.name, mappingB.name);
	    }
	    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	    /**
	     * Strip any JSON XSSI avoidance prefix from the string (as documented
	     * in the source maps specification), and then parse the string as
	     * JSON.
	     */
	    function parseSourceMapInput(str) {
	      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	    }
	    exports.parseSourceMapInput = parseSourceMapInput;

	    /**
	     * Compute the URL of a source given the the source root, the source's
	     * URL, and the source map's URL.
	     */
	    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	      sourceURL = sourceURL || '';
	      if (sourceRoot) {
	        // This follows what Chrome does.
	        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	          sourceRoot += '/';
	        }
	        // The spec says:
	        //   Line 4: An optional source root, useful for relocating source
	        //   files on a server or removing repeated values in the
	        //   âsourcesâ entry.  This value is prepended to the individual
	        //   entries in the âsourceâ field.
	        sourceURL = sourceRoot + sourceURL;
	      }

	      // Historically, SourceMapConsumer did not take the sourceMapURL as
	      // a parameter.  This mode is still somewhat supported, which is why
	      // this code block is conditional.  However, it's preferable to pass
	      // the source map URL to SourceMapConsumer, so that this function
	      // can implement the source URL resolution algorithm as outlined in
	      // the spec.  This block is basically the equivalent of:
	      //    new URL(sourceURL, sourceMapURL).toString()
	      // ... except it avoids using URL, which wasn't available in the
	      // older releases of node still supported by this library.
	      //
	      // The spec says:
	      //   If the sources are not absolute URLs after prepending of the
	      //   âsourceRootâ, the sources are resolved relative to the
	      //   SourceMap (like resolving script src in a html document).
	      if (sourceMapURL) {
	        var parsed = urlParse(sourceMapURL);
	        if (!parsed) {
	          throw new Error("sourceMapURL could not be parsed");
	        }
	        if (parsed.path) {
	          // Strip the last path component, but keep the "/".
	          var index = parsed.path.lastIndexOf('/');
	          if (index >= 0) {
	            parsed.path = parsed.path.substring(0, index + 1);
	          }
	        }
	        sourceURL = join(urlGenerate(parsed), sourceURL);
	      }
	      return normalize(sourceURL);
	    }
	    exports.computeSourceURL = computeSourceURL;
	  })(util);
	  return util;
	}

	var arraySet = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredArraySet;
	function requireArraySet() {
	  if (hasRequiredArraySet) return arraySet;
	  hasRequiredArraySet = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var util = requireUtil();
	  var has = Object.prototype.hasOwnProperty;
	  var hasNativeMap = typeof Map !== "undefined";

	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = hasNativeMap ? new Map() : Object.create(null);
	  }

	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };

	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	  };

	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      if (hasNativeMap) {
	        this._set.set(aStr, idx);
	      } else {
	        this._set[sStr] = idx;
	      }
	    }
	  };

	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    if (hasNativeMap) {
	      return this._set.has(aStr);
	    } else {
	      var sStr = util.toSetString(aStr);
	      return has.call(this._set, sStr);
	    }
	  };

	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    if (hasNativeMap) {
	      var idx = this._set.get(aStr);
	      if (idx >= 0) {
	        return idx;
	      }
	    } else {
	      var sStr = util.toSetString(aStr);
	      if (has.call(this._set, sStr)) {
	        return this._set[sStr];
	      }
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };

	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };

	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	  arraySet.ArraySet = ArraySet;
	  return arraySet;
	}

	var mappingList = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredMappingList;
	function requireMappingList() {
	  if (hasRequiredMappingList) return mappingList;
	  hasRequiredMappingList = 1;
	  /*
	   * Copyright 2014 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var util = requireUtil();

	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }

	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {
	      generatedLine: -1,
	      generatedColumn: 0
	    };
	  }

	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };

	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	  mappingList.MappingList = MappingList;
	  return mappingList;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredSourceMapGenerator;
	function requireSourceMapGenerator() {
	  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	  hasRequiredSourceMapGenerator = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var base64VLQ = requireBase64Vlq();
	  var util = requireUtil();
	  var ArraySet = requireArraySet().ArraySet;
	  var MappingList = requireMappingList().MappingList;

	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	  SourceMapGenerator.prototype._version = 3;

	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }
	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
	    }
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
	      // Cases 2 and 3.
	      return;
	    } else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      } else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	      result += next;
	    }
	    return result;
	  };
	  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
	    }, this);
	  };

	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	    return map;
	  };

	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	  return sourceMapGenerator;
	}

	var sourceMapConsumer = {};

	var binarySearch = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredBinarySearch;
	function requireBinarySearch() {
	  if (hasRequiredBinarySearch) return binarySearch;
	  hasRequiredBinarySearch = 1;
	  (function (exports) {
	    /*
	     * Copyright 2011 Mozilla Foundation and contributors
	     * Licensed under the New BSD license. See LICENSE or:
	     * http://opensource.org/licenses/BSD-3-Clause
	     */

	    exports.GREATEST_LOWER_BOUND = 1;
	    exports.LEAST_UPPER_BOUND = 2;

	    /**
	     * Recursive implementation of binary search.
	     *
	     * @param aLow Indices here and lower do not contain the needle.
	     * @param aHigh Indices here and higher do not contain the needle.
	     * @param aNeedle The element being searched for.
	     * @param aHaystack The non-empty array being searched.
	     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	     *     closest element that is smaller than or greater than the one we are
	     *     searching for, respectively, if the exact element cannot be found.
	     */
	    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	      // This function terminates when one of the following is true:
	      //
	      //   1. We find the exact element we are looking for.
	      //
	      //   2. We did not find the exact element, but we can return the index of
	      //      the next-closest element.
	      //
	      //   3. We did not find the exact element, and there is no next-closest
	      //      element than the one we are searching for, so we return -1.
	      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	      var cmp = aCompare(aNeedle, aHaystack[mid], true);
	      if (cmp === 0) {
	        // Found the element we are looking for.
	        return mid;
	      } else if (cmp > 0) {
	        // Our needle is greater than aHaystack[mid].
	        if (aHigh - mid > 1) {
	          // The element is in the upper half.
	          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	        }

	        // The exact needle element was not found in this haystack. Determine if
	        // we are in termination case (3) or (2) and return the appropriate thing.
	        if (aBias == exports.LEAST_UPPER_BOUND) {
	          return aHigh < aHaystack.length ? aHigh : -1;
	        } else {
	          return mid;
	        }
	      } else {
	        // Our needle is less than aHaystack[mid].
	        if (mid - aLow > 1) {
	          // The element is in the lower half.
	          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	        }

	        // we are in termination case (3) or (2) and return the appropriate thing.
	        if (aBias == exports.LEAST_UPPER_BOUND) {
	          return mid;
	        } else {
	          return aLow < 0 ? -1 : aLow;
	        }
	      }
	    }

	    /**
	     * This is an implementation of binary search which will always try and return
	     * the index of the closest element if there is no exact hit. This is because
	     * mappings between original and generated line/col pairs are single points,
	     * and there is an implicit region between each of them, so a miss just means
	     * that you aren't on the very start of a region.
	     *
	     * @param aNeedle The element you are looking for.
	     * @param aHaystack The array that is being searched.
	     * @param aCompare A function which takes the needle and an element in the
	     *     array and returns -1, 0, or 1 depending on whether the needle is less
	     *     than, equal to, or greater than the element, respectively.
	     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	     *     closest element that is smaller than or greater than the one we are
	     *     searching for, respectively, if the exact element cannot be found.
	     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	     */
	    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	      if (aHaystack.length === 0) {
	        return -1;
	      }
	      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	      if (index < 0) {
	        return -1;
	      }

	      // We have found either the exact element, or the next-closest element than
	      // the one we are searching for. However, there may be more than one such
	      // element. Make sure we always return the smallest of these.
	      while (index - 1 >= 0) {
	        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	          break;
	        }
	        --index;
	      }
	      return index;
	    };
	  })(binarySearch);
	  return binarySearch;
	}

	var quickSort = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredQuickSort;
	function requireQuickSort() {
	  if (hasRequiredQuickSort) return quickSort;
	  hasRequiredQuickSort = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.

	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }

	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + Math.random() * (high - low));
	  }

	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.

	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.

	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];

	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	      swap(ary, i + 1, j);
	      var q = i + 1;

	      // (2) Recurse on each half.

	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }

	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  quickSort.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	  return quickSort;
	}

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredSourceMapConsumer;
	function requireSourceMapConsumer() {
	  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	  hasRequiredSourceMapConsumer = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var util = requireUtil();
	  var binarySearch = requireBinarySearch();
	  var ArraySet = requireArraySet().ArraySet;
	  var base64VLQ = requireBase64Vlq();
	  var quickSort = requireQuickSort().quickSort;
	  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = util.parseSourceMapInput(aSourceMap);
	    }
	    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	  }
	  SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	  };

	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;

	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.

	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    configurable: true,
	    enumerable: true,
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	      return this.__generatedMappings;
	    }
	  });
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    configurable: true,
	    enumerable: true,
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	      return this.__originalMappings;
	    }
	  });
	  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	    var mappings;
	    switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	    }
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.  The line number is 1-based.
	   *   - column: Optional. the column number in the original source.
	   *    The column number is 0-based.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.  The
	   *    line number is 1-based.
	   *   - column: The column number in the generated source, or null.
	   *    The column number is 0-based.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }
	    var mappings = [];
	    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	    return mappings;
	  };
	  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The first parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * The second parameter, if given, is a string whose value is the URL
	   * at which the source map was found.  This URL is used to compute the
	   * sources array.
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = util.parseSourceMapInput(aSourceMap);
	    }
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);

	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	    if (sourceRoot) {
	      sourceRoot = util.normalize(sourceRoot);
	    }
	    sources = sources.map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
	    });

	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names.map(String), true);
	    this._sources = ArraySet.fromArray(sources, true);
	    this._absoluteSources = this._sources.toArray().map(function (s) {
	      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	    });
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this._sourceMapURL = aSourceMapURL;
	    this.file = file;
	  }
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	  /**
	   * Utility function to find the index of a source.  Returns -1 if not
	   * found.
	   */
	  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }
	    if (this._sources.has(relativeSource)) {
	      return this._sources.indexOf(relativeSource);
	    }

	    // Maybe aSource is an absolute URL as returned by |sources|.  In
	    // this case we can't simply undo the transform.
	    var i;
	    for (i = 0; i < this._absoluteSources.length; ++i) {
	      if (this._absoluteSources[i] == aSource) {
	        return i;
	      }
	    }
	    return -1;
	  };

	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @param String aSourceMapURL
	   *        The URL at which the source map can be found (optional)
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping();
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	        destOriginalMappings.push(destMapping);
	      }
	      destGeneratedMappings.push(destMapping);
	    }
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	    return smc;
	  };

	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;

	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._absoluteSources.slice();
	    }
	  });

	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }

	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      } else if (aStr.charAt(index) === ',') {
	        index++;
	      } else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
	    }
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.  The line number
	   *     is 1-based.
	   *   - column: The column number in the generated source.  The column
	   *     number is 0-based.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.  The
	   *     line number is 1-based.
	   *   - column: The column number in the original source, or null.  The
	   *     column number is 0-based.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
	      return sc == null;
	    });
	  };

	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }
	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }
	    var url;
	    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
	      }
	      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    } else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.  The line number
	   *     is 1-based.
	   *   - column: The column number in the original source.  The column
	   *     number is 0-based.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.  The
	   *     line number is 1-based.
	   *   - column: The column number in the generated source, or null.
	   *     The column number is 0-based.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The first parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * The second parameter, if given, is a string whose value is the URL
	   * at which the source map was found.  This URL is used to compute the
	   * sources array.
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = util.parseSourceMapInput(aSourceMap);
	    }
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	      };
	    });
	  }
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;

	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      }
	      return sources;
	    }
	  });

	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.  The line number
	   *     is 1-based.
	   *   - column: The column number in the generated source.  The column
	   *     number is 0-based.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.  The
	   *     line number is 1-based.
	   *   - column: The column number in the original source, or null.  The
	   *     column number is 0-based.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
	      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	      if (cmp) {
	        return cmp;
	      }
	      return needle.generatedColumn - section.generatedOffset.generatedColumn;
	    });
	    var section = this._sections[sectionIndex];
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
	      bias: aArgs.bias
	    });
	  };

	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    } else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.  The line number
	   *     is 1-based.
	   *   - column: The column number in the original source.  The column
	   *     number is 0-based.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.  The
	   *     line number is 1-based. 
	   *   - column: The column number in the generated source, or null.
	   *     The column number is 0-based.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
	        };
	        return ret;
	      }
	    }
	    return {
	      line: null,
	      column: null
	    };
	  };

	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	  return sourceMapConsumer;
	}

	var sourceNode = {};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	var hasRequiredSourceNode;
	function requireSourceNode() {
	  if (hasRequiredSourceNode) return sourceNode;
	  hasRequiredSourceNode = 1;
	  /*
	   * Copyright 2011 Mozilla Foundation and contributors
	   * Licensed under the New BSD license. See LICENSE or:
	   * http://opensource.org/licenses/BSD-3-Clause
	   */

	  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	  var util = requireUtil();

	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;

	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;

	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";

	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }

	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function () {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;
	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1,
	      lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });
	    return node;
	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
	        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
	      }
	    }
	  };

	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    } else {
	      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
	    }
	    return this;
	  };

	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length - 1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    } else {
	      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
	    }
	    return this;
	  };

	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      } else {
	        if (chunk !== '') {
	          aFn(chunk, {
	            source: this.source,
	            line: this.line,
	            column: this.column,
	            name: this.name
	          });
	        }
	      }
	    }
	  };

	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len - 1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };

	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    } else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    } else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };

	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }
	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };

	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null && original.line !== null && original.column !== null) {
	        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	    return {
	      code: generated.code,
	      map: map
	    };
	  };
	  sourceNode.SourceNode = SourceNode;
	  return sourceNode;
	}

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var hasRequiredSourceMap;
	function requireSourceMap() {
	  if (hasRequiredSourceMap) return sourceMap;
	  hasRequiredSourceMap = 1;
	  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
	  sourceMap.SourceNode = requireSourceNode().SourceNode;
	  return sourceMap;
	}

	/* global define */
	codeGen.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  var _utils = utils;
	  var SourceNode = undefined;
	  try {
	    /* istanbul ignore next */
	    if (typeof undefined !== 'function' || !undefined.amd) {
	      // We don't support this in AMD environments. For these environments, we asusme that
	      // they are running on the browser and thus have no need for the source-map library.
	      var SourceMap = requireSourceMap();
	      SourceNode = SourceMap.SourceNode;
	    }
	  } catch (err) {}
	  /* NOP */

	  /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	  if (!SourceNode) {
	    SourceNode = function (line, column, srcFile, chunks) {
	      this.src = '';
	      if (chunks) {
	        this.add(chunks);
	      }
	    };
	    /* istanbul ignore next */
	    SourceNode.prototype = {
	      add: function add(chunks) {
	        if (_utils.isArray(chunks)) {
	          chunks = chunks.join('');
	        }
	        this.src += chunks;
	      },
	      prepend: function prepend(chunks) {
	        if (_utils.isArray(chunks)) {
	          chunks = chunks.join('');
	        }
	        this.src = chunks + this.src;
	      },
	      toStringWithSourceMap: function toStringWithSourceMap() {
	        return {
	          code: this.toString()
	        };
	      },
	      toString: function toString() {
	        return this.src;
	      }
	    };
	  }
	  function castChunk(chunk, codeGen, loc) {
	    if (_utils.isArray(chunk)) {
	      var ret = [];
	      for (var i = 0, len = chunk.length; i < len; i++) {
	        ret.push(codeGen.wrap(chunk[i], loc));
	      }
	      return ret;
	    } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	      // Handle primitives that the SourceNode will throw up on
	      return chunk + '';
	    }
	    return chunk;
	  }
	  function CodeGen(srcFile) {
	    this.srcFile = srcFile;
	    this.source = [];
	  }
	  CodeGen.prototype = {
	    isEmpty: function isEmpty() {
	      return !this.source.length;
	    },
	    prepend: function prepend(source, loc) {
	      this.source.unshift(this.wrap(source, loc));
	    },
	    push: function push(source, loc) {
	      this.source.push(this.wrap(source, loc));
	    },
	    merge: function merge() {
	      var source = this.empty();
	      this.each(function (line) {
	        source.add(['  ', line, '\n']);
	      });
	      return source;
	    },
	    each: function each(iter) {
	      for (var i = 0, len = this.source.length; i < len; i++) {
	        iter(this.source[i]);
	      }
	    },
	    empty: function empty() {
	      var loc = this.currentLocation || {
	        start: {}
	      };
	      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	    },
	    wrap: function wrap(chunk) {
	      var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {
	        start: {}
	      } : arguments[1];
	      if (chunk instanceof SourceNode) {
	        return chunk;
	      }
	      chunk = castChunk(chunk, this, loc);
	      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	    },
	    functionCall: function functionCall(fn, type, params) {
	      params = this.generateList(params);
	      return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	    },
	    quotedString: function quotedString(str) {
	      return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	      .replace(/\u2029/g, '\\u2029') + '"';
	    },
	    objectLiteral: function objectLiteral(obj) {
	      var pairs = [];
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          var value = castChunk(obj[key], this);
	          if (value !== 'undefined') {
	            pairs.push([this.quotedString(key), ':', value]);
	          }
	        }
	      }
	      var ret = this.generateList(pairs);
	      ret.prepend('{');
	      ret.add('}');
	      return ret;
	    },
	    generateList: function generateList(entries) {
	      var ret = this.empty();
	      for (var i = 0, len = entries.length; i < len; i++) {
	        if (i) {
	          ret.add(',');
	        }
	        ret.add(castChunk(entries[i], this));
	      }
	      return ret;
	    },
	    generateArray: function generateArray(entries) {
	      var ret = this.generateList(entries);
	      ret.prepend('[');
	      ret.add(']');
	      return ret;
	    }
	  };
	  exports['default'] = CodeGen;
	  module.exports = exports['default'];
	})(codeGen, codeGen.exports);
	var codeGenExports = codeGen.exports;

	javascriptCompiler.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _base = base$1;
	  var _exception = exceptionExports;
	  var _exception2 = _interopRequireDefault(_exception);
	  var _utils = utils;
	  var _codeGen = codeGenExports;
	  var _codeGen2 = _interopRequireDefault(_codeGen);
	  function Literal(value) {
	    this.value = value;
	  }
	  function JavaScriptCompiler() {}
	  JavaScriptCompiler.prototype = {
	    // PUBLIC API: You can override these methods in a subclass to provide
	    // alternative compiled forms for name lookup and buffering semantics
	    nameLookup: function nameLookup(parent, name /* , type*/) {
	      if (name === 'constructor') {
	        return ['(', parent, '.propertyIsEnumerable(\'constructor\') ? ', parent, '.constructor : undefined', ')'];
	      }
	      if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	        return [parent, '.', name];
	      } else {
	        return [parent, '[', JSON.stringify(name), ']'];
	      }
	    },
	    depthedLookup: function depthedLookup(name) {
	      return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	    },
	    compilerInfo: function compilerInfo() {
	      var revision = _base.COMPILER_REVISION,
	        versions = _base.REVISION_CHANGES[revision];
	      return [revision, versions];
	    },
	    appendToBuffer: function appendToBuffer(source, location, explicit) {
	      // Force a source as this simplifies the merge logic.
	      if (!_utils.isArray(source)) {
	        source = [source];
	      }
	      source = this.source.wrap(source, location);
	      if (this.environment.isSimple) {
	        return ['return ', source, ';'];
	      } else if (explicit) {
	        // This is a case where the buffer operation occurs as a child of another
	        // construct, generally braces. We have to explicitly output these buffer
	        // operations to ensure that the emitted code goes in the correct location.
	        return ['buffer += ', source, ';'];
	      } else {
	        source.appendToBuffer = true;
	        return source;
	      }
	    },
	    initializeBuffer: function initializeBuffer() {
	      return this.quotedString('');
	    },
	    // END PUBLIC API

	    compile: function compile(environment, options, context, asObject) {
	      this.environment = environment;
	      this.options = options;
	      this.stringParams = this.options.stringParams;
	      this.trackIds = this.options.trackIds;
	      this.precompile = !asObject;
	      this.name = this.environment.name;
	      this.isChild = !!context;
	      this.context = context || {
	        decorators: [],
	        programs: [],
	        environments: []
	      };
	      this.preamble();
	      this.stackSlot = 0;
	      this.stackVars = [];
	      this.aliases = {};
	      this.registers = {
	        list: []
	      };
	      this.hashes = [];
	      this.compileStack = [];
	      this.inlineStack = [];
	      this.blockParams = [];
	      this.compileChildren(environment, options);
	      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	      this.useBlockParams = this.useBlockParams || environment.useBlockParams;
	      var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;
	      for (i = 0, l = opcodes.length; i < l; i++) {
	        opcode = opcodes[i];
	        this.source.currentLocation = opcode.loc;
	        firstLoc = firstLoc || opcode.loc;
	        this[opcode.opcode].apply(this, opcode.args);
	      }

	      // Flush any trailing content that might be pending.
	      this.source.currentLocation = firstLoc;
	      this.pushSource('');

	      /* istanbul ignore next */
	      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	        throw new _exception2['default']('Compile completed with content left on stack');
	      }
	      if (!this.decorators.isEmpty()) {
	        this.useDecorators = true;
	        this.decorators.prepend('var decorators = container.decorators;\n');
	        this.decorators.push('return fn;');
	        if (asObject) {
	          this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	        } else {
	          this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	          this.decorators.push('}\n');
	          this.decorators = this.decorators.merge();
	        }
	      } else {
	        this.decorators = undefined;
	      }
	      var fn = this.createFunctionContext(asObject);
	      if (!this.isChild) {
	        var ret = {
	          compiler: this.compilerInfo(),
	          main: fn
	        };
	        if (this.decorators) {
	          ret.main_d = this.decorators; // eslint-disable-line camelcase
	          ret.useDecorators = true;
	        }
	        var _context = this.context;
	        var programs = _context.programs;
	        var decorators = _context.decorators;
	        for (i = 0, l = programs.length; i < l; i++) {
	          if (programs[i]) {
	            ret[i] = programs[i];
	            if (decorators[i]) {
	              ret[i + '_d'] = decorators[i];
	              ret.useDecorators = true;
	            }
	          }
	        }
	        if (this.environment.usePartial) {
	          ret.usePartial = true;
	        }
	        if (this.options.data) {
	          ret.useData = true;
	        }
	        if (this.useDepths) {
	          ret.useDepths = true;
	        }
	        if (this.useBlockParams) {
	          ret.useBlockParams = true;
	        }
	        if (this.options.compat) {
	          ret.compat = true;
	        }
	        if (!asObject) {
	          ret.compiler = JSON.stringify(ret.compiler);
	          this.source.currentLocation = {
	            start: {
	              line: 1,
	              column: 0
	            }
	          };
	          ret = this.objectLiteral(ret);
	          if (options.srcName) {
	            ret = ret.toStringWithSourceMap({
	              file: options.destName
	            });
	            ret.map = ret.map && ret.map.toString();
	          } else {
	            ret = ret.toString();
	          }
	        } else {
	          ret.compilerOptions = this.options;
	        }
	        return ret;
	      } else {
	        return fn;
	      }
	    },
	    preamble: function preamble() {
	      // track the last context pushed into place to allow skipping the
	      // getContext opcode when it would be a noop
	      this.lastContext = 0;
	      this.source = new _codeGen2['default'](this.options.srcName);
	      this.decorators = new _codeGen2['default'](this.options.srcName);
	    },
	    createFunctionContext: function createFunctionContext(asObject) {
	      var varDeclarations = '';
	      var locals = this.stackVars.concat(this.registers.list);
	      if (locals.length > 0) {
	        varDeclarations += ', ' + locals.join(', ');
	      }

	      // Generate minimizer alias mappings
	      //
	      // When using true SourceNodes, this will update all references to the given alias
	      // as the source nodes are reused in situ. For the non-source node compilation mode,
	      // aliases will not be used, but this case is already being run on the client and
	      // we aren't concern about minimizing the template size.
	      var aliasCount = 0;
	      for (var alias in this.aliases) {
	        // eslint-disable-line guard-for-in
	        var node = this.aliases[alias];
	        if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	          varDeclarations += ', alias' + ++aliasCount + '=' + alias;
	          node.children[0] = 'alias' + aliasCount;
	        }
	      }
	      var params = ['container', 'depth0', 'helpers', 'partials', 'data'];
	      if (this.useBlockParams || this.useDepths) {
	        params.push('blockParams');
	      }
	      if (this.useDepths) {
	        params.push('depths');
	      }

	      // Perform a second pass over the output to merge content when possible
	      var source = this.mergeSource(varDeclarations);
	      if (asObject) {
	        params.push(source);
	        return Function.apply(this, params);
	      } else {
	        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	      }
	    },
	    mergeSource: function mergeSource(varDeclarations) {
	      var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	      this.source.each(function (line) {
	        if (line.appendToBuffer) {
	          if (bufferStart) {
	            line.prepend('  + ');
	          } else {
	            bufferStart = line;
	          }
	          bufferEnd = line;
	        } else {
	          if (bufferStart) {
	            if (!sourceSeen) {
	              appendFirst = true;
	            } else {
	              bufferStart.prepend('buffer += ');
	            }
	            bufferEnd.add(';');
	            bufferStart = bufferEnd = undefined;
	          }
	          sourceSeen = true;
	          if (!isSimple) {
	            appendOnly = false;
	          }
	        }
	      });
	      if (appendOnly) {
	        if (bufferStart) {
	          bufferStart.prepend('return ');
	          bufferEnd.add(';');
	        } else if (!sourceSeen) {
	          this.source.push('return "";');
	        }
	      } else {
	        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
	        if (bufferStart) {
	          bufferStart.prepend('return buffer + ');
	          bufferEnd.add(';');
	        } else {
	          this.source.push('return buffer;');
	        }
	      }
	      if (varDeclarations) {
	        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	      }
	      return this.source.merge();
	    },
	    // [blockValue]
	    //
	    // On stack, before: hash, inverse, program, value
	    // On stack, after: return value of blockHelperMissing
	    //
	    // The purpose of this opcode is to take a block of the form
	    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	    // replace it on the stack with the result of properly
	    // invoking blockHelperMissing.
	    blockValue: function blockValue(name) {
	      var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	      this.setupHelperArgs(name, 0, params);
	      var blockName = this.popStack();
	      params.splice(1, 0, blockName);
	      this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	    },
	    // [ambiguousBlockValue]
	    //
	    // On stack, before: hash, inverse, program, value
	    // Compiler value, before: lastHelper=value of last found helper, if any
	    // On stack, after, if no lastHelper: same as [blockValue]
	    // On stack, after, if lastHelper: value
	    ambiguousBlockValue: function ambiguousBlockValue() {
	      // We're being a bit cheeky and reusing the options value from the prior exec
	      var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	      this.setupHelperArgs('', 0, params, true);
	      this.flushInline();
	      var current = this.topStack();
	      params.splice(1, 0, current);
	      this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	    },
	    // [appendContent]
	    //
	    // On stack, before: ...
	    // On stack, after: ...
	    //
	    // Appends the string value of `content` to the current buffer
	    appendContent: function appendContent(content) {
	      if (this.pendingContent) {
	        content = this.pendingContent + content;
	      } else {
	        this.pendingLocation = this.source.currentLocation;
	      }
	      this.pendingContent = content;
	    },
	    // [append]
	    //
	    // On stack, before: value, ...
	    // On stack, after: ...
	    //
	    // Coerces `value` to a String and appends it to the current buffer.
	    //
	    // If `value` is truthy, or 0, it is coerced into a string and appended
	    // Otherwise, the empty string is appended
	    append: function append() {
	      if (this.isInline()) {
	        this.replaceStack(function (current) {
	          return [' != null ? ', current, ' : ""'];
	        });
	        this.pushSource(this.appendToBuffer(this.popStack()));
	      } else {
	        var local = this.popStack();
	        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	        if (this.environment.isSimple) {
	          this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	        }
	      }
	    },
	    // [appendEscaped]
	    //
	    // On stack, before: value, ...
	    // On stack, after: ...
	    //
	    // Escape `value` and append it to the buffer
	    appendEscaped: function appendEscaped() {
	      this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	    },
	    // [getContext]
	    //
	    // On stack, before: ...
	    // On stack, after: ...
	    // Compiler value, after: lastContext=depth
	    //
	    // Set the value of the `lastContext` compiler value to the depth
	    getContext: function getContext(depth) {
	      this.lastContext = depth;
	    },
	    // [pushContext]
	    //
	    // On stack, before: ...
	    // On stack, after: currentContext, ...
	    //
	    // Pushes the value of the current context onto the stack.
	    pushContext: function pushContext() {
	      this.pushStackLiteral(this.contextName(this.lastContext));
	    },
	    // [lookupOnContext]
	    //
	    // On stack, before: ...
	    // On stack, after: currentContext[name], ...
	    //
	    // Looks up the value of `name` on the current context and pushes
	    // it onto the stack.
	    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	      var i = 0;
	      if (!scoped && this.options.compat && !this.lastContext) {
	        // The depthed query is expected to handle the undefined logic for the root level that
	        // is implemented below, so we evaluate that directly in compat mode
	        this.push(this.depthedLookup(parts[i++]));
	      } else {
	        this.pushContext();
	      }
	      this.resolvePath('context', parts, i, falsy, strict);
	    },
	    // [lookupBlockParam]
	    //
	    // On stack, before: ...
	    // On stack, after: blockParam[name], ...
	    //
	    // Looks up the value of `parts` on the given block param and pushes
	    // it onto the stack.
	    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	      this.useBlockParams = true;
	      this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	      this.resolvePath('context', parts, 1);
	    },
	    // [lookupData]
	    //
	    // On stack, before: ...
	    // On stack, after: data, ...
	    //
	    // Push the data lookup operator
	    lookupData: function lookupData(depth, parts, strict) {
	      if (!depth) {
	        this.pushStackLiteral('data');
	      } else {
	        this.pushStackLiteral('container.data(data, ' + depth + ')');
	      }
	      this.resolvePath('data', parts, 0, true, strict);
	    },
	    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	      // istanbul ignore next

	      var _this = this;
	      if (this.options.strict || this.options.assumeObjects) {
	        this.push(strictLookup(this.options.strict && strict, this, parts, type));
	        return;
	      }
	      var len = parts.length;
	      for (; i < len; i++) {
	        /* eslint-disable no-loop-func */
	        this.replaceStack(function (current) {
	          var lookup = _this.nameLookup(current, parts[i], type);
	          // We want to ensure that zero and false are handled properly if the context (falsy flag)
	          // needs to have the special handling for these values.
	          if (!falsy) {
	            return [' != null ? ', lookup, ' : ', current];
	          } else {
	            // Otherwise we can use generic falsy handling
	            return [' && ', lookup];
	          }
	        });
	        /* eslint-enable no-loop-func */
	      }
	    },
	    // [resolvePossibleLambda]
	    //
	    // On stack, before: value, ...
	    // On stack, after: resolved value, ...
	    //
	    // If the `value` is a lambda, replace it on the stack by
	    // the return value of the lambda
	    resolvePossibleLambda: function resolvePossibleLambda() {
	      this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	    },
	    // [pushStringParam]
	    //
	    // On stack, before: ...
	    // On stack, after: string, currentContext, ...
	    //
	    // This opcode is designed for use in string mode, which
	    // provides the string value of a parameter along with its
	    // depth rather than resolving it immediately.
	    pushStringParam: function pushStringParam(string, type) {
	      this.pushContext();
	      this.pushString(type);

	      // If it's a subexpression, the string result
	      // will be pushed after this opcode.
	      if (type !== 'SubExpression') {
	        if (typeof string === 'string') {
	          this.pushString(string);
	        } else {
	          this.pushStackLiteral(string);
	        }
	      }
	    },
	    emptyHash: function emptyHash(omitEmpty) {
	      if (this.trackIds) {
	        this.push('{}'); // hashIds
	      }
	      if (this.stringParams) {
	        this.push('{}'); // hashContexts
	        this.push('{}'); // hashTypes
	      }
	      this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	    },
	    pushHash: function pushHash() {
	      if (this.hash) {
	        this.hashes.push(this.hash);
	      }
	      this.hash = {
	        values: [],
	        types: [],
	        contexts: [],
	        ids: []
	      };
	    },
	    popHash: function popHash() {
	      var hash = this.hash;
	      this.hash = this.hashes.pop();
	      if (this.trackIds) {
	        this.push(this.objectLiteral(hash.ids));
	      }
	      if (this.stringParams) {
	        this.push(this.objectLiteral(hash.contexts));
	        this.push(this.objectLiteral(hash.types));
	      }
	      this.push(this.objectLiteral(hash.values));
	    },
	    // [pushString]
	    //
	    // On stack, before: ...
	    // On stack, after: quotedString(string), ...
	    //
	    // Push a quoted version of `string` onto the stack
	    pushString: function pushString(string) {
	      this.pushStackLiteral(this.quotedString(string));
	    },
	    // [pushLiteral]
	    //
	    // On stack, before: ...
	    // On stack, after: value, ...
	    //
	    // Pushes a value onto the stack. This operation prevents
	    // the compiler from creating a temporary variable to hold
	    // it.
	    pushLiteral: function pushLiteral(value) {
	      this.pushStackLiteral(value);
	    },
	    // [pushProgram]
	    //
	    // On stack, before: ...
	    // On stack, after: program(guid), ...
	    //
	    // Push a program expression onto the stack. This takes
	    // a compile-time guid and converts it into a runtime-accessible
	    // expression.
	    pushProgram: function pushProgram(guid) {
	      if (guid != null) {
	        this.pushStackLiteral(this.programExpression(guid));
	      } else {
	        this.pushStackLiteral(null);
	      }
	    },
	    // [registerDecorator]
	    //
	    // On stack, before: hash, program, params..., ...
	    // On stack, after: ...
	    //
	    // Pops off the decorator's parameters, invokes the decorator,
	    // and inserts the decorator into the decorators list.
	    registerDecorator: function registerDecorator(paramSize, name) {
	      var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);
	      this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	    },
	    // [invokeHelper]
	    //
	    // On stack, before: hash, inverse, program, params..., ...
	    // On stack, after: result of helper invocation
	    //
	    // Pops off the helper's parameters, invokes the helper,
	    // and pushes the helper's return value onto the stack.
	    //
	    // If the helper is not found, `helperMissing` is called.
	    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	      var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name),
	        simple = isSimple ? [helper.name, ' || '] : '';
	      var lookup = ['('].concat(simple, nonHelper);
	      if (!this.options.strict) {
	        lookup.push(' || ', this.aliasable('helpers.helperMissing'));
	      }
	      lookup.push(')');
	      this.push(this.source.functionCall(lookup, 'call', helper.callParams));
	    },
	    // [invokeKnownHelper]
	    //
	    // On stack, before: hash, inverse, program, params..., ...
	    // On stack, after: result of helper invocation
	    //
	    // This operation is used when the helper is known to exist,
	    // so a `helperMissing` fallback is not required.
	    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	      var helper = this.setupHelper(paramSize, name);
	      this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	    },
	    // [invokeAmbiguous]
	    //
	    // On stack, before: hash, inverse, program, params..., ...
	    // On stack, after: result of disambiguation
	    //
	    // This operation is used when an expression like `{{foo}}`
	    // is provided, but we don't know at compile-time whether it
	    // is a helper or a path.
	    //
	    // This operation emits more code than the other options,
	    // and can be avoided by passing the `knownHelpers` and
	    // `knownHelpersOnly` flags at compile-time.
	    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	      this.useRegister('helper');
	      var nonHelper = this.popStack();
	      this.emptyHash();
	      var helper = this.setupHelper(0, name, helperCall);
	      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
	      var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	      if (!this.options.strict) {
	        lookup[0] = '(helper = ';
	        lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
	      }
	      this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	    },
	    // [invokePartial]
	    //
	    // On stack, before: context, ...
	    // On stack after: result of partial invocation
	    //
	    // This operation pops off a context, invokes a partial with that context,
	    // and pushes the result of the invocation back.
	    invokePartial: function invokePartial(isDynamic, name, indent) {
	      var params = [],
	        options = this.setupParams(name, 1, params);
	      if (isDynamic) {
	        name = this.popStack();
	        delete options.name;
	      }
	      if (indent) {
	        options.indent = JSON.stringify(indent);
	      }
	      options.helpers = 'helpers';
	      options.partials = 'partials';
	      options.decorators = 'container.decorators';
	      if (!isDynamic) {
	        params.unshift(this.nameLookup('partials', name, 'partial'));
	      } else {
	        params.unshift(name);
	      }
	      if (this.options.compat) {
	        options.depths = 'depths';
	      }
	      options = this.objectLiteral(options);
	      params.push(options);
	      this.push(this.source.functionCall('container.invokePartial', '', params));
	    },
	    // [assignToHash]
	    //
	    // On stack, before: value, ..., hash, ...
	    // On stack, after: ..., hash, ...
	    //
	    // Pops a value off the stack and assigns it to the current hash
	    assignToHash: function assignToHash(key) {
	      var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;
	      if (this.trackIds) {
	        id = this.popStack();
	      }
	      if (this.stringParams) {
	        type = this.popStack();
	        context = this.popStack();
	      }
	      var hash = this.hash;
	      if (context) {
	        hash.contexts[key] = context;
	      }
	      if (type) {
	        hash.types[key] = type;
	      }
	      if (id) {
	        hash.ids[key] = id;
	      }
	      hash.values[key] = value;
	    },
	    pushId: function pushId(type, name, child) {
	      if (type === 'BlockParam') {
	        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	      } else if (type === 'PathExpression') {
	        this.pushString(name);
	      } else if (type === 'SubExpression') {
	        this.pushStackLiteral('true');
	      } else {
	        this.pushStackLiteral('null');
	      }
	    },
	    // HELPERS

	    compiler: JavaScriptCompiler,
	    compileChildren: function compileChildren(environment, options) {
	      var children = environment.children,
	        child = undefined,
	        compiler = undefined;
	      for (var i = 0, l = children.length; i < l; i++) {
	        child = children[i];
	        compiler = new this.compiler(); // eslint-disable-line new-cap

	        var existing = this.matchExistingProgram(child);
	        if (existing == null) {
	          this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	          var index = this.context.programs.length;
	          child.index = index;
	          child.name = 'program' + index;
	          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	          this.context.decorators[index] = compiler.decorators;
	          this.context.environments[index] = child;
	          this.useDepths = this.useDepths || compiler.useDepths;
	          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	          child.useDepths = this.useDepths;
	          child.useBlockParams = this.useBlockParams;
	        } else {
	          child.index = existing.index;
	          child.name = 'program' + existing.index;
	          this.useDepths = this.useDepths || existing.useDepths;
	          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
	        }
	      }
	    },
	    matchExistingProgram: function matchExistingProgram(child) {
	      for (var i = 0, len = this.context.environments.length; i < len; i++) {
	        var environment = this.context.environments[i];
	        if (environment && environment.equals(child)) {
	          return environment;
	        }
	      }
	    },
	    programExpression: function programExpression(guid) {
	      var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];
	      if (this.useBlockParams || this.useDepths) {
	        programParams.push('blockParams');
	      }
	      if (this.useDepths) {
	        programParams.push('depths');
	      }
	      return 'container.program(' + programParams.join(', ') + ')';
	    },
	    useRegister: function useRegister(name) {
	      if (!this.registers[name]) {
	        this.registers[name] = true;
	        this.registers.list.push(name);
	      }
	    },
	    push: function push(expr) {
	      if (!(expr instanceof Literal)) {
	        expr = this.source.wrap(expr);
	      }
	      this.inlineStack.push(expr);
	      return expr;
	    },
	    pushStackLiteral: function pushStackLiteral(item) {
	      this.push(new Literal(item));
	    },
	    pushSource: function pushSource(source) {
	      if (this.pendingContent) {
	        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	        this.pendingContent = undefined;
	      }
	      if (source) {
	        this.source.push(source);
	      }
	    },
	    replaceStack: function replaceStack(callback) {
	      var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	      /* istanbul ignore next */
	      if (!this.isInline()) {
	        throw new _exception2['default']('replaceStack on non-inline');
	      }

	      // We want to merge the inline statement into the replacement statement via ','
	      var top = this.popStack(true);
	      if (top instanceof Literal) {
	        // Literals do not need to be inlined
	        stack = [top.value];
	        prefix = ['(', stack];
	        usedLiteral = true;
	      } else {
	        // Get or create the current stack name for use by the inline
	        createdStack = true;
	        var _name = this.incrStack();
	        prefix = ['((', this.push(_name), ' = ', top, ')'];
	        stack = this.topStack();
	      }
	      var item = callback.call(this, stack);
	      if (!usedLiteral) {
	        this.popStack();
	      }
	      if (createdStack) {
	        this.stackSlot--;
	      }
	      this.push(prefix.concat(item, ')'));
	    },
	    incrStack: function incrStack() {
	      this.stackSlot++;
	      if (this.stackSlot > this.stackVars.length) {
	        this.stackVars.push('stack' + this.stackSlot);
	      }
	      return this.topStackName();
	    },
	    topStackName: function topStackName() {
	      return 'stack' + this.stackSlot;
	    },
	    flushInline: function flushInline() {
	      var inlineStack = this.inlineStack;
	      this.inlineStack = [];
	      for (var i = 0, len = inlineStack.length; i < len; i++) {
	        var entry = inlineStack[i];
	        /* istanbul ignore if */
	        if (entry instanceof Literal) {
	          this.compileStack.push(entry);
	        } else {
	          var stack = this.incrStack();
	          this.pushSource([stack, ' = ', entry, ';']);
	          this.compileStack.push(stack);
	        }
	      }
	    },
	    isInline: function isInline() {
	      return this.inlineStack.length;
	    },
	    popStack: function popStack(wrapped) {
	      var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();
	      if (!wrapped && item instanceof Literal) {
	        return item.value;
	      } else {
	        if (!inline) {
	          /* istanbul ignore next */
	          if (!this.stackSlot) {
	            throw new _exception2['default']('Invalid stack pop');
	          }
	          this.stackSlot--;
	        }
	        return item;
	      }
	    },
	    topStack: function topStack() {
	      var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	      /* istanbul ignore if */
	      if (item instanceof Literal) {
	        return item.value;
	      } else {
	        return item;
	      }
	    },
	    contextName: function contextName(context) {
	      if (this.useDepths && context) {
	        return 'depths[' + context + ']';
	      } else {
	        return 'depth' + context;
	      }
	    },
	    quotedString: function quotedString(str) {
	      return this.source.quotedString(str);
	    },
	    objectLiteral: function objectLiteral(obj) {
	      return this.source.objectLiteral(obj);
	    },
	    aliasable: function aliasable(name) {
	      var ret = this.aliases[name];
	      if (ret) {
	        ret.referenceCount++;
	        return ret;
	      }
	      ret = this.aliases[name] = this.source.wrap(name);
	      ret.aliasable = true;
	      ret.referenceCount = 1;
	      return ret;
	    },
	    setupHelper: function setupHelper(paramSize, name, blockHelper) {
	      var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	      var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');
	      return {
	        params: params,
	        paramsInit: paramsInit,
	        name: foundHelper,
	        callParams: [callContext].concat(params)
	      };
	    },
	    setupParams: function setupParams(helper, paramSize, params) {
	      var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;
	      if (objectArgs) {
	        params = [];
	      }
	      options.name = this.quotedString(helper);
	      options.hash = this.popStack();
	      if (this.trackIds) {
	        options.hashIds = this.popStack();
	      }
	      if (this.stringParams) {
	        options.hashTypes = this.popStack();
	        options.hashContexts = this.popStack();
	      }
	      var inverse = this.popStack(),
	        program = this.popStack();

	      // Avoid setting fn and inverse if neither are set. This allows
	      // helpers to do a check for `if (options.fn)`
	      if (program || inverse) {
	        options.fn = program || 'container.noop';
	        options.inverse = inverse || 'container.noop';
	      }

	      // The parameters go on to the stack in order (making sure that they are evaluated in order)
	      // so we need to pop them off the stack in reverse order
	      var i = paramSize;
	      while (i--) {
	        param = this.popStack();
	        params[i] = param;
	        if (this.trackIds) {
	          ids[i] = this.popStack();
	        }
	        if (this.stringParams) {
	          types[i] = this.popStack();
	          contexts[i] = this.popStack();
	        }
	      }
	      if (objectArgs) {
	        options.args = this.source.generateArray(params);
	      }
	      if (this.trackIds) {
	        options.ids = this.source.generateArray(ids);
	      }
	      if (this.stringParams) {
	        options.types = this.source.generateArray(types);
	        options.contexts = this.source.generateArray(contexts);
	      }
	      if (this.options.data) {
	        options.data = 'data';
	      }
	      if (this.useBlockParams) {
	        options.blockParams = 'blockParams';
	      }
	      return options;
	    },
	    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	      var options = this.setupParams(helper, paramSize, params);
	      options = this.objectLiteral(options);
	      if (useRegister) {
	        this.useRegister('options');
	        params.push('options');
	        return ['options=', options];
	      } else if (params) {
	        params.push(options);
	        return '';
	      } else {
	        return options;
	      }
	    }
	  };
	  (function () {
	    var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
	    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
	    for (var i = 0, l = reservedWords.length; i < l; i++) {
	      compilerWords[reservedWords[i]] = true;
	    }
	  })();
	  JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	  };
	  function strictLookup(requireTerminal, compiler, parts, type) {
	    var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	    if (requireTerminal) {
	      len--;
	    }
	    for (; i < len; i++) {
	      stack = compiler.nameLookup(stack, parts[i], type);
	    }
	    if (requireTerminal) {
	      return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
	    } else {
	      return stack;
	    }
	  }
	  exports['default'] = JavaScriptCompiler;
	  module.exports = exports['default'];
	})(javascriptCompiler, javascriptCompiler.exports);
	var javascriptCompilerExports = javascriptCompiler.exports;

	handlebars$1.exports;
	(function (module, exports) {

	  exports.__esModule = true;
	  // istanbul ignore next

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      'default': obj
	    };
	  }
	  var _handlebarsRuntime = handlebars_runtimeExports;
	  var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

	  // Compiler imports

	  var _handlebarsCompilerAst = astExports;
	  var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
	  var _handlebarsCompilerBase = base;
	  var _handlebarsCompilerCompiler = compiler;
	  var _handlebarsCompilerJavascriptCompiler = javascriptCompilerExports;
	  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
	  var _handlebarsCompilerVisitor = visitorExports;
	  var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
	  var _handlebarsNoConflict = noConflictExports;
	  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
	  var _create = _handlebarsRuntime2['default'].create;
	  function create() {
	    var hb = _create();
	    hb.compile = function (input, options) {
	      return _handlebarsCompilerCompiler.compile(input, options, hb);
	    };
	    hb.precompile = function (input, options) {
	      return _handlebarsCompilerCompiler.precompile(input, options, hb);
	    };
	    hb.AST = _handlebarsCompilerAst2['default'];
	    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
	    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	    hb.Parser = _handlebarsCompilerBase.parser;
	    hb.parse = _handlebarsCompilerBase.parse;
	    return hb;
	  }
	  var inst = create();
	  inst.create = create;
	  _handlebarsNoConflict2['default'](inst);
	  inst.Visitor = _handlebarsCompilerVisitor2['default'];
	  inst['default'] = inst;
	  exports['default'] = inst;
	  module.exports = exports['default'];
	})(handlebars$1, handlebars$1.exports);
	var handlebarsExports = handlebars$1.exports;

	var printer$1 = {};

	/* eslint-disable new-cap */
	printer$1.__esModule = true;
	printer$1.print = print;
	printer$1.PrintVisitor = PrintVisitor;
	// istanbul ignore next

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}
	var _visitor = visitorExports;
	var _visitor2 = _interopRequireDefault(_visitor);
	function print(ast) {
	  return new PrintVisitor().accept(ast);
	}
	function PrintVisitor() {
	  this.padding = 0;
	}
	PrintVisitor.prototype = new _visitor2['default']();
	PrintVisitor.prototype.pad = function (string) {
	  var out = '';
	  for (var i = 0, l = this.padding; i < l; i++) {
	    out += '  ';
	  }
	  out += string + '\n';
	  return out;
	};
	PrintVisitor.prototype.Program = function (program) {
	  var out = '',
	    body = program.body,
	    i = undefined,
	    l = undefined;
	  if (program.blockParams) {
	    var blockParams = 'BLOCK PARAMS: [';
	    for (i = 0, l = program.blockParams.length; i < l; i++) {
	      blockParams += ' ' + program.blockParams[i];
	    }
	    blockParams += ' ]';
	    out += this.pad(blockParams);
	  }
	  for (i = 0, l = body.length; i < l; i++) {
	    out += this.accept(body[i]);
	  }
	  this.padding--;
	  return out;
	};
	PrintVisitor.prototype.MustacheStatement = function (mustache) {
	  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
	};
	PrintVisitor.prototype.Decorator = function (mustache) {
	  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
	};
	PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
	  var out = '';
	  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
	  this.padding++;
	  out += this.pad(this.SubExpression(block));
	  if (block.program) {
	    out += this.pad('PROGRAM:');
	    this.padding++;
	    out += this.accept(block.program);
	    this.padding--;
	  }
	  if (block.inverse) {
	    if (block.program) {
	      this.padding++;
	    }
	    out += this.pad('{{^}}');
	    this.padding++;
	    out += this.accept(block.inverse);
	    this.padding--;
	    if (block.program) {
	      this.padding--;
	    }
	  }
	  this.padding--;
	  return out;
	};
	PrintVisitor.prototype.PartialStatement = function (partial) {
	  var content = 'PARTIAL:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }
	  return this.pad('{{> ' + content + ' }}');
	};
	PrintVisitor.prototype.PartialBlockStatement = function (partial) {
	  var content = 'PARTIAL BLOCK:' + partial.name.original;
	  if (partial.params[0]) {
	    content += ' ' + this.accept(partial.params[0]);
	  }
	  if (partial.hash) {
	    content += ' ' + this.accept(partial.hash);
	  }
	  content += ' ' + this.pad('PROGRAM:');
	  this.padding++;
	  content += this.accept(partial.program);
	  this.padding--;
	  return this.pad('{{> ' + content + ' }}');
	};
	PrintVisitor.prototype.ContentStatement = function (content) {
	  return this.pad("CONTENT[ '" + content.value + "' ]");
	};
	PrintVisitor.prototype.CommentStatement = function (comment) {
	  return this.pad("{{! '" + comment.value + "' }}");
	};
	PrintVisitor.prototype.SubExpression = function (sexpr) {
	  var params = sexpr.params,
	    paramStrings = [],
	    hash = undefined;
	  for (var i = 0, l = params.length; i < l; i++) {
	    paramStrings.push(this.accept(params[i]));
	  }
	  params = '[' + paramStrings.join(', ') + ']';
	  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';
	  return this.accept(sexpr.path) + ' ' + params + hash;
	};
	PrintVisitor.prototype.PathExpression = function (id) {
	  var path = id.parts.join('/');
	  return (id.data ? '@' : '') + 'PATH:' + path;
	};
	PrintVisitor.prototype.StringLiteral = function (string) {
	  return '"' + string.value + '"';
	};
	PrintVisitor.prototype.NumberLiteral = function (number) {
	  return 'NUMBER{' + number.value + '}';
	};
	PrintVisitor.prototype.BooleanLiteral = function (bool) {
	  return 'BOOLEAN{' + bool.value + '}';
	};
	PrintVisitor.prototype.UndefinedLiteral = function () {
	  return 'UNDEFINED';
	};
	PrintVisitor.prototype.NullLiteral = function () {
	  return 'NULL';
	};
	PrintVisitor.prototype.Hash = function (hash) {
	  var pairs = hash.pairs,
	    joinedPairs = [];
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    joinedPairs.push(this.accept(pairs[i]));
	  }
	  return 'HASH{' + joinedPairs.join(', ') + '}';
	};
	PrintVisitor.prototype.HashPair = function (pair) {
	  return pair.key + '=' + this.accept(pair.value);
	};

	// USAGE:
	// var handlebars = require('handlebars');
	/* eslint-disable no-var */

	// var local = handlebars.create();

	var handlebars = handlebarsExports['default'];
	var printer = printer$1;
	handlebars.PrintVisitor = printer.PrintVisitor;
	handlebars.print = printer.print;
	var lib = handlebars;

	// Publish a Node.js require() handler for .handlebars and .hbs files
	function extension(module, filename) {
	  var fs = require$$2__default["default"];
	  var templateString = fs.readFileSync(filename, 'utf8');
	  module.exports = handlebars.compile(templateString);
	}
	/* istanbul ignore else */
	if (typeof commonjsRequire !== 'undefined' && commonjsRequire.extensions) {
	  commonjsRequire.extensions['.handlebars'] = extension;
	  commonjsRequire.extensions['.hbs'] = extension;
	}
	var Handlebars = /*@__PURE__*/getDefaultExportFromCjs(lib);

	/**
	 * Quantity Adjuster Scripts
	 * -----------------------------------------------------------------------------
	 * Handles any events associated with the quantity adjuster component
	 *
	 *  [data-quantity-adjuster]
	 *    [data-increment]
	 *    input[type="number"]
	 *    [data-decrement]
	 *
	 */

	const selectors$f = {
	  adjuster: '[data-quantity-adjuster]',
	  increment: '[data-increment]',
	  decrement: '[data-decrement]',
	  input: 'input[type="number"]'
	};
	const dataKey$1 = 'quantity-adjuster';
	class QuantityAdjuster {
	  /**
	   * Quantity Adjuster Constructor
	   *
	   * @param {HTMLElement | jQuery} el - element, either matching selectors.adjuster or a child element
	   */
	  constructor(el) {
	    this.name = 'quantityAdjuster';
	    this.namespace = `.${this.name}`;
	    this.$el = $$2(el).is(selectors$f.adjuster) ? $$2(el) : $$2(el).parents(selectors$f.adjuster);
	    if (!this.$el) {
	      console.warn(`[${this.name}] - Element required to initialize`);
	      return;
	    }
	    this.$increment = $$2(selectors$f.increment, this.$el);
	    this.$decrement = $$2(selectors$f.decrement, this.$el);
	    this.$input = $$2(selectors$f.input, this.$el);
	    this.$increment.on('click', this.onIncrementClick.bind(this));
	    this.$decrement.on('click', this.onDecrementClick.bind(this));
	    this.$input.on('change', this.onInputChange.bind(this));
	    this._addMutationObserver(this.$input.get(0));
	    this._updateDisabledState();
	  }
	  _addMutationObserver(el) {
	    if (!el) return;
	    const config = {
	      attributes: true
	    };
	    const observer = new MutationObserver(mutations => {
	      mutations.forEach(mutation => {
	        if (mutation.type === 'attributes') {
	          if (mutation.attributeName === 'max' || mutation.attributeName === 'min') {
	            this.onMinMaxAttributeChange();
	          } else if (mutation.attributeName === 'disabled') {
	            this.onDisabledAttributeChange();
	          }
	        }
	      });
	    });
	    observer.observe(el, config);
	  }
	  _updateDisabledState() {
	    const val = parseInt(this.$input.val());
	    if (this.$input.is(':disabled')) {
	      this.$increment.prop('disabled', true);
	      this.$decrement.prop('disabled', true);
	      return;
	    }
	    if (val === this.getMax() && val === this.getMin()) {
	      this.$increment.prop('disabled', true);
	      this.$decrement.prop('disabled', true);
	    } else if (val >= this.getMax()) {
	      this.$increment.prop('disabled', true);
	      this.$decrement.prop('disabled', false);
	    } else if (val <= this.getMin()) {
	      this.$increment.prop('disabled', false);
	      this.$decrement.prop('disabled', true);
	    } else {
	      this.$increment.prop('disabled', false);
	      this.$decrement.prop('disabled', false);
	    }
	  }
	  _changeValue(amount) {
	    if (this.$input.is(':disabled') || typeof amount === 'undefined') return;
	    amount = parseInt(amount);
	    const val = parseInt(this.$input.val());
	    const newVal = val + amount;

	    // Don't change if the value is the same or invalid
	    if (newVal === val || newVal > this.getMax() || newVal < this.getMin()) return;
	    this.$input.val(newVal);
	    this.$input.trigger('change');
	  }
	  _clampInputVal() {
	    const currVal = parseInt(this.$input.val());
	    const max = this.getMax();
	    const min = this.getMin();
	    if (currVal > max) {
	      this.$input.val(max);
	    } else if (currVal < min) {
	      this.$input.val(min);
	    }
	  }
	  getMin() {
	    return parseInt(this.$input.attr('min')) || 0;
	  }
	  getMax() {
	    return parseInt(this.$input.attr('max')) || 999;
	  }
	  onDisabledAttributeChange() {
	    this._updateDisabledState();
	  }
	  onMinMaxAttributeChange() {
	    this._clampInputVal();
	    this._updateDisabledState();
	  }
	  onInputChange() {
	    this._clampInputVal();
	    this._updateDisabledState();
	  }
	  onIncrementClick(e) {
	    e.preventDefault();
	    this._changeValue(1);
	  }
	  onDecrementClick(e) {
	    e.preventDefault();
	    this._changeValue(-1);
	  }
	  static ensure(el) {
	    let $el = $$2(el);
	    if (!$el.is(selectors$f.adjuster)) {
	      $el = $el.parents(selectors$f.adjuster);
	    }
	    let data = $el.data(dataKey$1);
	    if (!data) {
	      $el.data(dataKey$1, data = new QuantityAdjuster($el));
	    }
	    return data;
	  }
	  static refresh($container) {
	    $$2(selectors$f.adjuster, $container).each((i, el) => {
	      QuantityAdjuster.ensure(el);
	    });
	  }
	  static getDataKey() {
	    return dataKey$1;
	  }
	}
	const shopifyEvents = ['shopify:section:unload', 'shopify:section:select', 'shopify:section:deselect', 'shopify:section:reorder', 'shopify:block:select', 'shopify:block:deselect'];
	$$2(document).on(shopifyEvents.join(' '), QuantityAdjuster.refresh);
	QuantityAdjuster.refresh();

	$$2(window);
	$$2(document.body);

	const $document$3 = $$2(document);
	const $body$4 = $$2(document.body);
	const selectors$e = {
	  close: '[data-drawer-close]'
	};
	const classes$a = {
	  drawer: 'drawer',
	  visible: 'is-visible',
	  backdrop: 'drawer-backdrop',
	  backdropVisible: 'is-visible',
	  bodyDrawerOpen: 'drawer-open'
	};
	class Drawer {
	  /**
	   * Drawer constructor
	   *
	   * @param {HTMLElement | $} el - The drawer element
	   * @param {Object} options
	   */
	  constructor(el, options) {
	    this.name = 'drawer';
	    this.namespace = `.${this.name}`;
	    this.$el = $$2(el);
	    this.stateIsOpen = false;
	    this.transitionEndEvent = whichTransitionEnd();
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    if (this.$el === undefined || !this.$el.hasClass(classes$a.drawer)) {
	      console.warn(`[${this.name}] - Element with class ${classes$a.drawer} required to initialize.`);
	      return;
	    }
	    const defaults = {
	      closeSelector: selectors$e.close,
	      backdrop: true
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    this.events = {
	      HIDE: 'hide' + this.namespace,
	      HIDDEN: 'hidden' + this.namespace,
	      SHOW: 'show' + this.namespace,
	      SHOWN: 'shown' + this.namespace
	    };
	    this.$el.on('click', this.settings.closeSelector, this.onCloseClick.bind(this));
	  }
	  addBackdrop(callback) {
	    const cb = callback || $$2.noop;
	    if (this.stateIsOpen) {
	      this.$backdrop = $$2(document.createElement('div'));
	      this.$backdrop.addClass(classes$a.backdrop).appendTo($body$4);
	      this.$backdrop.one(this.transitionEndEvent, cb);
	      this.$backdrop.one('click', this.hide.bind(this));

	      // debug this...
	      setTimeout(() => {
	        $body$4.addClass(classes$a.bodyDrawerOpen);
	        this.$backdrop.addClass(classes$a.backdropVisible);
	      }, 10);
	    } else {
	      cb();
	    }
	  }
	  removeBackdrop(callback) {
	    const cb = callback || $$2.noop;
	    if (this.$backdrop) {
	      this.$backdrop.one(this.transitionEndEvent, () => {
	        this.$backdrop && this.$backdrop.remove();
	        this.$backdrop = null;
	        cb();
	      });
	      setTimeout(() => {
	        this.$backdrop.removeClass(classes$a.backdropVisible);
	        $body$4.removeClass(classes$a.bodyDrawerOpen);
	      }, 10);
	    } else {
	      cb();
	    }
	  }

	  /**
	   * Called after the closing animation has run
	   */
	  onHidden() {
	    this.stateIsOpen = false;
	    const e = $$2.Event(this.events.HIDDEN);
	    this.$el.trigger(e);
	  }

	  /**
	   * Called after the opening animation has run
	   */
	  onShown() {
	    const e = $$2.Event(this.events.SHOWN);
	    this.$el.trigger(e);
	  }
	  hide() {
	    const e = $$2.Event(this.events.HIDE);
	    this.$el.trigger(e);
	    if (!this.stateIsOpen) return;
	    this.$el.removeClass(classes$a.visible);
	    if (this.settings.backdrop) {
	      this.removeBackdrop();
	    }
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onHidden.bind(this));
	    } else {
	      this.onHidden();
	    }
	  }
	  show() {
	    const e = $$2.Event(this.events.SHOW);
	    this.$el.trigger(e);
	    if (this.stateIsOpen) return;
	    this.stateIsOpen = true;
	    this.$el.addClass(classes$a.visible);
	    if (this.settings.backdrop) {
	      this.addBackdrop();
	    }
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onShown.bind(this));
	    } else {
	      this.onShown();
	    }
	  }
	  toggle() {
	    return this.stateIsOpen ? this.hide() : this.show();
	  }
	  onCloseClick(e) {
	    e.preventDefault();
	    this.hide();
	  }
	}

	// Data API
	$document$3.on('click.drawer', '[data-toggle="drawer"]', function (e) {
	  const $this = $$2(this);
	  const $target = $$2($this.attr('data-target'));
	  const options = $$2.extend($target.data(), $this.data());
	  let data = $this.data('drawer');
	  if ($this.is('a')) e.preventDefault();
	  if (!data) {
	    $this.data('drawer', data = new Drawer($target, options));
	    data.show();
	  } else {
	    data.toggle();
	  }
	});

	const classes$9 = {
	  open: 'is-open',
	  forcedOpen: 'is-forced-open'
	};
	class Dropdown {
	  constructor($trigger) {
	    this.$trigger = $trigger;
	    this.$el = $$2(this.$trigger.data('dropdown-trigger'));
	    this.blockId = this.$trigger.data('block').toString();
	  }
	  isOpen() {
	    return this.$el.hasClass(classes$9.open);
	  }
	  open() {
	    this.$el.addClass(classes$9.open);
	  }
	  close() {
	    this.$el.removeClass(classes$9.open);
	  }

	  /**
	   * Dropdown manager doesn't use the forced open class
	   * So we can use it in conjunction with the theme editor to ensure dropdowns are open while editing
	   */
	  forceOpen() {
	    this.$el.addClass(classes$9.forcedOpen);
	  }
	  forceClose() {
	    this.$el.removeClass(classes$9.forcedOpen);
	  }
	}

	const selectors$d = {
	  form: 'form',
	  formContents: '[data-form-contents]',
	  formMessage: '[data-form-message][data-message-success][data-message-fail]'
	};
	const classes$8 = {
	  showMessage: 'show-message'
	};
	class NewsletterForm {
	  /**
	   * NewsletterForm constructor
	   *
	   * @param {HTMLElement} el - Element used for scoping any element selection.  Can either be a containing element or the form element itself
	   * @param {Object} options
	   */
	  constructor(el, options) {
	    this.name = 'newsletterForm';
	    const defaults = {
	      setCookies: true // toggle setting of browser cookies
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    this.transitionEndEvent = whichTransitionEnd();
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    this.$el = $$2(el);
	    this.$form = this.$el.is(selectors$d.form) ? this.$el : this.$el.find(selectors$d.form);
	    this.timeout = null;
	    if (!this.$form.length) {
	      console.warn(`[${this.name}] - Form element required to initialize`);
	      return;
	    }
	    this.$formContents = $$2(selectors$d.formContents, this.$el);
	    this.$formMessage = $$2(selectors$d.formMessage, this.$el);

	    /**
	     * These are the cookies that we'll use to keep track of how much the user has interacted with the footer
	     */
	    this.cookies = {};
	    this.cookies.emailCollected = generateCookie('emailCollected');
	  }
	  emailCollected() {
	    return hasCookie(this.cookies.emailCollected.name);
	  }

	  /**
	   * Temporarily shows the form message
	   *
	   * @param {Boolean} reset - If set, will call this.reset
	   */
	  showMessageWithTimeout() {
	    let reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    this.$formContents.addClass(classes$8.showMessage);
	    window.clearTimeout(this.timeout);
	    this.timeout = setTimeout(() => {
	      if (reset) {
	        this.reset();
	      } else {
	        this.$formContents.removeClass(classes$8.showMessage);
	      }
	    }, 4000);
	  }

	  /**
	   * Resets everything to it's initial state.  Only call when form content isn't visible
	   */
	  reset() {
	    this.$form.find('input[type="email"]').val('');
	    this.$form.find('input[type="checkbox"]').prop('checked', false);
	    const cb = this.$formMessage.html.bind(this.$formMessage, '');
	    if (this.supportsCssTransitions) {
	      this.$formContents.one(this.transitionEndEvent, cb);
	    } else {
	      setTimeout(cb, getTransitionTimingDuration('base'));
	    }
	    this.$formContents.removeClass(classes$8.showMessage);
	  }
	  onSubscribeSuccess(response) {
	    const isSubscribed = response && response.data && response.data.is_subscribed;
	    const successMsg = this.$formMessage.data(isSubscribed ? 'message-already-subscribed' : 'message-success');
	    if (!isThemeEditor() && this.settings.setCookies) {
	      setCookie(this.cookies.emailCollected);
	    }
	    this.$formMessage.html(successMsg);

	    // Don't reset the form if they're already subscribed, they might want to just enter a different email
	    this.showMessageWithTimeout(!isSubscribed);
	  }
	  onSubmitFail(errors) {
	    this.$formMessage.html(Array.isArray(errors) ? errors.join('  ') : errors);
	    this.showMessageWithTimeout();
	  }
	  onSubscribeFail() {
	    this.$formMessage.html(this.$formMessage.data('message-fail'));
	    this.showMessageWithTimeout();
	  }
	}

	const $document$2 = $$2(document);
	const $body$3 = $$2(document.body);
	const selectors$c = {
	  close: '[data-overlay-close]',
	  searchInput: '[data-search-input]'
	};
	const classes$7 = {
	  overlay: 'overlay',
	  visible: 'is-visible',
	  bodyOverlayOpen: 'overlay-open'
	};
	class Overlay {
	  /**
	   * Overlay constructor
	   *
	   * @param {HTMLElement | $} el - The overlay element
	   * @param {Object} options
	   */
	  constructor(el, options) {
	    this.name = 'overlay';
	    this.namespace = `.${this.name}`;
	    this.$el = $$2(el);
	    this.stateIsOpen = false;
	    this.transitionEndEvent = whichTransitionEnd();
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    if (this.$el === undefined || !this.$el.hasClass(classes$7.overlay)) {
	      console.warn(`[${this.name}] - Element with class ${classes$7.overlay} required to initialize.`);
	      return;
	    }
	    const defaults = {
	      closeSelector: selectors$c.close
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    this.events = {
	      HIDE: 'hide' + this.namespace,
	      HIDDEN: 'hidden' + this.namespace,
	      SHOW: 'show' + this.namespace,
	      SHOWN: 'shown' + this.namespace,
	      FOCUS: 'focus' + this.namespace,
	      KEYDOWN_DISMISS: 'keydown.dismiss' + this.namespace
	    };
	    this.$el.on('click', this.settings.closeSelector, this.onCloseClick.bind(this));
	  }

	  /**
	   * Called after the closing animation has run
	   */
	  onHidden() {
	    $body$3.removeClass(classes$7.bodyOverlayOpen);
	    const e = $$2.Event(this.events.HIDDEN);
	    this.$el.trigger(e);
	  }

	  /**
	   * Called after the opening animation has run
	   */
	  onShown() {
	    this.enforceFocus();
	    const e = $$2.Event(this.events.SHOWN);
	    const $searchInput = $$2(selectors$c.searchInput, this.$el);
	    this.$el.trigger(e);
	    this.$el.trigger('focus');
	    if ($searchInput.length) {
	      $searchInput.trigger('focus');
	    }
	  }
	  hide() {
	    const e = $$2.Event(this.events.HIDE);
	    this.$el.trigger(e);
	    if (!this.stateIsOpen) return;
	    this.stateIsOpen = false;
	    this.updateEscapeHandler();
	    $document$2.off(this.events.FOCUS);
	    this.$el.removeClass(classes$7.visible);
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onHidden.bind(this));
	    } else {
	      this.onHidden();
	    }
	  }
	  show() {
	    const e = $$2.Event(this.events.SHOW);
	    this.$el.trigger(e);
	    if (this.stateIsOpen) return;
	    this.stateIsOpen = true;
	    this.updateEscapeHandler();
	    $body$3.addClass(classes$7.bodyOverlayOpen);
	    this.$el.addClass(classes$7.visible);
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onShown.bind(this));
	    } else {
	      this.onShown();
	    }
	  }
	  enforceFocus() {
	    $document$2.off(this.events.FOCUS);
	    $document$2.on(this.events.FOCUS, $$2.proxy(function (e) {
	      if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
	        this.$el.trigger('focus');
	      }
	    }, this));
	  }
	  updateEscapeHandler() {
	    if (this.stateIsOpen) {
	      this.$el.on(this.events.KEYDOWN_DISMISS, $$2.proxy(function (e) {
	        e.which === 27 && this.hide();
	      }, this));
	    } else {
	      this.$el.off(this.events.KEYDOWN_DISMISS);
	    }
	  }
	  toggle() {
	    return this.stateIsOpen ? this.hide() : this.show();
	  }
	  onCloseClick(e) {
	    e.preventDefault();
	    this.hide();
	  }
	}

	// Data API
	$document$2.on('click.overlay', '[data-toggle="overlay"]', function (e) {
	  const $this = $$2(this);
	  const $target = $$2($this.attr('data-target'));
	  const options = $$2.extend($target.data(), $this.data());
	  let data = $this.data('overlay');
	  if ($this.is('a')) e.preventDefault();
	  if (!data) {
	    $this.data('overlay', data = new Overlay($target, options));
	    data.show();
	  } else {
	    data.toggle();
	  }
	});

	const $document$1 = $$2(document);
	const selectors$b = {
	  close: '[data-slideup-close]'
	};
	const classes$6 = {
	  slideup: 'slideup',
	  visible: 'is-visible'
	};
	class Slideup {
	  /**
	   * Slideup constructor
	   *
	   * @param {HTMLElement | $} el - The slideup element
	   * @param {Object} options
	   */
	  constructor(el, options) {
	    this.name = 'slideup';
	    this.namespace = `.${this.name}`;
	    this.$el = $$2(el);
	    this.stateIsOpen = false;
	    this.transitionEndEvent = whichTransitionEnd();
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    if (this.$el === undefined || !this.$el.hasClass(classes$6.slideup)) {
	      console.warn(`[${this.name}] - Element with class ${classes$6.slideup} required to initialize.`);
	      return;
	    }
	    const defaults = {
	      closeSelector: selectors$b.close
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    this.events = {
	      HIDE: 'hide' + this.namespace,
	      HIDDEN: 'hidden' + this.namespace,
	      SHOW: 'show' + this.namespace,
	      SHOWN: 'shown' + this.namespace
	    };
	    this.$el.on('click', this.settings.closeSelector, this.onCloseClick.bind(this));
	  }

	  /**
	   * Called after the closing animation has run
	   */
	  onHidden() {
	    const e = $$2.Event(this.events.HIDDEN);
	    this.$el.trigger(e);
	  }

	  /**
	   * Called after the opening animation has run
	   */
	  onShown() {
	    const e = $$2.Event(this.events.SHOWN);
	    this.$el.trigger(e);
	  }
	  hide() {
	    const e = $$2.Event(this.events.HIDE);
	    this.$el.trigger(e);
	    if (!this.stateIsOpen) return;
	    this.stateIsOpen = false;
	    this.$el.removeClass(classes$6.visible);
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onHidden.bind(this));
	    } else {
	      this.onHidden();
	    }
	  }
	  show() {
	    const e = $$2.Event(this.events.SHOW);
	    this.$el.trigger(e);
	    if (this.stateIsOpen) return;
	    this.stateIsOpen = true;
	    this.$el.addClass(classes$6.visible);
	    if (this.supportsCssTransitions) {
	      this.$el.one(this.transitionEndEvent, this.onShown.bind(this));
	    } else {
	      this.onShown();
	    }
	  }
	  toggle() {
	    return this.stateIsOpen ? this.hide() : this.show();
	  }
	  onCloseClick(e) {
	    e.preventDefault();
	    this.hide();
	  }
	}
	$document$1.on('click.slideup', '[data-toggle="slideup"]', function (e) {
	  const $this = $$2(this);
	  const $target = $$2($this.attr('data-target'));
	  const options = $$2.extend($target.data(), $this.data());
	  let data = $this.data('slideup');
	  if ($this.is('a')) e.preventDefault();
	  if (!data) {
	    $this.data('slideup', data = new Slideup($target, options));
	    data.show();
	  } else {
	    data.toggle();
	  }
	});

	/**
	 * Slideup Alert
	 * ------------------------------------------------------------------------------
	 *
	 * Requires:
	 *  - snippets/slideup-template.liquid
	 *
	 * @namespace - slideupAlert
	*/

	const $body$2 = $$2(document.body);
	const selectors$a = {
	  template: 'script[data-slideup-template]'
	};
	class SlideupAlert {
	  /**
	   * Slideup Alert constructor
	   *
	   * @param {Object} options
	   * @param {String} options.title - Title text of the slideup
	   * @param {String} options.text - Body text of the slideup
	   * @param {Integer} options.timeoutDuration - How long to display the alert before closing automatically (in ms)
	   */
	  constructor(options) {
	    this.name = 'slideupAlert';
	    this.namespace = '.' + this.name;
	    if ($$2(selectors$a.template).length === 0) {
	      console.warn(`[${this.name}] - Handlebars template required to initialize`);
	      return;
	    }
	    const template = Handlebars.compile($$2(selectors$a.template).html());
	    const defaults = {
	      title: null,
	      text: null,
	      timeoutDuration: 5000
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    this.interactionTimeout = false;
	    this.$el = $$2(template(this.settings));
	    this.$el.appendTo($body$2);
	    this.$el.on('shown.slideup', this.onShown.bind(this));
	    this.$el.on('hidden.slideup', this.onHidden.bind(this));
	    this.$el.on('mouseenter', this.onMouseenter.bind(this));
	    this.$el.on('mouseleave', this.onMouseleave.bind(this));
	    this.slideup = new Slideup(this.$el);
	    setTimeout(() => {
	      this.slideup.show();
	    }, 10);
	  }
	  setInteractionTimeout() {
	    this.interactionTimeout = setTimeout(() => {
	      this.slideup.hide();
	    }, this.settings.timeoutDuration);
	  }
	  clearInteractionTimeout() {
	    clearTimeout(this.interactionTimeout);
	  }
	  onMouseenter() {
	    this.clearInteractionTimeout();
	  }
	  onMouseleave() {
	    this.setInteractionTimeout();
	  }
	  onHidden() {
	    this.clearInteractionTimeout();
	    this.$el.remove();
	  }
	  onShown() {
	    this.setInteractionTimeout();
	  }
	}

	const $document = $$2(document);
	const selectors$9 = {
	  tabsContainer: '.tabs-container',
	  tabsListWrapper: '.tabs-list-wrapper',
	  tabsList: '.tabs-list',
	  tab: '.tab',
	  tabsPanelsWrapper: '.tabs-panels-wrapper',
	  tabPanel: '.tab-panel'
	};
	const classes$5 = {
	  tabActive: 'is-active',
	  tabPanelActive: 'is-active'
	};
	class Tabs {
	  /**
	   * Tabs constructor
	   *
	   * @param {HTMLElement | $} el - Element containing the tab elements
	   * @param {Object} options - Options passed into the slider initialize function
	   */
	  constructor(el, options) {
	    const $el = $$2(el);
	    this.name = 'tabs';
	    this.namespace = `.${this.name}`;
	    this.events = {
	      HIDDEN: 'hidden' + this.namespace,
	      HIDE: 'hide' + this.namespace,
	      SHOW: 'show' + this.namespace,
	      SHOWN: 'shown' + this.namespace
	    };
	    this.animationDuration = 300; // For emulating transitions where transitionevents aren't supports
	    this.transitionEndEvent = whichTransitionEnd();
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    this.isAnimating = false;
	    if (!$el.length || !$el.is(selectors$9.tabsContainer)) {
	      console.warn(`[${this.name}] - Tabs container element required to initialize`);
	      return;
	    }
	    this.$el = $el;
	    this.$tabs = $$2(selectors$9.tab, this.$el);
	    this.$tabsList = $$2(selectors$9.tabsList, this.$el);
	    this.$tabsListWrapper = $$2(selectors$9.tabsListWrapper, this.$el);
	    this.$tabPanels = $$2(selectors$9.tabPanel, this.$el);
	    this.$tabsPanelsWrapper = $$2(selectors$9.tabsPanelsWrapper, this.$el);
	    this.$activeTab = this.$tabs.filter('.' + classes$5.tabActive); // Keep track of the active elements
	    this.$activeTabPanel = this.$tabPanels.filter('.' + classes$5.tabPanelActive); // Keep track of the active elements

	    // START required elements check
	    const requiredEls = 'tabs tabsList tabsListWrapper tabPanels tabsPanelsWrapper'.split(' ');
	    const missingEls = [];
	    for (let i = 0; i < requiredEls.length; i++) {
	      const element = requiredEls[i];
	      if (this['$' + element].length === 0) {
	        missingEls.push(element);
	        console.warn(`[${this.name}] - "this.$${element}" element required to initialize`);
	      }
	    }
	    if (missingEls.length > 0) return;
	    // END requirements check

	    this.setTabsPanelsWrapperHeight();
	    this.$el.on('click', selectors$9.tab, this.onTabClick.bind(this));

	    // If no active tab, activate the first one
	    if (this.$activeTab.length === 0) {
	      this.activate(this.$tabs.first());
	    }
	    $$2(window).on('resize', throttle(100, this.onResize.bind(this)));
	  }
	  onResize() {
	    this.setTabsPanelsWrapperHeight();
	  }

	  // Resize tabspanels to max height of the largest panel 
	  setTabsPanelsWrapperHeight() {
	    const heights = [];
	    this.$tabPanels.each((i, el) => {
	      heights.push(el.offsetHeight);
	    });
	    this.$tabsPanelsWrapper.css('height', Math.max.apply(null, heights));
	  }
	  activate($tab) {
	    if (!$tab || $tab.length === 0 || $tab.hasClass(classes$5.tabActive) || $tab.is(this.$activeTab) || this.isAnimating) return;

	    // Tabs
	    if (this.$activeTab && this.$activeTab.length) {
	      this.$activeTab.removeClass(classes$5.tabActive);
	      this.$activeTab.attr('role') === 'tab' && this.$activeTab.attr('aria-selected', false);
	    }
	    $tab.addClass(classes$5.tabActive);
	    $tab.attr('role') === 'tab' && $tab.attr('aria-selected', true);

	    // Tab Panels
	    const $tabPanel = $$2($tab.attr('href'));

	    // Initial callback that happens once the active panel is fully hidden
	    const cb = () => {
	      if (this.$activeTabPanel) {
	        this.$el.trigger($$2.Event(this.events.HIDDEN, {
	          relatedTarget: this.$activeTabPanel.get(0)
	        }));
	      }
	      this.$el.trigger($$2.Event(this.events.SHOW, {
	        relatedTarget: $tabPanel.get(0)
	      }));
	      $tabPanel.addClass(classes$5.tabPanelActive);

	      // Update active element variables
	      this.$activeTab = $tab;
	      this.$activeTabPanel = $tabPanel;

	      // Secondary callback that happens once the newly active panel is fully visible
	      const cb2 = () => {
	        this.$el.trigger($$2.Event(this.events.SHOWN, {
	          relatedTarget: $tabPanel.get(0)
	        }));
	        this.isAnimating = false;
	      };
	      if (this.supportsCssTransitions) {
	        this.$activeTabPanel.one(this.transitionEndEvent, cb2);
	      } else {
	        setTimeout(cb2, this.animationDuration);
	      }
	    };
	    if (this.$activeTabPanel && this.$activeTabPanel.length) {
	      this.$el.trigger($$2.Event(this.events.HIDE, {
	        relatedTarget: this.$activeTabPanel.get(0)
	      }));
	      this.$activeTabPanel.removeClass(classes$5.tabPanelActive);
	      this.isAnimating = true;
	      if (this.supportsCssTransitions) {
	        this.$activeTabPanel.one(this.transitionEndEvent, cb);
	      } else {
	        setTimeout(cb, this.animationDuration);
	      }
	    }
	    // No active panel, just run the callback
	    else {
	      cb();
	    }
	  }

	  // Only used by the theme editor to reset everything
	  deactivate() {
	    this.$tabs.removeClass(classes$5.tabActive);
	    this.$tabPanels.removeClass(classes$5.tabPanelActive);
	    this.$activeTab = undefined;
	    this.$activeTabPanel = undefined;
	    this.isAnimating = false;
	  }
	  onTabClick(e) {
	    e.preventDefault();
	    this.activate($$2(e.currentTarget));
	  }
	}
	$document.on('click.tabs', '[data-toggle="tab"]', function (e) {
	  e.preventDefault();
	  const $this = $$2(this);
	  const $container = $this.parents(selectors$9.tabsContainer);
	  let data = $container.data('tabs');
	  if (!data) {
	    data = new Tabs($container);
	    $container.data('tabs', data);
	    data.activate($$2(e.currentTarget));
	  }
	});

	/*! @vimeo/player v2.10.0 | (c) 2019 Vimeo | MIT License | https://github.com/vimeo/player.js */
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	/**
	 * @module lib/functions
	 */

	/**
	 * Check to see this is a node environment.
	 * @type {Boolean}
	 */

	/* global global */
	var isNode = typeof global !== 'undefined' && {}.toString.call(global) === '[object global]';
	/**
	 * Get the name of the method for a given getter or setter.
	 *
	 * @param {string} prop The name of the property.
	 * @param {string} type Either âgetâ or âsetâ.
	 * @return {string}
	 */

	function getMethodName(prop, type) {
	  if (prop.indexOf(type.toLowerCase()) === 0) {
	    return prop;
	  }
	  return "".concat(type.toLowerCase()).concat(prop.substr(0, 1).toUpperCase()).concat(prop.substr(1));
	}
	/**
	 * Check to see if the object is a DOM Element.
	 *
	 * @param {*} element The object to check.
	 * @return {boolean}
	 */

	function isDomElement(element) {
	  return Boolean(element && element.nodeType === 1 && 'nodeName' in element && element.ownerDocument && element.ownerDocument.defaultView);
	}
	/**
	 * Check to see whether the value is a number.
	 *
	 * @see http://dl.dropboxusercontent.com/u/35146/js/tests/isNumber.html
	 * @param {*} value The value to check.
	 * @param {boolean} integer Check if the value is an integer.
	 * @return {boolean}
	 */

	function isInteger(value) {
	  // eslint-disable-next-line eqeqeq
	  return !isNaN(parseFloat(value)) && isFinite(value) && Math.floor(value) == value;
	}
	/**
	 * Check to see if the URL is a Vimeo url.
	 *
	 * @param {string} url The url string.
	 * @return {boolean}
	 */

	function isVimeoUrl(url) {
	  return /^(https?:)?\/\/((player|www)\.)?vimeo\.com(?=$|\/)/.test(url);
	}
	/**
	 * Get the Vimeo URL from an element.
	 * The element must have either a data-vimeo-id or data-vimeo-url attribute.
	 *
	 * @param {object} oEmbedParameters The oEmbed parameters.
	 * @return {string}
	 */

	function getVimeoUrl() {
	  var oEmbedParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var id = oEmbedParameters.id;
	  var url = oEmbedParameters.url;
	  var idOrUrl = id || url;
	  if (!idOrUrl) {
	    throw new Error('An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.');
	  }
	  if (isInteger(idOrUrl)) {
	    return "https://vimeo.com/".concat(idOrUrl);
	  }
	  if (isVimeoUrl(idOrUrl)) {
	    return idOrUrl.replace('http:', 'https:');
	  }
	  if (id) {
	    throw new TypeError("\u201C".concat(id, "\u201D is not a valid video id."));
	  }
	  throw new TypeError("\u201C".concat(idOrUrl, "\u201D is not a vimeo.com url."));
	}
	var arrayIndexOfSupport = typeof Array.prototype.indexOf !== 'undefined';
	var postMessageSupport = typeof window !== 'undefined' && typeof window.postMessage !== 'undefined';
	if (!isNode && (!arrayIndexOfSupport || !postMessageSupport)) {
	  throw new Error('Sorry, the Vimeo Player API is not available in this browser.');
	}
	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
	function createCommonjsModule(fn, module) {
	  return module = {
	    exports: {}
	  }, fn(module, module.exports), module.exports;
	}

	/*!
	 * weakmap-polyfill v2.0.0 - ECMAScript6 WeakMap polyfill
	 * https://github.com/polygonplanet/weakmap-polyfill
	 * Copyright (c) 2015-2016 polygon planet <polygon.planet.aqua@gmail.com>
	 * @license MIT
	 */
	(function (self) {
	  if (self.WeakMap) {
	    return;
	  }
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var defineProperty = function (object, name, value) {
	    if (Object.defineProperty) {
	      Object.defineProperty(object, name, {
	        configurable: true,
	        writable: true,
	        value: value
	      });
	    } else {
	      object[name] = value;
	    }
	  };
	  self.WeakMap = function () {
	    // ECMA-262 23.3 WeakMap Objects
	    function WeakMap() {
	      if (this === void 0) {
	        throw new TypeError("Constructor WeakMap requires 'new'");
	      }
	      defineProperty(this, '_id', genId('_WeakMap')); // ECMA-262 23.3.1.1 WeakMap([iterable])

	      if (arguments.length > 0) {
	        // Currently, WeakMap `iterable` argument is not supported
	        throw new TypeError('WeakMap iterable is not supported');
	      }
	    } // ECMA-262 23.3.3.2 WeakMap.prototype.delete(key)

	    defineProperty(WeakMap.prototype, 'delete', function (key) {
	      checkInstance(this, 'delete');
	      if (!isObject(key)) {
	        return false;
	      }
	      var entry = key[this._id];
	      if (entry && entry[0] === key) {
	        delete key[this._id];
	        return true;
	      }
	      return false;
	    }); // ECMA-262 23.3.3.3 WeakMap.prototype.get(key)

	    defineProperty(WeakMap.prototype, 'get', function (key) {
	      checkInstance(this, 'get');
	      if (!isObject(key)) {
	        return void 0;
	      }
	      var entry = key[this._id];
	      if (entry && entry[0] === key) {
	        return entry[1];
	      }
	      return void 0;
	    }); // ECMA-262 23.3.3.4 WeakMap.prototype.has(key)

	    defineProperty(WeakMap.prototype, 'has', function (key) {
	      checkInstance(this, 'has');
	      if (!isObject(key)) {
	        return false;
	      }
	      var entry = key[this._id];
	      if (entry && entry[0] === key) {
	        return true;
	      }
	      return false;
	    }); // ECMA-262 23.3.3.5 WeakMap.prototype.set(key, value)

	    defineProperty(WeakMap.prototype, 'set', function (key, value) {
	      checkInstance(this, 'set');
	      if (!isObject(key)) {
	        throw new TypeError('Invalid value used as weak map key');
	      }
	      var entry = key[this._id];
	      if (entry && entry[0] === key) {
	        entry[1] = value;
	        return this;
	      }
	      defineProperty(key, this._id, [key, value]);
	      return this;
	    });
	    function checkInstance(x, methodName) {
	      if (!isObject(x) || !hasOwnProperty.call(x, '_id')) {
	        throw new TypeError(methodName + ' method called on incompatible receiver ' + typeof x);
	      }
	    }
	    function genId(prefix) {
	      return prefix + '_' + rand() + '.' + rand();
	    }
	    function rand() {
	      return Math.random().toString().substring(2);
	    }
	    defineProperty(WeakMap, '_polyfill', true);
	    return WeakMap;
	  }();
	  function isObject(x) {
	    return Object(x) === x;
	  }
	})(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal);
	var npo_src = createCommonjsModule(function (module) {
	  /*! Native Promise Only
	      v0.8.1 (c) Kyle Simpson
	      MIT License: http://getify.mit-license.org
	  */
	  (function UMD(name, context, definition) {
	    // special form of UMD for polyfilling across evironments
	    context[name] = context[name] || definition();
	    if (module.exports) {
	      module.exports = context[name];
	    }
	  })("Promise", typeof commonjsGlobal != "undefined" ? commonjsGlobal : commonjsGlobal, function DEF() {
	    var builtInProp,
	      cycle,
	      scheduling_queue,
	      ToString = Object.prototype.toString,
	      timer = typeof setImmediate != "undefined" ? function timer(fn) {
	        return setImmediate(fn);
	      } : setTimeout; // dammit, IE8.

	    try {
	      Object.defineProperty({}, "x", {});
	      builtInProp = function builtInProp(obj, name, val, config) {
	        return Object.defineProperty(obj, name, {
	          value: val,
	          writable: true,
	          configurable: config !== false
	        });
	      };
	    } catch (err) {
	      builtInProp = function builtInProp(obj, name, val) {
	        obj[name] = val;
	        return obj;
	      };
	    } // Note: using a queue instead of array for efficiency

	    scheduling_queue = function Queue() {
	      var first, last, item;
	      function Item(fn, self) {
	        this.fn = fn;
	        this.self = self;
	        this.next = void 0;
	      }
	      return {
	        add: function add(fn, self) {
	          item = new Item(fn, self);
	          if (last) {
	            last.next = item;
	          } else {
	            first = item;
	          }
	          last = item;
	          item = void 0;
	        },
	        drain: function drain() {
	          var f = first;
	          first = last = cycle = void 0;
	          while (f) {
	            f.fn.call(f.self);
	            f = f.next;
	          }
	        }
	      };
	    }();
	    function schedule(fn, self) {
	      scheduling_queue.add(fn, self);
	      if (!cycle) {
	        cycle = timer(scheduling_queue.drain);
	      }
	    } // promise duck typing

	    function isThenable(o) {
	      var _then,
	        o_type = typeof o;
	      if (o != null && (o_type == "object" || o_type == "function")) {
	        _then = o.then;
	      }
	      return typeof _then == "function" ? _then : false;
	    }
	    function notify() {
	      for (var i = 0; i < this.chain.length; i++) {
	        notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
	      }
	      this.chain.length = 0;
	    } // NOTE: This is a separate function to isolate
	    // the `try..catch` so that other code can be
	    // optimized better

	    function notifyIsolated(self, cb, chain) {
	      var ret, _then;
	      try {
	        if (cb === false) {
	          chain.reject(self.msg);
	        } else {
	          if (cb === true) {
	            ret = self.msg;
	          } else {
	            ret = cb.call(void 0, self.msg);
	          }
	          if (ret === chain.promise) {
	            chain.reject(TypeError("Promise-chain cycle"));
	          } else if (_then = isThenable(ret)) {
	            _then.call(ret, chain.resolve, chain.reject);
	          } else {
	            chain.resolve(ret);
	          }
	        }
	      } catch (err) {
	        chain.reject(err);
	      }
	    }
	    function resolve(msg) {
	      var _then,
	        self = this; // already triggered?

	      if (self.triggered) {
	        return;
	      }
	      self.triggered = true; // unwrap

	      if (self.def) {
	        self = self.def;
	      }
	      try {
	        if (_then = isThenable(msg)) {
	          schedule(function () {
	            var def_wrapper = new MakeDefWrapper(self);
	            try {
	              _then.call(msg, function $resolve$() {
	                resolve.apply(def_wrapper, arguments);
	              }, function $reject$() {
	                reject.apply(def_wrapper, arguments);
	              });
	            } catch (err) {
	              reject.call(def_wrapper, err);
	            }
	          });
	        } else {
	          self.msg = msg;
	          self.state = 1;
	          if (self.chain.length > 0) {
	            schedule(notify, self);
	          }
	        }
	      } catch (err) {
	        reject.call(new MakeDefWrapper(self), err);
	      }
	    }
	    function reject(msg) {
	      var self = this; // already triggered?

	      if (self.triggered) {
	        return;
	      }
	      self.triggered = true; // unwrap

	      if (self.def) {
	        self = self.def;
	      }
	      self.msg = msg;
	      self.state = 2;
	      if (self.chain.length > 0) {
	        schedule(notify, self);
	      }
	    }
	    function iteratePromises(Constructor, arr, resolver, rejecter) {
	      for (var idx = 0; idx < arr.length; idx++) {
	        (function IIFE(idx) {
	          Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
	            resolver(idx, msg);
	          }, rejecter);
	        })(idx);
	      }
	    }
	    function MakeDefWrapper(self) {
	      this.def = self;
	      this.triggered = false;
	    }
	    function MakeDef(self) {
	      this.promise = self;
	      this.state = 0;
	      this.triggered = false;
	      this.chain = [];
	      this.msg = void 0;
	    }
	    function Promise(executor) {
	      if (typeof executor != "function") {
	        throw TypeError("Not a function");
	      }
	      if (this.__NPO__ !== 0) {
	        throw TypeError("Not a promise");
	      } // instance shadowing the inherited "brand"
	      // to signal an already "initialized" promise

	      this.__NPO__ = 1;
	      var def = new MakeDef(this);
	      this["then"] = function then(success, failure) {
	        var o = {
	          success: typeof success == "function" ? success : true,
	          failure: typeof failure == "function" ? failure : false
	        }; // Note: `then(..)` itself can be borrowed to be used against
	        // a different promise constructor for making the chained promise,
	        // by substituting a different `this` binding.

	        o.promise = new this.constructor(function extractChain(resolve, reject) {
	          if (typeof resolve != "function" || typeof reject != "function") {
	            throw TypeError("Not a function");
	          }
	          o.resolve = resolve;
	          o.reject = reject;
	        });
	        def.chain.push(o);
	        if (def.state !== 0) {
	          schedule(notify, def);
	        }
	        return o.promise;
	      };
	      this["catch"] = function $catch$(failure) {
	        return this.then(void 0, failure);
	      };
	      try {
	        executor.call(void 0, function publicResolve(msg) {
	          resolve.call(def, msg);
	        }, function publicReject(msg) {
	          reject.call(def, msg);
	        });
	      } catch (err) {
	        reject.call(def, err);
	      }
	    }
	    var PromisePrototype = builtInProp({}, "constructor", Promise, /*configurable=*/
	    false); // Note: Android 4 cannot use `Object.defineProperty(..)` here

	    Promise.prototype = PromisePrototype; // built-in "brand" to signal an "uninitialized" promise

	    builtInProp(PromisePrototype, "__NPO__", 0, /*configurable=*/
	    false);
	    builtInProp(Promise, "resolve", function Promise$resolve(msg) {
	      var Constructor = this; // spec mandated checks
	      // note: best "isPromise" check that's practical for now

	      if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
	        return msg;
	      }
	      return new Constructor(function executor(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	        resolve(msg);
	      });
	    });
	    builtInProp(Promise, "reject", function Promise$reject(msg) {
	      return new this(function executor(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	        reject(msg);
	      });
	    });
	    builtInProp(Promise, "all", function Promise$all(arr) {
	      var Constructor = this; // spec mandated checks

	      if (ToString.call(arr) != "[object Array]") {
	        return Constructor.reject(TypeError("Not an array"));
	      }
	      if (arr.length === 0) {
	        return Constructor.resolve([]);
	      }
	      return new Constructor(function executor(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	        var len = arr.length,
	          msgs = Array(len),
	          count = 0;
	        iteratePromises(Constructor, arr, function resolver(idx, msg) {
	          msgs[idx] = msg;
	          if (++count === len) {
	            resolve(msgs);
	          }
	        }, reject);
	      });
	    });
	    builtInProp(Promise, "race", function Promise$race(arr) {
	      var Constructor = this; // spec mandated checks

	      if (ToString.call(arr) != "[object Array]") {
	        return Constructor.reject(TypeError("Not an array"));
	      }
	      return new Constructor(function executor(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	        iteratePromises(Constructor, arr, function resolver(idx, msg) {
	          resolve(msg);
	        }, reject);
	      });
	    });
	    return Promise;
	  });
	});

	/**
	 * @module lib/callbacks
	 */
	var callbackMap = new WeakMap();
	/**
	 * Store a callback for a method or event for a player.
	 *
	 * @param {Player} player The player object.
	 * @param {string} name The method or event name.
	 * @param {(function(this:Player, *): void|{resolve: function, reject: function})} callback
	 *        The callback to call or an object with resolve and reject functions for a promise.
	 * @return {void}
	 */

	function storeCallback(player, name, callback) {
	  var playerCallbacks = callbackMap.get(player.element) || {};
	  if (!(name in playerCallbacks)) {
	    playerCallbacks[name] = [];
	  }
	  playerCallbacks[name].push(callback);
	  callbackMap.set(player.element, playerCallbacks);
	}
	/**
	 * Get the callbacks for a player and event or method.
	 *
	 * @param {Player} player The player object.
	 * @param {string} name The method or event name
	 * @return {function[]}
	 */

	function getCallbacks(player, name) {
	  var playerCallbacks = callbackMap.get(player.element) || {};
	  return playerCallbacks[name] || [];
	}
	/**
	 * Remove a stored callback for a method or event for a player.
	 *
	 * @param {Player} player The player object.
	 * @param {string} name The method or event name
	 * @param {function} [callback] The specific callback to remove.
	 * @return {boolean} Was this the last callback?
	 */

	function removeCallback(player, name, callback) {
	  var playerCallbacks = callbackMap.get(player.element) || {};
	  if (!playerCallbacks[name]) {
	    return true;
	  } // If no callback is passed, remove all callbacks for the event

	  if (!callback) {
	    playerCallbacks[name] = [];
	    callbackMap.set(player.element, playerCallbacks);
	    return true;
	  }
	  var index = playerCallbacks[name].indexOf(callback);
	  if (index !== -1) {
	    playerCallbacks[name].splice(index, 1);
	  }
	  callbackMap.set(player.element, playerCallbacks);
	  return playerCallbacks[name] && playerCallbacks[name].length === 0;
	}
	/**
	 * Return the first stored callback for a player and event or method.
	 *
	 * @param {Player} player The player object.
	 * @param {string} name The method or event name.
	 * @return {function} The callback, or false if there were none
	 */

	function shiftCallbacks(player, name) {
	  var playerCallbacks = getCallbacks(player, name);
	  if (playerCallbacks.length < 1) {
	    return false;
	  }
	  var callback = playerCallbacks.shift();
	  removeCallback(player, name, callback);
	  return callback;
	}
	/**
	 * Move callbacks associated with an element to another element.
	 *
	 * @param {HTMLElement} oldElement The old element.
	 * @param {HTMLElement} newElement The new element.
	 * @return {void}
	 */

	function swapCallbacks(oldElement, newElement) {
	  var playerCallbacks = callbackMap.get(oldElement);
	  callbackMap.set(newElement, playerCallbacks);
	  callbackMap.delete(oldElement);
	}

	/**
	 * @module lib/embed
	 */
	var oEmbedParameters = ['autopause', 'autoplay', 'background', 'byline', 'color', 'controls', 'dnt', 'height', 'id', 'loop', 'maxheight', 'maxwidth', 'muted', 'playsinline', 'portrait', 'responsive', 'speed', 'texttrack', 'title', 'transparent', 'url', 'width'];
	/**
	 * Get the 'data-vimeo'-prefixed attributes from an element as an object.
	 *
	 * @param {HTMLElement} element The element.
	 * @param {Object} [defaults={}] The default values to use.
	 * @return {Object<string, string>}
	 */

	function getOEmbedParameters(element) {
	  var defaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  return oEmbedParameters.reduce(function (params, param) {
	    var value = element.getAttribute("data-vimeo-".concat(param));
	    if (value || value === '') {
	      params[param] = value === '' ? 1 : value;
	    }
	    return params;
	  }, defaults);
	}
	/**
	 * Create an embed from oEmbed data inside an element.
	 *
	 * @param {object} data The oEmbed data.
	 * @param {HTMLElement} element The element to put the iframe in.
	 * @return {HTMLIFrameElement} The iframe embed.
	 */

	function createEmbed(_ref, element) {
	  var html = _ref.html;
	  if (!element) {
	    throw new TypeError('An element must be provided');
	  }
	  if (element.getAttribute('data-vimeo-initialized') !== null) {
	    return element.querySelector('iframe');
	  }
	  var div = document.createElement('div');
	  div.innerHTML = html;
	  element.appendChild(div.firstChild);
	  element.setAttribute('data-vimeo-initialized', 'true');
	  return element.querySelector('iframe');
	}
	/**
	 * Make an oEmbed call for the specified URL.
	 *
	 * @param {string} videoUrl The vimeo.com url for the video.
	 * @param {Object} [params] Parameters to pass to oEmbed.
	 * @param {HTMLElement} element The element.
	 * @return {Promise}
	 */

	function getOEmbedData(videoUrl) {
	  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var element = arguments.length > 2 ? arguments[2] : undefined;
	  return new Promise(function (resolve, reject) {
	    if (!isVimeoUrl(videoUrl)) {
	      throw new TypeError("\u201C".concat(videoUrl, "\u201D is not a vimeo.com url."));
	    }
	    var url = "https://vimeo.com/api/oembed.json?url=".concat(encodeURIComponent(videoUrl));
	    for (var param in params) {
	      if (params.hasOwnProperty(param)) {
	        url += "&".concat(param, "=").concat(encodeURIComponent(params[param]));
	      }
	    }
	    var xhr = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onload = function () {
	      if (xhr.status === 404) {
	        reject(new Error("\u201C".concat(videoUrl, "\u201D was not found.")));
	        return;
	      }
	      if (xhr.status === 403) {
	        reject(new Error("\u201C".concat(videoUrl, "\u201D is not embeddable.")));
	        return;
	      }
	      try {
	        var json = JSON.parse(xhr.responseText); // Check api response for 403 on oembed

	        if (json.domain_status_code === 403) {
	          // We still want to create the embed to give users visual feedback
	          createEmbed(json, element);
	          reject(new Error("\u201C".concat(videoUrl, "\u201D is not embeddable.")));
	          return;
	        }
	        resolve(json);
	      } catch (error) {
	        reject(error);
	      }
	    };
	    xhr.onerror = function () {
	      var status = xhr.status ? " (".concat(xhr.status, ")") : '';
	      reject(new Error("There was an error fetching the embed code from Vimeo".concat(status, ".")));
	    };
	    xhr.send();
	  });
	}
	/**
	 * Initialize all embeds within a specific element
	 *
	 * @param {HTMLElement} [parent=document] The parent element.
	 * @return {void}
	 */

	function initializeEmbeds() {
	  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
	  var elements = [].slice.call(parent.querySelectorAll('[data-vimeo-id], [data-vimeo-url]'));
	  var handleError = function handleError(error) {
	    if ('console' in window && console.error) {
	      console.error("There was an error creating an embed: ".concat(error));
	    }
	  };
	  elements.forEach(function (element) {
	    try {
	      // Skip any that have data-vimeo-defer
	      if (element.getAttribute('data-vimeo-defer') !== null) {
	        return;
	      }
	      var params = getOEmbedParameters(element);
	      var url = getVimeoUrl(params);
	      getOEmbedData(url, params, element).then(function (data) {
	        return createEmbed(data, element);
	      }).catch(handleError);
	    } catch (error) {
	      handleError(error);
	    }
	  });
	}
	/**
	 * Resize embeds when messaged by the player.
	 *
	 * @param {HTMLElement} [parent=document] The parent element.
	 * @return {void}
	 */

	function resizeEmbeds() {
	  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

	  // Prevent execution if users include the player.js script multiple times.
	  if (window.VimeoPlayerResizeEmbeds_) {
	    return;
	  }
	  window.VimeoPlayerResizeEmbeds_ = true;
	  var onMessage = function onMessage(event) {
	    if (!isVimeoUrl(event.origin)) {
	      return;
	    } // 'spacechange' is fired only on embeds with cards

	    if (!event.data || event.data.event !== 'spacechange') {
	      return;
	    }
	    var iframes = parent.querySelectorAll('iframe');
	    for (var i = 0; i < iframes.length; i++) {
	      if (iframes[i].contentWindow !== event.source) {
	        continue;
	      } // Change padding-bottom of the enclosing div to accommodate
	      // card carousel without distorting aspect ratio

	      var space = iframes[i].parentElement;
	      space.style.paddingBottom = "".concat(event.data.data[0].bottom, "px");
	      break;
	    }
	  };
	  if (window.addEventListener) {
	    window.addEventListener('message', onMessage, false);
	  } else if (window.attachEvent) {
	    window.attachEvent('onmessage', onMessage);
	  }
	}

	/**
	 * @module lib/postmessage
	 */
	/**
	 * Parse a message received from postMessage.
	 *
	 * @param {*} data The data received from postMessage.
	 * @return {object}
	 */

	function parseMessageData(data) {
	  if (typeof data === 'string') {
	    try {
	      data = JSON.parse(data);
	    } catch (error) {
	      // If the message cannot be parsed, throw the error as a warning
	      console.warn(error);
	      return {};
	    }
	  }
	  return data;
	}
	/**
	 * Post a message to the specified target.
	 *
	 * @param {Player} player The player object to use.
	 * @param {string} method The API method to call.
	 * @param {object} params The parameters to send to the player.
	 * @return {void}
	 */

	function postMessage(player, method, params) {
	  if (!player.element.contentWindow || !player.element.contentWindow.postMessage) {
	    return;
	  }
	  var message = {
	    method: method
	  };
	  if (params !== undefined) {
	    message.value = params;
	  } // IE 8 and 9 do not support passing messages, so stringify them

	  var ieVersion = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, '$1'));
	  if (ieVersion >= 8 && ieVersion < 10) {
	    message = JSON.stringify(message);
	  }
	  player.element.contentWindow.postMessage(message, player.origin);
	}
	/**
	 * Parse the data received from a message event.
	 *
	 * @param {Player} player The player that received the message.
	 * @param {(Object|string)} data The message data. Strings will be parsed into JSON.
	 * @return {void}
	 */

	function processData(player, data) {
	  data = parseMessageData(data);
	  var callbacks = [];
	  var param;
	  if (data.event) {
	    if (data.event === 'error') {
	      var promises = getCallbacks(player, data.data.method);
	      promises.forEach(function (promise) {
	        var error = new Error(data.data.message);
	        error.name = data.data.name;
	        promise.reject(error);
	        removeCallback(player, data.data.method, promise);
	      });
	    }
	    callbacks = getCallbacks(player, "event:".concat(data.event));
	    param = data.data;
	  } else if (data.method) {
	    var callback = shiftCallbacks(player, data.method);
	    if (callback) {
	      callbacks.push(callback);
	      param = data.value;
	    }
	  }
	  callbacks.forEach(function (callback) {
	    try {
	      if (typeof callback === 'function') {
	        callback.call(player, param);
	        return;
	      }
	      callback.resolve(param);
	    } catch (e) {// empty
	    }
	  });
	}
	var playerMap = new WeakMap();
	var readyMap = new WeakMap();
	var Player = /*#__PURE__*/
	function () {
	  /**
	   * Create a Player.
	   *
	   * @param {(HTMLIFrameElement|HTMLElement|string|jQuery)} element A reference to the Vimeo
	   *        player iframe, and id, or a jQuery object.
	   * @param {object} [options] oEmbed parameters to use when creating an embed in the element.
	   * @return {Player}
	   */
	  function Player(element) {
	    var _this = this;
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    _classCallCheck(this, Player);

	    /* global jQuery */
	    if (window.jQuery && element instanceof jQuery) {
	      if (element.length > 1 && window.console && console.warn) {
	        console.warn('A jQuery object with multiple elements was passed, using the first element.');
	      }
	      element = element[0];
	    } // Find an element by ID

	    if (typeof document !== 'undefined' && typeof element === 'string') {
	      element = document.getElementById(element);
	    } // Not an element!

	    if (!isDomElement(element)) {
	      throw new TypeError('You must pass either a valid element or a valid id.');
	    }
	    var win = element.ownerDocument.defaultView; // Already initialized an embed in this div, so grab the iframe

	    if (element.nodeName !== 'IFRAME') {
	      var iframe = element.querySelector('iframe');
	      if (iframe) {
	        element = iframe;
	      }
	    } // iframe url is not a Vimeo url

	    if (element.nodeName === 'IFRAME' && !isVimeoUrl(element.getAttribute('src') || '')) {
	      throw new Error('The player element passed isnât a Vimeo embed.');
	    } // If there is already a player object in the map, return that

	    if (playerMap.has(element)) {
	      return playerMap.get(element);
	    }
	    this.element = element;
	    this.origin = '*';
	    var readyPromise = new npo_src(function (resolve, reject) {
	      var onMessage = function onMessage(event) {
	        if (!isVimeoUrl(event.origin) || _this.element.contentWindow !== event.source) {
	          return;
	        }
	        if (_this.origin === '*') {
	          _this.origin = event.origin;
	        }
	        var data = parseMessageData(event.data);
	        var isError = data && data.event === 'error';
	        var isReadyError = isError && data.data && data.data.method === 'ready';
	        if (isReadyError) {
	          var error = new Error(data.data.message);
	          error.name = data.data.name;
	          reject(error);
	          return;
	        }
	        var isReadyEvent = data && data.event === 'ready';
	        var isPingResponse = data && data.method === 'ping';
	        if (isReadyEvent || isPingResponse) {
	          _this.element.setAttribute('data-ready', 'true');
	          resolve();
	          return;
	        }
	        processData(_this, data);
	      };
	      if (win.addEventListener) {
	        win.addEventListener('message', onMessage, false);
	      } else if (win.attachEvent) {
	        win.attachEvent('onmessage', onMessage);
	      }
	      if (_this.element.nodeName !== 'IFRAME') {
	        var params = getOEmbedParameters(element, options);
	        var url = getVimeoUrl(params);
	        getOEmbedData(url, params, element).then(function (data) {
	          var iframe = createEmbed(data, element); // Overwrite element with the new iframe,
	          // but store reference to the original element

	          _this.element = iframe;
	          _this._originalElement = element;
	          swapCallbacks(element, iframe);
	          playerMap.set(_this.element, _this);
	          return data;
	        }).catch(reject);
	      }
	    }); // Store a copy of this Player in the map

	    readyMap.set(this, readyPromise);
	    playerMap.set(this.element, this); // Send a ping to the iframe so the ready promise will be resolved if
	    // the player is already ready.

	    if (this.element.nodeName === 'IFRAME') {
	      postMessage(this, 'ping');
	    }
	    return this;
	  }
	  /**
	   * Get a promise for a method.
	   *
	   * @param {string} name The API method to call.
	   * @param {Object} [args={}] Arguments to send via postMessage.
	   * @return {Promise}
	   */

	  _createClass(Player, [{
	    key: "callMethod",
	    value: function callMethod(name) {
	      var _this2 = this;
	      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return new npo_src(function (resolve, reject) {
	        // We are storing the resolve/reject handlers to call later, so we
	        // canât return here.
	        // eslint-disable-next-line promise/always-return
	        return _this2.ready().then(function () {
	          storeCallback(_this2, name, {
	            resolve: resolve,
	            reject: reject
	          });
	          postMessage(_this2, name, args);
	        }).catch(reject);
	      });
	    }
	    /**
	     * Get a promise for the value of a player property.
	     *
	     * @param {string} name The property name
	     * @return {Promise}
	     */
	  }, {
	    key: "get",
	    value: function get(name) {
	      var _this3 = this;
	      return new npo_src(function (resolve, reject) {
	        name = getMethodName(name, 'get'); // We are storing the resolve/reject handlers to call later, so we
	        // canât return here.
	        // eslint-disable-next-line promise/always-return

	        return _this3.ready().then(function () {
	          storeCallback(_this3, name, {
	            resolve: resolve,
	            reject: reject
	          });
	          postMessage(_this3, name);
	        }).catch(reject);
	      });
	    }
	    /**
	     * Get a promise for setting the value of a player property.
	     *
	     * @param {string} name The API method to call.
	     * @param {mixed} value The value to set.
	     * @return {Promise}
	     */
	  }, {
	    key: "set",
	    value: function set(name, value) {
	      var _this4 = this;
	      return new npo_src(function (resolve, reject) {
	        name = getMethodName(name, 'set');
	        if (value === undefined || value === null) {
	          throw new TypeError('There must be a value to set.');
	        } // We are storing the resolve/reject handlers to call later, so we
	        // canât return here.
	        // eslint-disable-next-line promise/always-return

	        return _this4.ready().then(function () {
	          storeCallback(_this4, name, {
	            resolve: resolve,
	            reject: reject
	          });
	          postMessage(_this4, name, value);
	        }).catch(reject);
	      });
	    }
	    /**
	     * Add an event listener for the specified event. Will call the
	     * callback with a single parameter, `data`, that contains the data for
	     * that event.
	     *
	     * @param {string} eventName The name of the event.
	     * @param {function(*)} callback The function to call when the event fires.
	     * @return {void}
	     */
	  }, {
	    key: "on",
	    value: function on(eventName, callback) {
	      if (!eventName) {
	        throw new TypeError('You must pass an event name.');
	      }
	      if (!callback) {
	        throw new TypeError('You must pass a callback function.');
	      }
	      if (typeof callback !== 'function') {
	        throw new TypeError('The callback must be a function.');
	      }
	      var callbacks = getCallbacks(this, "event:".concat(eventName));
	      if (callbacks.length === 0) {
	        this.callMethod('addEventListener', eventName).catch(function () {// Ignore the error. There will be an error event fired that
	          // will trigger the error callback if they are listening.
	        });
	      }
	      storeCallback(this, "event:".concat(eventName), callback);
	    }
	    /**
	     * Remove an event listener for the specified event. Will remove all
	     * listeners for that event if a `callback` isnât passed, or only that
	     * specific callback if it is passed.
	     *
	     * @param {string} eventName The name of the event.
	     * @param {function} [callback] The specific callback to remove.
	     * @return {void}
	     */
	  }, {
	    key: "off",
	    value: function off(eventName, callback) {
	      if (!eventName) {
	        throw new TypeError('You must pass an event name.');
	      }
	      if (callback && typeof callback !== 'function') {
	        throw new TypeError('The callback must be a function.');
	      }
	      var lastCallback = removeCallback(this, "event:".concat(eventName), callback); // If there are no callbacks left, remove the listener

	      if (lastCallback) {
	        this.callMethod('removeEventListener', eventName).catch(function (e) {// Ignore the error. There will be an error event fired that
	          // will trigger the error callback if they are listening.
	        });
	      }
	    }
	    /**
	     * A promise to load a new video.
	     *
	     * @promise LoadVideoPromise
	     * @fulfill {number} The video with this id successfully loaded.
	     * @reject {TypeError} The id was not a number.
	     */

	    /**
	     * Load a new video into this embed. The promise will be resolved if
	     * the video is successfully loaded, or it will be rejected if it could
	     * not be loaded.
	     *
	     * @param {number|object} options The id of the video or an object with embed options.
	     * @return {LoadVideoPromise}
	     */
	  }, {
	    key: "loadVideo",
	    value: function loadVideo(options) {
	      return this.callMethod('loadVideo', options);
	    }
	    /**
	     * A promise to perform an action when the Player is ready.
	     *
	     * @todo document errors
	     * @promise LoadVideoPromise
	     * @fulfill {void}
	     */

	    /**
	     * Trigger a function when the player iframe has initialized. You do not
	     * need to wait for `ready` to trigger to begin adding event listeners
	     * or calling other methods.
	     *
	     * @return {ReadyPromise}
	     */
	  }, {
	    key: "ready",
	    value: function ready() {
	      var readyPromise = readyMap.get(this) || new npo_src(function (resolve, reject) {
	        reject(new Error('Unknown player. Probably unloaded.'));
	      });
	      return npo_src.resolve(readyPromise);
	    }
	    /**
	     * A promise to add a cue point to the player.
	     *
	     * @promise AddCuePointPromise
	     * @fulfill {string} The id of the cue point to use for removeCuePoint.
	     * @reject {RangeError} the time was less than 0 or greater than the
	     *         videoâs duration.
	     * @reject {UnsupportedError} Cue points are not supported with the current
	     *         player or browser.
	     */

	    /**
	     * Add a cue point to the player.
	     *
	     * @param {number} time The time for the cue point.
	     * @param {object} [data] Arbitrary data to be returned with the cue point.
	     * @return {AddCuePointPromise}
	     */
	  }, {
	    key: "addCuePoint",
	    value: function addCuePoint(time) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return this.callMethod('addCuePoint', {
	        time: time,
	        data: data
	      });
	    }
	    /**
	     * A promise to remove a cue point from the player.
	     *
	     * @promise AddCuePointPromise
	     * @fulfill {string} The id of the cue point that was removed.
	     * @reject {InvalidCuePoint} The cue point with the specified id was not
	     *         found.
	     * @reject {UnsupportedError} Cue points are not supported with the current
	     *         player or browser.
	     */

	    /**
	     * Remove a cue point from the video.
	     *
	     * @param {string} id The id of the cue point to remove.
	     * @return {RemoveCuePointPromise}
	     */
	  }, {
	    key: "removeCuePoint",
	    value: function removeCuePoint(id) {
	      return this.callMethod('removeCuePoint', id);
	    }
	    /**
	     * A representation of a text track on a video.
	     *
	     * @typedef {Object} VimeoTextTrack
	     * @property {string} language The ISO language code.
	     * @property {string} kind The kind of track it is (captions or subtitles).
	     * @property {string} label The humanâreadable label for the track.
	     */

	    /**
	     * A promise to enable a text track.
	     *
	     * @promise EnableTextTrackPromise
	     * @fulfill {VimeoTextTrack} The text track that was enabled.
	     * @reject {InvalidTrackLanguageError} No track was available with the
	     *         specified language.
	     * @reject {InvalidTrackError} No track was available with the specified
	     *         language and kind.
	     */

	    /**
	     * Enable the text track with the specified language, and optionally the
	     * specified kind (captions or subtitles).
	     *
	     * When set via the API, the track language will not change the viewerâs
	     * stored preference.
	     *
	     * @param {string} language The twoâletter language code.
	     * @param {string} [kind] The kind of track to enable (captions or subtitles).
	     * @return {EnableTextTrackPromise}
	     */
	  }, {
	    key: "enableTextTrack",
	    value: function enableTextTrack(language, kind) {
	      if (!language) {
	        throw new TypeError('You must pass a language.');
	      }
	      return this.callMethod('enableTextTrack', {
	        language: language,
	        kind: kind
	      });
	    }
	    /**
	     * A promise to disable the active text track.
	     *
	     * @promise DisableTextTrackPromise
	     * @fulfill {void} The track was disabled.
	     */

	    /**
	     * Disable the currently-active text track.
	     *
	     * @return {DisableTextTrackPromise}
	     */
	  }, {
	    key: "disableTextTrack",
	    value: function disableTextTrack() {
	      return this.callMethod('disableTextTrack');
	    }
	    /**
	     * A promise to pause the video.
	     *
	     * @promise PausePromise
	     * @fulfill {void} The video was paused.
	     */

	    /**
	     * Pause the video if itâs playing.
	     *
	     * @return {PausePromise}
	     */
	  }, {
	    key: "pause",
	    value: function pause() {
	      return this.callMethod('pause');
	    }
	    /**
	     * A promise to play the video.
	     *
	     * @promise PlayPromise
	     * @fulfill {void} The video was played.
	     */

	    /**
	     * Play the video if itâs paused. **Note:** on iOS and some other
	     * mobile devices, you cannot programmatically trigger play. Once the
	     * viewer has tapped on the play button in the player, however, you
	     * will be able to use this function.
	     *
	     * @return {PlayPromise}
	     */
	  }, {
	    key: "play",
	    value: function play() {
	      return this.callMethod('play');
	    }
	    /**
	     * A promise to unload the video.
	     *
	     * @promise UnloadPromise
	     * @fulfill {void} The video was unloaded.
	     */

	    /**
	     * Return the player to its initial state.
	     *
	     * @return {UnloadPromise}
	     */
	  }, {
	    key: "unload",
	    value: function unload() {
	      return this.callMethod('unload');
	    }
	    /**
	     * Cleanup the player and remove it from the DOM
	     *
	     * It won't be usable and a new one should be constructed
	     *  in order to do any operations.
	     *
	     * @return {Promise}
	     */
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      var _this5 = this;
	      return new npo_src(function (resolve) {
	        readyMap.delete(_this5);
	        playerMap.delete(_this5.element);
	        if (_this5._originalElement) {
	          playerMap.delete(_this5._originalElement);
	          _this5._originalElement.removeAttribute('data-vimeo-initialized');
	        }
	        if (_this5.element && _this5.element.nodeName === 'IFRAME' && _this5.element.parentNode) {
	          _this5.element.parentNode.removeChild(_this5.element);
	        }
	        resolve();
	      });
	    }
	    /**
	     * A promise to get the autopause behavior of the video.
	     *
	     * @promise GetAutopausePromise
	     * @fulfill {boolean} Whether autopause is turned on or off.
	     * @reject {UnsupportedError} Autopause is not supported with the current
	     *         player or browser.
	     */

	    /**
	     * Get the autopause behavior for this player.
	     *
	     * @return {GetAutopausePromise}
	     */
	  }, {
	    key: "getAutopause",
	    value: function getAutopause() {
	      return this.get('autopause');
	    }
	    /**
	     * A promise to set the autopause behavior of the video.
	     *
	     * @promise SetAutopausePromise
	     * @fulfill {boolean} Whether autopause is turned on or off.
	     * @reject {UnsupportedError} Autopause is not supported with the current
	     *         player or browser.
	     */

	    /**
	     * Enable or disable the autopause behavior of this player.
	     *
	     * By default, when another video is played in the same browser, this
	     * player will automatically pause. Unless you have a specific reason
	     * for doing so, we recommend that you leave autopause set to the
	     * default (`true`).
	     *
	     * @param {boolean} autopause
	     * @return {SetAutopausePromise}
	     */
	  }, {
	    key: "setAutopause",
	    value: function setAutopause(autopause) {
	      return this.set('autopause', autopause);
	    }
	    /**
	     * A promise to get the buffered property of the video.
	     *
	     * @promise GetBufferedPromise
	     * @fulfill {Array} Buffered Timeranges converted to an Array.
	     */

	    /**
	     * Get the buffered property of the video.
	     *
	     * @return {GetBufferedPromise}
	     */
	  }, {
	    key: "getBuffered",
	    value: function getBuffered() {
	      return this.get('buffered');
	    }
	    /**
	     * A promise to get the color of the player.
	     *
	     * @promise GetColorPromise
	     * @fulfill {string} The hex color of the player.
	     */

	    /**
	     * Get the color for this player.
	     *
	     * @return {GetColorPromise}
	     */
	  }, {
	    key: "getColor",
	    value: function getColor() {
	      return this.get('color');
	    }
	    /**
	     * A promise to set the color of the player.
	     *
	     * @promise SetColorPromise
	     * @fulfill {string} The color was successfully set.
	     * @reject {TypeError} The string was not a valid hex or rgb color.
	     * @reject {ContrastError} The color was set, but the contrast is
	     *         outside of the acceptable range.
	     * @reject {EmbedSettingsError} The owner of the player has chosen to
	     *         use a specific color.
	     */

	    /**
	     * Set the color of this player to a hex or rgb string. Setting the
	     * color may fail if the owner of the video has set their embed
	     * preferences to force a specific color.
	     *
	     * @param {string} color The hex or rgb color string to set.
	     * @return {SetColorPromise}
	     */
	  }, {
	    key: "setColor",
	    value: function setColor(color) {
	      return this.set('color', color);
	    }
	    /**
	     * A representation of a cue point.
	     *
	     * @typedef {Object} VimeoCuePoint
	     * @property {number} time The time of the cue point.
	     * @property {object} data The data passed when adding the cue point.
	     * @property {string} id The unique id for use with removeCuePoint.
	     */

	    /**
	     * A promise to get the cue points of a video.
	     *
	     * @promise GetCuePointsPromise
	     * @fulfill {VimeoCuePoint[]} The cue points added to the video.
	     * @reject {UnsupportedError} Cue points are not supported with the current
	     *         player or browser.
	     */

	    /**
	     * Get an array of the cue points added to the video.
	     *
	     * @return {GetCuePointsPromise}
	     */
	  }, {
	    key: "getCuePoints",
	    value: function getCuePoints() {
	      return this.get('cuePoints');
	    }
	    /**
	     * A promise to get the current time of the video.
	     *
	     * @promise GetCurrentTimePromise
	     * @fulfill {number} The current time in seconds.
	     */

	    /**
	     * Get the current playback position in seconds.
	     *
	     * @return {GetCurrentTimePromise}
	     */
	  }, {
	    key: "getCurrentTime",
	    value: function getCurrentTime() {
	      return this.get('currentTime');
	    }
	    /**
	     * A promise to set the current time of the video.
	     *
	     * @promise SetCurrentTimePromise
	     * @fulfill {number} The actual current time that was set.
	     * @reject {RangeError} the time was less than 0 or greater than the
	     *         videoâs duration.
	     */

	    /**
	     * Set the current playback position in seconds. If the player was
	     * paused, it will remain paused. Likewise, if the player was playing,
	     * it will resume playing once the video has buffered.
	     *
	     * You can provide an accurate time and the player will attempt to seek
	     * to as close to that time as possible. The exact time will be the
	     * fulfilled value of the promise.
	     *
	     * @param {number} currentTime
	     * @return {SetCurrentTimePromise}
	     */
	  }, {
	    key: "setCurrentTime",
	    value: function setCurrentTime(currentTime) {
	      return this.set('currentTime', currentTime);
	    }
	    /**
	     * A promise to get the duration of the video.
	     *
	     * @promise GetDurationPromise
	     * @fulfill {number} The duration in seconds.
	     */

	    /**
	     * Get the duration of the video in seconds. It will be rounded to the
	     * nearest second before playback begins, and to the nearest thousandth
	     * of a second after playback begins.
	     *
	     * @return {GetDurationPromise}
	     */
	  }, {
	    key: "getDuration",
	    value: function getDuration() {
	      return this.get('duration');
	    }
	    /**
	     * A promise to get the ended state of the video.
	     *
	     * @promise GetEndedPromise
	     * @fulfill {boolean} Whether or not the video has ended.
	     */

	    /**
	     * Get the ended state of the video. The video has ended if
	     * `currentTime === duration`.
	     *
	     * @return {GetEndedPromise}
	     */
	  }, {
	    key: "getEnded",
	    value: function getEnded() {
	      return this.get('ended');
	    }
	    /**
	     * A promise to get the loop state of the player.
	     *
	     * @promise GetLoopPromise
	     * @fulfill {boolean} Whether or not the player is set to loop.
	     */

	    /**
	     * Get the loop state of the player.
	     *
	     * @return {GetLoopPromise}
	     */
	  }, {
	    key: "getLoop",
	    value: function getLoop() {
	      return this.get('loop');
	    }
	    /**
	     * A promise to set the loop state of the player.
	     *
	     * @promise SetLoopPromise
	     * @fulfill {boolean} The loop state that was set.
	     */

	    /**
	     * Set the loop state of the player. When set to `true`, the player
	     * will start over immediately once playback ends.
	     *
	     * @param {boolean} loop
	     * @return {SetLoopPromise}
	     */
	  }, {
	    key: "setLoop",
	    value: function setLoop(loop) {
	      return this.set('loop', loop);
	    }
	    /**
	     * A promise to set the muted state of the player.
	     *
	     * @promise SetMutedPromise
	     * @fulfill {boolean} The muted state that was set.
	     */

	    /**
	     * Set the muted state of the player. When set to `true`, the player
	     * volume will be muted.
	     *
	     * @param {boolean} muted
	     * @return {SetMutedPromise}
	     */
	  }, {
	    key: "setMuted",
	    value: function setMuted(muted) {
	      return this.set('muted', muted);
	    }
	    /**
	     * A promise to get the muted state of the player.
	     *
	     * @promise GetMutedPromise
	     * @fulfill {boolean} Whether or not the player is muted.
	     */

	    /**
	     * Get the muted state of the player.
	     *
	     * @return {GetMutedPromise}
	     */
	  }, {
	    key: "getMuted",
	    value: function getMuted() {
	      return this.get('muted');
	    }
	    /**
	     * A promise to get the paused state of the player.
	     *
	     * @promise GetLoopPromise
	     * @fulfill {boolean} Whether or not the video is paused.
	     */

	    /**
	     * Get the paused state of the player.
	     *
	     * @return {GetLoopPromise}
	     */
	  }, {
	    key: "getPaused",
	    value: function getPaused() {
	      return this.get('paused');
	    }
	    /**
	     * A promise to get the playback rate of the player.
	     *
	     * @promise GetPlaybackRatePromise
	     * @fulfill {number} The playback rate of the player on a scale from 0.5 to 2.
	     */

	    /**
	     * Get the playback rate of the player on a scale from `0.5` to `2`.
	     *
	     * @return {GetPlaybackRatePromise}
	     */
	  }, {
	    key: "getPlaybackRate",
	    value: function getPlaybackRate() {
	      return this.get('playbackRate');
	    }
	    /**
	     * A promise to set the playbackrate of the player.
	     *
	     * @promise SetPlaybackRatePromise
	     * @fulfill {number} The playback rate was set.
	     * @reject {RangeError} The playback rate was less than 0.5 or greater than 2.
	     */

	    /**
	     * Set the playback rate of the player on a scale from `0.5` to `2`. When set
	     * via the API, the playback rate will not be synchronized to other
	     * players or stored as the viewer's preference.
	     *
	     * @param {number} playbackRate
	     * @return {SetPlaybackRatePromise}
	     */
	  }, {
	    key: "setPlaybackRate",
	    value: function setPlaybackRate(playbackRate) {
	      return this.set('playbackRate', playbackRate);
	    }
	    /**
	     * A promise to get the played property of the video.
	     *
	     * @promise GetPlayedPromise
	     * @fulfill {Array} Played Timeranges converted to an Array.
	     */

	    /**
	     * Get the played property of the video.
	     *
	     * @return {GetPlayedPromise}
	     */
	  }, {
	    key: "getPlayed",
	    value: function getPlayed() {
	      return this.get('played');
	    }
	    /**
	     * A promise to get the seekable property of the video.
	     *
	     * @promise GetSeekablePromise
	     * @fulfill {Array} Seekable Timeranges converted to an Array.
	     */

	    /**
	     * Get the seekable property of the video.
	     *
	     * @return {GetSeekablePromise}
	     */
	  }, {
	    key: "getSeekable",
	    value: function getSeekable() {
	      return this.get('seekable');
	    }
	    /**
	     * A promise to get the seeking property of the player.
	     *
	     * @promise GetSeekingPromise
	     * @fulfill {boolean} Whether or not the player is currently seeking.
	     */

	    /**
	     * Get if the player is currently seeking.
	     *
	     * @return {GetSeekingPromise}
	     */
	  }, {
	    key: "getSeeking",
	    value: function getSeeking() {
	      return this.get('seeking');
	    }
	    /**
	     * A promise to get the text tracks of a video.
	     *
	     * @promise GetTextTracksPromise
	     * @fulfill {VimeoTextTrack[]} The text tracks associated with the video.
	     */

	    /**
	     * Get an array of the text tracks that exist for the video.
	     *
	     * @return {GetTextTracksPromise}
	     */
	  }, {
	    key: "getTextTracks",
	    value: function getTextTracks() {
	      return this.get('textTracks');
	    }
	    /**
	     * A promise to get the embed code for the video.
	     *
	     * @promise GetVideoEmbedCodePromise
	     * @fulfill {string} The `<iframe>` embed code for the video.
	     */

	    /**
	     * Get the `<iframe>` embed code for the video.
	     *
	     * @return {GetVideoEmbedCodePromise}
	     */
	  }, {
	    key: "getVideoEmbedCode",
	    value: function getVideoEmbedCode() {
	      return this.get('videoEmbedCode');
	    }
	    /**
	     * A promise to get the id of the video.
	     *
	     * @promise GetVideoIdPromise
	     * @fulfill {number} The id of the video.
	     */

	    /**
	     * Get the id of the video.
	     *
	     * @return {GetVideoIdPromise}
	     */
	  }, {
	    key: "getVideoId",
	    value: function getVideoId() {
	      return this.get('videoId');
	    }
	    /**
	     * A promise to get the title of the video.
	     *
	     * @promise GetVideoTitlePromise
	     * @fulfill {number} The title of the video.
	     */

	    /**
	     * Get the title of the video.
	     *
	     * @return {GetVideoTitlePromise}
	     */
	  }, {
	    key: "getVideoTitle",
	    value: function getVideoTitle() {
	      return this.get('videoTitle');
	    }
	    /**
	     * A promise to get the native width of the video.
	     *
	     * @promise GetVideoWidthPromise
	     * @fulfill {number} The native width of the video.
	     */

	    /**
	     * Get the native width of the currentlyâplaying video. The width of
	     * the highestâresolution available will be used before playback begins.
	     *
	     * @return {GetVideoWidthPromise}
	     */
	  }, {
	    key: "getVideoWidth",
	    value: function getVideoWidth() {
	      return this.get('videoWidth');
	    }
	    /**
	     * A promise to get the native height of the video.
	     *
	     * @promise GetVideoHeightPromise
	     * @fulfill {number} The native height of the video.
	     */

	    /**
	     * Get the native height of the currentlyâplaying video. The height of
	     * the highestâresolution available will be used before playback begins.
	     *
	     * @return {GetVideoHeightPromise}
	     */
	  }, {
	    key: "getVideoHeight",
	    value: function getVideoHeight() {
	      return this.get('videoHeight');
	    }
	    /**
	     * A promise to get the vimeo.com url for the video.
	     *
	     * @promise GetVideoUrlPromise
	     * @fulfill {number} The vimeo.com url for the video.
	     * @reject {PrivacyError} The url isnât available because of the videoâs privacy setting.
	     */

	    /**
	     * Get the vimeo.com url for the video.
	     *
	     * @return {GetVideoUrlPromise}
	     */
	  }, {
	    key: "getVideoUrl",
	    value: function getVideoUrl() {
	      return this.get('videoUrl');
	    }
	    /**
	     * A promise to get the volume level of the player.
	     *
	     * @promise GetVolumePromise
	     * @fulfill {number} The volume level of the player on a scale from 0 to 1.
	     */

	    /**
	     * Get the current volume level of the player on a scale from `0` to `1`.
	     *
	     * Most mobile devices do not support an independent volume from the
	     * system volume. In those cases, this method will always return `1`.
	     *
	     * @return {GetVolumePromise}
	     */
	  }, {
	    key: "getVolume",
	    value: function getVolume() {
	      return this.get('volume');
	    }
	    /**
	     * A promise to set the volume level of the player.
	     *
	     * @promise SetVolumePromise
	     * @fulfill {number} The volume was set.
	     * @reject {RangeError} The volume was less than 0 or greater than 1.
	     */

	    /**
	     * Set the volume of the player on a scale from `0` to `1`. When set
	     * via the API, the volume level will not be synchronized to other
	     * players or stored as the viewerâs preference.
	     *
	     * Most mobile devices do not support setting the volume. An error will
	     * *not* be triggered in that situation.
	     *
	     * @param {number} volume
	     * @return {SetVolumePromise}
	     */
	  }, {
	    key: "setVolume",
	    value: function setVolume(volume) {
	      return this.set('volume', volume);
	    }
	  }]);
	  return Player;
	}(); // Setup embed only if this is not a node environment

	if (!isNode) {
	  initializeEmbeds();
	  resizeEmbeds();
	}

	/* eslint-disable */
	/**
	 * Video Player Script
	 * -----------------------------------------------------------------------------
	 *
	 * Creates a Video Player player out of basic markup
	 * Requires some basic styling to make things work correctly - see components/video-player.scss
	 *
	 * Mark up looks like...
	 *
	 * <div id="video-player-{{ yt_video_id }}" class="video-player" data-video-player data-video-id="{{ yt_video_id }}" data-video-type="vimeo / youtube" data-background="{{ true / false }}" data-embed-color="{{ hex_color }}">
	 *   <div class="video-player__cover" data-video-player-cover>
	 *     <div class="video-player__cover-still" style="background-image: url(...);"></div>
	 *     <span class="video-player__cover-play">{% include 'icon-play-button' %}</span>
	 *   </div>
	 *   <div class="video-player__embed" data-video-player-embed></div>
	 * </div>
	 *
	 */
	/* eslint-enable */

	const selectors$8 = {
	  videoPlayer: '[data-video-player]',
	  videoPlayerEmbed: '[data-video-player-embed]',
	  videoPlayerCover: '[data-video-player-cover]'
	};
	const classes$4 = {
	  state: {
	    playing: 'video-player--playing',
	    ended: 'video-player--ended',
	    paused: 'video-player--paused',
	    buffering: 'video-player--buffering'
	  }
	};
	const VIDEO_TYPES = {
	  VIMEO: 'vimeo',
	  YOUTUBE: 'youtube'
	};
	const dataKey = 'video-player-instance';
	class VideoPlayer {
	  /**
	   * VideoPlayer constructor
	   *
	   * @param {HTMLElement | $} el - Element containing required markup.  All settings are passed as data attributes on this element
	   */
	  constructor(el) {
	    this.name = 'videoPlayer';
	    this.namespace = `.${this.name}`;
	    this.$el = $$2(el);
	    if (!this.$el.is(selectors$8.videoPlayer)) {
	      console.warn(`[${this.name}] - Element matching ${selectors$8.videoPlayer} required to initialize`);
	      return;
	    }
	    this.player = null;
	    this.state = null;
	    this.type = this.$el.data('video-type');
	    this.id = this.$el.data('video-id');
	    this.background = this.$el.data('background');
	    this.embedColor = this.$el.data('embed-color') || '000';
	    if (!this.id || !(this.type === VIDEO_TYPES.VIMEO || this.type === VIDEO_TYPES.YOUTUBE)) {
	      console.warn(`[${this.name}] - Video ID and valid video type required to initialize`);
	      return;
	    }
	    this.$embed = this.$el.find(selectors$8.videoPlayerEmbed);
	    this.$cover = this.$el.find(selectors$8.videoPlayerCover);

	    // These bind functions create a player from their respective JS libraries
	    // and add a click handlers on the cover
	    if (this.type === VIDEO_TYPES.VIMEO) {
	      this.bindVimeoPlayer();
	    } else if (this.type === VIDEO_TYPES.YOUTUBE) {
	      this.bindYouTubePlayer();
	    }
	  }
	  bindVimeoPlayer() {
	    const opts = {
	      id: this.id,
	      color: this.embedColor.replace('#', '')
	    };
	    opts.background = this.background || false;
	    opts.muted = this.background;
	    opts.autoplay = this.background;
	    this.player = new Player(this.$embed, opts);
	    this.player.on('ended', this.onEnded.bind(this));
	    this.player.on('play', this.onPlay.bind(this));
	    this.player.on('pause', this.onPaused.bind(this));
	    this.player.on('bufferstart', this.onBuffering.bind(this));
	    if (this.background && this.$cover.length) {
	      this.$cover.remove();
	      this.$cover = null;
	    } else {
	      this.$cover.on('click', this.onCoverClick.bind(this));
	    }
	  }
	  bindYouTubePlayer() {
	    function createPlayer() {
	      const uniqID = `${this.$el.attr('id')}-player`;
	      this.$embed.attr({
	        sandbox: 'allow-same-origin allow-scripts allow-presentation',
	        id: uniqID,
	        frameborder: 0
	      });
	      this.player = new window.YT.Player(uniqID, {
	        videoId: this.id,
	        playerVars: {
	          rel: 0,
	          autohide: 1,
	          controls: 2,
	          playsinline: 1,
	          modestbranding: 1,
	          wmode: 'transparent'
	        },
	        events: {
	          onReady: e => {
	            this.$cover.on('click', this.onCoverClick.bind(this));
	          },
	          onStateChange: e => {
	            switch (e.data) {
	              case window.YT.PlayerState.PLAYING:
	                this.onPlay();
	                break;
	              case window.YT.PlayerState.PAUSED:
	                this.onPaused();
	                break;
	              case window.YT.PlayerState.ENDED:
	                this.onEnded();
	                break;
	              case window.YT.PlayerState.BUFFERING:
	                this.onBuffering();
	                break;
	            }
	          }
	        }
	      });
	    }
	    const _createPlayer = createPlayer.bind(this);
	    if (window.YT === undefined) {
	      window.onYouTubeIframeAPIReady = _createPlayer;
	      const tag = document.createElement('script');
	      tag.src = 'https://www.youtube.com/iframe_api';
	      const firstScriptTag = document.getElementsByTagName('script')[0];
	      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
	    } else {
	      _createPlayer();
	    }
	  }
	  switchToState(state) {
	    this.$el.removeClass(classes$4.state[this.state]);
	    this.$el.addClass(classes$4.state[state]);
	    this.state = state;
	  }
	  play() {
	    if (this.type === VIDEO_TYPES.YOUTUBE) {
	      this.player.playVideo();
	    } else if (this.type === VIDEO_TYPES.VIMEO) {
	      this.player.play().then(this.onPlay.bind(this));
	    }
	  }
	  pause() {
	    if (this.type === VIDEO_TYPES.YOUTUBE) {
	      this.player.pauseVideo();
	    } else if (this.type === VIDEO_TYPES.VIMEO) {
	      this.player.pause().then(this.onPaused.bind(this));
	    }
	  }
	  onPlay() {
	    this.switchToState('playing');
	  }
	  onEnded() {
	    this.switchToState('ended');
	  }
	  onPaused() {
	    this.switchToState('paused');
	  }
	  onBuffering() {
	    this.switchToState('buffering');
	  }
	  onCoverClick(e) {
	    e.preventDefault();
	    this.play();
	  }
	  static ensure(el) {
	    let $el = $$2(el);
	    if (!$el.is(selectors$8.videoPlayer)) {
	      $el = $el.parents(selectors$8.videoPlayer);
	    }
	    let data = $el.data(dataKey);
	    if (!data) {
	      $el.data(dataKey, data = new VideoPlayer($el));
	    }
	    return data;
	  }
	  static refresh($container) {
	    $$2(selectors$8.videoPlayer, $container).each((i, el) => {
	      VideoPlayer.ensure(el);
	    });
	  }
	  static getDataKey() {
	    return dataKey;
	  }
	}

	const selectors$7 = {
	  addForm: 'form[action^="/cart/add"]',
	  addToCart: '[data-add-to-cart]',
	  addToCartText: '[data-add-to-cart-text]'
	};
	const $window$1 = $$2(window);
	const $body$1 = $$2(document.body);
	class AJAXFormManager {
	  constructor() {
	    this.name = 'ajaxFormManager';
	    this.namespace = `.${this.name}`;
	    this.events = {
	      ADD_SUCCESS: `addSuccess${this.namespace}`,
	      ADD_FAIL: `addFail${this.namespace}`
	    };
	    this.requestInProgress = false;
	    $body$1.on('submit', selectors$7.addForm, e => {
	      e.preventDefault();
	      if (this.requestInProgress) return;
	      const $submitButton = $$2(e.target).find(selectors$7.addToCart);
	      const $submitButtonText = $submitButton.find(selectors$7.addToCartText);

	      // Update the submit button text and disable the button so the user knows the form is being submitted
	      $submitButton.prop('disabled', true);
	      $submitButtonText.html(getPropByString(window, 'theme.strings.adding') || 'Adding');
	      CartAPI$1.addItemFromForm($$2(e.target)).then(data => {
	        const event = $$2.Event(this.events.ADD_SUCCESS, {
	          cart: data
	        });
	        $window$1.trigger(event);
	      }).fail(data => {
	        const event = $$2.Event(this.events.ADD_FAIL, {
	          data
	        });
	        $window$1.trigger(event);
	      }).always(() => {
	        // Reset button state
	        $submitButton.prop('disabled', false);
	        $submitButtonText.html(theme.strings.addToCart);
	      });
	    });
	  }
	}
	new AJAXFormManager();

	$$2(window);
	$$2(document.body);

	// $("#CartNote").keydown(function (e) {
	//   // Allow: backspace, delete, tab, escape and enter
	//   if ($.inArray(e.keyCode, [46, 8, 9, 27, 13, 110, 190]) !== -1 ||
	//        // Allow: Ctrl+A
	//       (e.keyCode === 65 && e.ctrlKey === true) ||

	//       (e.keyCode >= 96 && e.keyCode <= 105) ||

	//       (e.keyCode >= 49 && e.keyCode <= 57 && e.shiftKey === false) ||

	//       (e.keyCode === 49 && e.shiftKey === true) ||

	//       (e.keyCode >= 65 && e.keyCode <= 90 && e.altKey === false) ||
	//        // Allow: home, end, left, right
	//       (e.keyCode >= 32 && e.keyCode <= 39)) {
	//            // let it happen, don't do anything
	//            return;
	//             }

	//   if (e.shiftKey || (e.keyCode < 65 || e.keyCode > 105)) {
	//       e.preventDefault();
	//   }
	// });

	// $('#CartNote').on('input', function() {
	//   var c = this.selectionStart,
	//       r = /[^a-z0-9]/gi,
	//       v = $(this).val();
	//   if(r.test(v)) {
	//     $(this).val(v.replace(r, ''));
	//     c--;
	//   }
	//   this.setSelectionRange(c, c);
	// });

	$$2(document).ready(function () {
	  $$2('#CartNote').keydown(function (e) {
	    // Allow: backspace, delete, tab, escape and enter
	    if ($$2.inArray(e.keyCode, [46, 8, 9, 27, 13, 110]) !== -1 ||
	    // Allow: Ctrl+A
	    e.keyCode === 65 && e.ctrlKey === true ||
	    // Allow: home, end, left, right
	    e.keyCode >= 35 && e.keyCode <= 39) {
	      // let it happen, don't do anything
	      return;
	    }
	    // Ensure that it is a number and stop the keypress
	    if (e.altKey === true || e.keyCode === 220 || e.keyCode === 191 && e.shiftKey === false) {
	      e.preventDefault();
	    }
	  });
	});

	/**
	 * SSR Window 2.0.0
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2020, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: May 12, 2020
	 */
	/* eslint-disable no-param-reassign */
	function isObject(obj) {
	  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
	}
	function extend(target, src) {
	  if (target === void 0) {
	    target = {};
	  }
	  if (src === void 0) {
	    src = {};
	  }
	  Object.keys(src).forEach(function (key) {
	    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
	      extend(target[key], src[key]);
	    }
	  });
	}
	var doc$1 = typeof document !== 'undefined' ? document : {};
	var ssrDocument = {
	  body: {},
	  addEventListener: function () {},
	  removeEventListener: function () {},
	  activeElement: {
	    blur: function () {},
	    nodeName: ''
	  },
	  querySelector: function () {
	    return null;
	  },
	  querySelectorAll: function () {
	    return [];
	  },
	  getElementById: function () {
	    return null;
	  },
	  createEvent: function () {
	    return {
	      initEvent: function () {}
	    };
	  },
	  createElement: function () {
	    return {
	      children: [],
	      childNodes: [],
	      style: {},
	      setAttribute: function () {},
	      getElementsByTagName: function () {
	        return [];
	      }
	    };
	  },
	  createElementNS: function () {
	    return {};
	  },
	  importNode: function () {
	    return null;
	  },
	  location: {
	    hash: '',
	    host: '',
	    hostname: '',
	    href: '',
	    origin: '',
	    pathname: '',
	    protocol: '',
	    search: ''
	  }
	};
	extend(doc$1, ssrDocument);
	var win$1 = typeof window !== 'undefined' ? window : {};
	var ssrWindow = {
	  document: ssrDocument,
	  navigator: {
	    userAgent: ''
	  },
	  location: {
	    hash: '',
	    host: '',
	    hostname: '',
	    href: '',
	    origin: '',
	    pathname: '',
	    protocol: '',
	    search: ''
	  },
	  history: {
	    replaceState: function () {},
	    pushState: function () {},
	    go: function () {},
	    back: function () {}
	  },
	  CustomEvent: function CustomEvent() {
	    return this;
	  },
	  addEventListener: function () {},
	  removeEventListener: function () {},
	  getComputedStyle: function () {
	    return {
	      getPropertyValue: function () {
	        return '';
	      }
	    };
	  },
	  Image: function () {},
	  Date: function () {},
	  screen: {},
	  setTimeout: function () {},
	  clearTimeout: function () {},
	  matchMedia: function () {
	    return {};
	  }
	};
	extend(win$1, ssrWindow);

	/**
	 * Dom7 2.1.5
	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	 * http://framework7.io/docs/dom.html
	 *
	 * Copyright 2020, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 *
	 * Licensed under MIT
	 *
	 * Released on: May 15, 2020
	 */
	class Dom7 {
	  constructor(arr) {
	    const self = this;
	    // Create array-like object
	    for (let i = 0; i < arr.length; i += 1) {
	      self[i] = arr[i];
	    }
	    self.length = arr.length;
	    // Return collection with methods
	    return this;
	  }
	}
	function $$1(selector, context) {
	  const arr = [];
	  let i = 0;
	  if (selector && !context) {
	    if (selector instanceof Dom7) {
	      return selector;
	    }
	  }
	  if (selector) {
	    // String
	    if (typeof selector === 'string') {
	      let els;
	      let tempParent;
	      const html = selector.trim();
	      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	        let toCreate = 'div';
	        if (html.indexOf('<li') === 0) toCreate = 'ul';
	        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
	        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
	        if (html.indexOf('<tbody') === 0) toCreate = 'table';
	        if (html.indexOf('<option') === 0) toCreate = 'select';
	        tempParent = doc$1.createElement(toCreate);
	        tempParent.innerHTML = html;
	        for (i = 0; i < tempParent.childNodes.length; i += 1) {
	          arr.push(tempParent.childNodes[i]);
	        }
	      } else {
	        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	          // Pure ID selector
	          els = [doc$1.getElementById(selector.trim().split('#')[1])];
	        } else {
	          // Other selectors
	          els = (context || doc$1).querySelectorAll(selector.trim());
	        }
	        for (i = 0; i < els.length; i += 1) {
	          if (els[i]) arr.push(els[i]);
	        }
	      }
	    } else if (selector.nodeType || selector === win$1 || selector === doc$1) {
	      // Node/element
	      arr.push(selector);
	    } else if (selector.length > 0 && selector[0].nodeType) {
	      // Array of elements or instance of Dom
	      for (i = 0; i < selector.length; i += 1) {
	        arr.push(selector[i]);
	      }
	    }
	  }
	  return new Dom7(arr);
	}
	$$1.fn = Dom7.prototype;
	$$1.Class = Dom7;
	$$1.Dom7 = Dom7;
	function unique(arr) {
	  const uniqueArray = [];
	  for (let i = 0; i < arr.length; i += 1) {
	    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
	  }
	  return uniqueArray;
	}

	// Classes and attributes
	function addClass(className) {
	  if (typeof className === 'undefined') {
	    return this;
	  }
	  const classes = className.split(' ');
	  for (let i = 0; i < classes.length; i += 1) {
	    for (let j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
	    }
	  }
	  return this;
	}
	function removeClass(className) {
	  const classes = className.split(' ');
	  for (let i = 0; i < classes.length; i += 1) {
	    for (let j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
	    }
	  }
	  return this;
	}
	function hasClass(className) {
	  if (!this[0]) return false;
	  return this[0].classList.contains(className);
	}
	function toggleClass(className) {
	  const classes = className.split(' ');
	  for (let i = 0; i < classes.length; i += 1) {
	    for (let j = 0; j < this.length; j += 1) {
	      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
	    }
	  }
	  return this;
	}
	function attr(attrs, value) {
	  if (arguments.length === 1 && typeof attrs === 'string') {
	    // Get attr
	    if (this[0]) return this[0].getAttribute(attrs);
	    return undefined;
	  }

	  // Set attrs
	  for (let i = 0; i < this.length; i += 1) {
	    if (arguments.length === 2) {
	      // String
	      this[i].setAttribute(attrs, value);
	    } else {
	      // Object
	      // eslint-disable-next-line
	      for (const attrName in attrs) {
	        this[i][attrName] = attrs[attrName];
	        this[i].setAttribute(attrName, attrs[attrName]);
	      }
	    }
	  }
	  return this;
	}
	// eslint-disable-next-line
	function removeAttr(attr) {
	  for (let i = 0; i < this.length; i += 1) {
	    this[i].removeAttribute(attr);
	  }
	  return this;
	}
	function data(key, value) {
	  let el;
	  if (typeof value === 'undefined') {
	    el = this[0];
	    // Get value
	    if (el) {
	      if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
	        return el.dom7ElementDataStorage[key];
	      }
	      const dataKey = el.getAttribute(`data-${key}`);
	      if (dataKey) {
	        return dataKey;
	      }
	      return undefined;
	    }
	    return undefined;
	  }

	  // Set value
	  for (let i = 0; i < this.length; i += 1) {
	    el = this[i];
	    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
	    el.dom7ElementDataStorage[key] = value;
	  }
	  return this;
	}
	// Transforms
	// eslint-disable-next-line
	function transform(transform) {
	  for (let i = 0; i < this.length; i += 1) {
	    const elStyle = this[i].style;
	    elStyle.webkitTransform = transform;
	    elStyle.transform = transform;
	  }
	  return this;
	}
	function transition$1(duration) {
	  if (typeof duration !== 'string') {
	    duration = `${duration}ms`; // eslint-disable-line
	  }
	  for (let i = 0; i < this.length; i += 1) {
	    const elStyle = this[i].style;
	    elStyle.webkitTransitionDuration = duration;
	    elStyle.transitionDuration = duration;
	  }
	  return this;
	}
	// Events
	function on() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  let [eventType, targetSelector, listener, capture] = args;
	  if (typeof args[1] === 'function') {
	    [eventType, listener, capture] = args;
	    targetSelector = undefined;
	  }
	  if (!capture) capture = false;
	  function handleLiveEvent(e) {
	    const target = e.target;
	    if (!target) return;
	    const eventData = e.target.dom7EventData || [];
	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }
	    if ($$1(target).is(targetSelector)) listener.apply(target, eventData);else {
	      const parents = $$1(target).parents(); // eslint-disable-line
	      for (let k = 0; k < parents.length; k += 1) {
	        if ($$1(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
	      }
	    }
	  }
	  function handleEvent(e) {
	    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
	    if (eventData.indexOf(e) < 0) {
	      eventData.unshift(e);
	    }
	    listener.apply(this, eventData);
	  }
	  const events = eventType.split(' ');
	  let j;
	  for (let i = 0; i < this.length; i += 1) {
	    const el = this[i];
	    if (!targetSelector) {
	      for (j = 0; j < events.length; j += 1) {
	        const event = events[j];
	        if (!el.dom7Listeners) el.dom7Listeners = {};
	        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
	        el.dom7Listeners[event].push({
	          listener,
	          proxyListener: handleEvent
	        });
	        el.addEventListener(event, handleEvent, capture);
	      }
	    } else {
	      // Live events
	      for (j = 0; j < events.length; j += 1) {
	        const event = events[j];
	        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
	        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
	        el.dom7LiveListeners[event].push({
	          listener,
	          proxyListener: handleLiveEvent
	        });
	        el.addEventListener(event, handleLiveEvent, capture);
	      }
	    }
	  }
	  return this;
	}
	function off() {
	  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }
	  let [eventType, targetSelector, listener, capture] = args;
	  if (typeof args[1] === 'function') {
	    [eventType, listener, capture] = args;
	    targetSelector = undefined;
	  }
	  if (!capture) capture = false;
	  const events = eventType.split(' ');
	  for (let i = 0; i < events.length; i += 1) {
	    const event = events[i];
	    for (let j = 0; j < this.length; j += 1) {
	      const el = this[j];
	      let handlers;
	      if (!targetSelector && el.dom7Listeners) {
	        handlers = el.dom7Listeners[event];
	      } else if (targetSelector && el.dom7LiveListeners) {
	        handlers = el.dom7LiveListeners[event];
	      }
	      if (handlers && handlers.length) {
	        for (let k = handlers.length - 1; k >= 0; k -= 1) {
	          const handler = handlers[k];
	          if (listener && handler.listener === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          } else if (!listener) {
	            el.removeEventListener(event, handler.proxyListener, capture);
	            handlers.splice(k, 1);
	          }
	        }
	      }
	    }
	  }
	  return this;
	}
	function trigger() {
	  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    args[_key5] = arguments[_key5];
	  }
	  const events = args[0].split(' ');
	  const eventData = args[1];
	  for (let i = 0; i < events.length; i += 1) {
	    const event = events[i];
	    for (let j = 0; j < this.length; j += 1) {
	      const el = this[j];
	      let evt;
	      try {
	        evt = new win$1.CustomEvent(event, {
	          detail: eventData,
	          bubbles: true,
	          cancelable: true
	        });
	      } catch (e) {
	        evt = doc$1.createEvent('Event');
	        evt.initEvent(event, true, true);
	        evt.detail = eventData;
	      }
	      // eslint-disable-next-line
	      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
	      el.dispatchEvent(evt);
	      el.dom7EventData = [];
	      delete el.dom7EventData;
	    }
	  }
	  return this;
	}
	function transitionEnd$1(callback) {
	  const events = ['webkitTransitionEnd', 'transitionend'];
	  const dom = this;
	  let i;
	  function fireCallBack(e) {
	    /* jshint validthis:true */
	    if (e.target !== this) return;
	    callback.call(this, e);
	    for (i = 0; i < events.length; i += 1) {
	      dom.off(events[i], fireCallBack);
	    }
	  }
	  if (callback) {
	    for (i = 0; i < events.length; i += 1) {
	      dom.on(events[i], fireCallBack);
	    }
	  }
	  return this;
	}
	function outerWidth(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      const styles = this.styles();
	      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
	    }
	    return this[0].offsetWidth;
	  }
	  return null;
	}
	function outerHeight(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      const styles = this.styles();
	      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
	    }
	    return this[0].offsetHeight;
	  }
	  return null;
	}
	function offset() {
	  if (this.length > 0) {
	    const el = this[0];
	    const box = el.getBoundingClientRect();
	    const body = doc$1.body;
	    const clientTop = el.clientTop || body.clientTop || 0;
	    const clientLeft = el.clientLeft || body.clientLeft || 0;
	    const scrollTop = el === win$1 ? win$1.scrollY : el.scrollTop;
	    const scrollLeft = el === win$1 ? win$1.scrollX : el.scrollLeft;
	    return {
	      top: box.top + scrollTop - clientTop,
	      left: box.left + scrollLeft - clientLeft
	    };
	  }
	  return null;
	}
	function styles() {
	  if (this[0]) return win$1.getComputedStyle(this[0], null);
	  return {};
	}
	function css(props, value) {
	  let i;
	  if (arguments.length === 1) {
	    if (typeof props === 'string') {
	      if (this[0]) return win$1.getComputedStyle(this[0], null).getPropertyValue(props);
	    } else {
	      for (i = 0; i < this.length; i += 1) {
	        // eslint-disable-next-line
	        for (let prop in props) {
	          this[i].style[prop] = props[prop];
	        }
	      }
	      return this;
	    }
	  }
	  if (arguments.length === 2 && typeof props === 'string') {
	    for (i = 0; i < this.length; i += 1) {
	      this[i].style[props] = value;
	    }
	    return this;
	  }
	  return this;
	}
	// Iterate over the collection passing elements to `callback`
	function each(callback) {
	  // Don't bother continuing without a callback
	  if (!callback) return this;
	  // Iterate over the current collection
	  for (let i = 0; i < this.length; i += 1) {
	    // If the callback returns false
	    if (callback.call(this[i], i, this[i]) === false) {
	      // End the loop early
	      return this;
	    }
	  }
	  // Return `this` to allow chained DOM operations
	  return this;
	}
	// eslint-disable-next-line
	function html(html) {
	  if (typeof html === 'undefined') {
	    return this[0] ? this[0].innerHTML : undefined;
	  }
	  for (let i = 0; i < this.length; i += 1) {
	    this[i].innerHTML = html;
	  }
	  return this;
	}
	// eslint-disable-next-line
	function text(text) {
	  if (typeof text === 'undefined') {
	    if (this[0]) {
	      return this[0].textContent.trim();
	    }
	    return null;
	  }
	  for (let i = 0; i < this.length; i += 1) {
	    this[i].textContent = text;
	  }
	  return this;
	}
	function is(selector) {
	  const el = this[0];
	  let compareWith;
	  let i;
	  if (!el || typeof selector === 'undefined') return false;
	  if (typeof selector === 'string') {
	    if (el.matches) return el.matches(selector);else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
	    compareWith = $$1(selector);
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) return true;
	    }
	    return false;
	  } else if (selector === doc$1) return el === doc$1;else if (selector === win$1) return el === win$1;
	  if (selector.nodeType || selector instanceof Dom7) {
	    compareWith = selector.nodeType ? [selector] : selector;
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) return true;
	    }
	    return false;
	  }
	  return false;
	}
	function index() {
	  let child = this[0];
	  let i;
	  if (child) {
	    i = 0;
	    // eslint-disable-next-line
	    while ((child = child.previousSibling) !== null) {
	      if (child.nodeType === 1) i += 1;
	    }
	    return i;
	  }
	  return undefined;
	}
	// eslint-disable-next-line
	function eq(index) {
	  if (typeof index === 'undefined') return this;
	  const length = this.length;
	  let returnIndex;
	  if (index > length - 1) {
	    return new Dom7([]);
	  }
	  if (index < 0) {
	    returnIndex = length + index;
	    if (returnIndex < 0) return new Dom7([]);
	    return new Dom7([this[returnIndex]]);
	  }
	  return new Dom7([this[index]]);
	}
	function append() {
	  let newChild;
	  for (let k = 0; k < arguments.length; k += 1) {
	    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
	    for (let i = 0; i < this.length; i += 1) {
	      if (typeof newChild === 'string') {
	        const tempDiv = doc$1.createElement('div');
	        tempDiv.innerHTML = newChild;
	        while (tempDiv.firstChild) {
	          this[i].appendChild(tempDiv.firstChild);
	        }
	      } else if (newChild instanceof Dom7) {
	        for (let j = 0; j < newChild.length; j += 1) {
	          this[i].appendChild(newChild[j]);
	        }
	      } else {
	        this[i].appendChild(newChild);
	      }
	    }
	  }
	  return this;
	}
	function prepend(newChild) {
	  let i;
	  let j;
	  for (i = 0; i < this.length; i += 1) {
	    if (typeof newChild === 'string') {
	      const tempDiv = doc$1.createElement('div');
	      tempDiv.innerHTML = newChild;
	      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
	        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	      }
	    } else if (newChild instanceof Dom7) {
	      for (j = 0; j < newChild.length; j += 1) {
	        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	      }
	    } else {
	      this[i].insertBefore(newChild, this[i].childNodes[0]);
	    }
	  }
	  return this;
	}
	function next(selector) {
	  if (this.length > 0) {
	    if (selector) {
	      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
	        return new Dom7([this[0].nextElementSibling]);
	      }
	      return new Dom7([]);
	    }
	    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function nextAll(selector) {
	  const nextEls = [];
	  let el = this[0];
	  if (!el) return new Dom7([]);
	  while (el.nextElementSibling) {
	    const next = el.nextElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($$1(next).is(selector)) nextEls.push(next);
	    } else nextEls.push(next);
	    el = next;
	  }
	  return new Dom7(nextEls);
	}
	function prev(selector) {
	  if (this.length > 0) {
	    const el = this[0];
	    if (selector) {
	      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
	        return new Dom7([el.previousElementSibling]);
	      }
	      return new Dom7([]);
	    }
	    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function prevAll(selector) {
	  const prevEls = [];
	  let el = this[0];
	  if (!el) return new Dom7([]);
	  while (el.previousElementSibling) {
	    const prev = el.previousElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($$1(prev).is(selector)) prevEls.push(prev);
	    } else prevEls.push(prev);
	    el = prev;
	  }
	  return new Dom7(prevEls);
	}
	function parent(selector) {
	  const parents = []; // eslint-disable-line
	  for (let i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode !== null) {
	      if (selector) {
	        if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
	      } else {
	        parents.push(this[i].parentNode);
	      }
	    }
	  }
	  return $$1(unique(parents));
	}
	function parents(selector) {
	  const parents = []; // eslint-disable-line
	  for (let i = 0; i < this.length; i += 1) {
	    let parent = this[i].parentNode; // eslint-disable-line
	    while (parent) {
	      if (selector) {
	        if ($$1(parent).is(selector)) parents.push(parent);
	      } else {
	        parents.push(parent);
	      }
	      parent = parent.parentNode;
	    }
	  }
	  return $$1(unique(parents));
	}
	function closest(selector) {
	  let closest = this; // eslint-disable-line
	  if (typeof selector === 'undefined') {
	    return new Dom7([]);
	  }
	  if (!closest.is(selector)) {
	    closest = closest.parents(selector).eq(0);
	  }
	  return closest;
	}
	function find(selector) {
	  const foundElements = [];
	  for (let i = 0; i < this.length; i += 1) {
	    const found = this[i].querySelectorAll(selector);
	    for (let j = 0; j < found.length; j += 1) {
	      foundElements.push(found[j]);
	    }
	  }
	  return new Dom7(foundElements);
	}
	function children(selector) {
	  const children = []; // eslint-disable-line
	  for (let i = 0; i < this.length; i += 1) {
	    const childNodes = this[i].childNodes;
	    for (let j = 0; j < childNodes.length; j += 1) {
	      if (!selector) {
	        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
	      } else if (childNodes[j].nodeType === 1 && $$1(childNodes[j]).is(selector)) {
	        children.push(childNodes[j]);
	      }
	    }
	  }
	  return new Dom7(unique(children));
	}
	function remove() {
	  for (let i = 0; i < this.length; i += 1) {
	    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
	  }
	  return this;
	}
	function add() {
	  const dom = this;
	  let i;
	  let j;
	  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    args[_key6] = arguments[_key6];
	  }
	  for (i = 0; i < args.length; i += 1) {
	    const toAdd = $$1(args[i]);
	    for (j = 0; j < toAdd.length; j += 1) {
	      dom[dom.length] = toAdd[j];
	      dom.length += 1;
	    }
	  }
	  return dom;
	}

	/**
	 * SSR Window 1.0.1
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2018, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: July 18, 2018
	 */
	var doc = typeof document === 'undefined' ? {
	  body: {},
	  addEventListener: function addEventListener() {},
	  removeEventListener: function removeEventListener() {},
	  activeElement: {
	    blur: function blur() {},
	    nodeName: ''
	  },
	  querySelector: function querySelector() {
	    return null;
	  },
	  querySelectorAll: function querySelectorAll() {
	    return [];
	  },
	  getElementById: function getElementById() {
	    return null;
	  },
	  createEvent: function createEvent() {
	    return {
	      initEvent: function initEvent() {}
	    };
	  },
	  createElement: function createElement() {
	    return {
	      children: [],
	      childNodes: [],
	      style: {},
	      setAttribute: function setAttribute() {},
	      getElementsByTagName: function getElementsByTagName() {
	        return [];
	      }
	    };
	  },
	  location: {
	    hash: ''
	  }
	} : document; // eslint-disable-line

	var win = typeof window === 'undefined' ? {
	  document: doc,
	  navigator: {
	    userAgent: ''
	  },
	  location: {},
	  history: {},
	  CustomEvent: function CustomEvent() {
	    return this;
	  },
	  addEventListener: function addEventListener() {},
	  removeEventListener: function removeEventListener() {},
	  getComputedStyle: function getComputedStyle() {
	    return {
	      getPropertyValue: function getPropertyValue() {
	        return '';
	      }
	    };
	  },
	  Image: function Image() {},
	  Date: function Date() {},
	  screen: {},
	  setTimeout: function setTimeout() {},
	  clearTimeout: function clearTimeout() {}
	} : window; // eslint-disable-line

	/**
	 * Swiper 4.5.0
	 * Most modern mobile touch slider and framework with hardware accelerated transitions
	 * http://www.idangero.us/swiper/
	 *
	 * Copyright 2014-2019 Vladimir Kharlampidi
	 *
	 * Released under the MIT License
	 *
	 * Released on: February 22, 2019
	 */
	const Methods = {
	  addClass,
	  removeClass,
	  hasClass,
	  toggleClass,
	  attr,
	  removeAttr,
	  data,
	  transform,
	  transition: transition$1,
	  on,
	  off,
	  trigger,
	  transitionEnd: transitionEnd$1,
	  outerWidth,
	  outerHeight,
	  offset,
	  css,
	  each,
	  html,
	  text,
	  is,
	  index,
	  eq,
	  append,
	  prepend,
	  next,
	  nextAll,
	  prev,
	  prevAll,
	  parent,
	  parents,
	  closest,
	  find,
	  children,
	  remove,
	  add,
	  styles
	};
	Object.keys(Methods).forEach(methodName => {
	  $$1.fn[methodName] = Methods[methodName];
	});
	const Utils = {
	  deleteProps(obj) {
	    const object = obj;
	    Object.keys(object).forEach(key => {
	      try {
	        object[key] = null;
	      } catch (e) {
	        // no getter for object
	      }
	      try {
	        delete object[key];
	      } catch (e) {
	        // something got wrong
	      }
	    });
	  },
	  nextTick(callback) {
	    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    return setTimeout(callback, delay);
	  },
	  now() {
	    return Date.now();
	  },
	  getTranslate(el) {
	    let axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
	    let matrix;
	    let curTransform;
	    let transformMatrix;
	    const curStyle = win.getComputedStyle(el, null);
	    if (win.WebKitCSSMatrix) {
	      curTransform = curStyle.transform || curStyle.webkitTransform;
	      if (curTransform.split(',').length > 6) {
	        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
	      }
	      // Some old versions of Webkit choke when 'none' is passed; pass
	      // empty string instead in this case
	      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	    } else {
	      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	      matrix = transformMatrix.toString().split(',');
	    }
	    if (axis === 'x') {
	      // Latest Chrome and webkits Fix
	      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
	      // Normal Browsers
	      else curTransform = parseFloat(matrix[4]);
	    }
	    if (axis === 'y') {
	      // Latest Chrome and webkits Fix
	      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
	      // Normal Browsers
	      else curTransform = parseFloat(matrix[5]);
	    }
	    return curTransform || 0;
	  },
	  parseUrlQuery(url) {
	    const query = {};
	    let urlToParse = url || win.location.href;
	    let i;
	    let params;
	    let param;
	    let length;
	    if (typeof urlToParse === 'string' && urlToParse.length) {
	      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
	      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
	      length = params.length;
	      for (i = 0; i < length; i += 1) {
	        param = params[i].replace(/#\S+/g, '').split('=');
	        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
	      }
	    }
	    return query;
	  },
	  isObject(o) {
	    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	  },
	  extend() {
	    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
	    for (let i = 1; i < arguments.length; i += 1) {
	      const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
	      if (nextSource !== undefined && nextSource !== null) {
	        const keysArray = Object.keys(Object(nextSource));
	        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	          const nextKey = keysArray[nextIndex];
	          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (desc !== undefined && desc.enumerable) {
	            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              to[nextKey] = {};
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	    }
	    return to;
	  }
	};
	const Support = function Support() {
	  const testDiv = doc.createElement('div');
	  return {
	    touch: win.Modernizr && win.Modernizr.touch === true || function checkTouch() {
	      return !!(win.navigator.maxTouchPoints > 0 || 'ontouchstart' in win || win.DocumentTouch && doc instanceof win.DocumentTouch);
	    }(),
	    pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || 'maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints > 0),
	    prefixedPointerEvents: !!win.navigator.msPointerEnabled,
	    transition: function checkTransition() {
	      const style = testDiv.style;
	      return 'transition' in style || 'webkitTransition' in style || 'MozTransition' in style;
	    }(),
	    transforms3d: win.Modernizr && win.Modernizr.csstransforms3d === true || function checkTransforms3d() {
	      const style = testDiv.style;
	      return 'webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style;
	    }(),
	    flexbox: function checkFlexbox() {
	      const style = testDiv.style;
	      const styles = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');
	      for (let i = 0; i < styles.length; i += 1) {
	        if (styles[i] in style) return true;
	      }
	      return false;
	    }(),
	    observer: function checkObserver() {
	      return 'MutationObserver' in win || 'WebkitMutationObserver' in win;
	    }(),
	    passiveListener: function checkPassiveListener() {
	      let supportsPassive = false;
	      try {
	        const opts = Object.defineProperty({}, 'passive', {
	          // eslint-disable-next-line
	          get() {
	            supportsPassive = true;
	          }
	        });
	        win.addEventListener('testPassiveListener', null, opts);
	      } catch (e) {
	        // No support
	      }
	      return supportsPassive;
	    }(),
	    gestures: function checkGestures() {
	      return 'ongesturestart' in win;
	    }()
	  };
	}();
	const Browser = function Browser() {
	  function isSafari() {
	    const ua = win.navigator.userAgent.toLowerCase();
	    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
	  }
	  return {
	    isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
	    isEdge: !!win.navigator.userAgent.match(/Edge/g),
	    isSafari: isSafari(),
	    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
	  };
	}();
	class SwiperClass {
	  constructor() {
	    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    const self = this;
	    self.params = params;

	    // Events
	    self.eventsListeners = {};
	    if (self.params && self.params.on) {
	      Object.keys(self.params.on).forEach(eventName => {
	        self.on(eventName, self.params.on[eventName]);
	      });
	    }
	  }
	  on(events, handler, priority) {
	    const self = this;
	    if (typeof handler !== 'function') return self;
	    const method = priority ? 'unshift' : 'push';
	    events.split(' ').forEach(event => {
	      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
	      self.eventsListeners[event][method](handler);
	    });
	    return self;
	  }
	  once(events, handler, priority) {
	    const self = this;
	    if (typeof handler !== 'function') return self;
	    function onceHandler() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      handler.apply(self, args);
	      self.off(events, onceHandler);
	      if (onceHandler.f7proxy) {
	        delete onceHandler.f7proxy;
	      }
	    }
	    onceHandler.f7proxy = handler;
	    return self.on(events, onceHandler, priority);
	  }
	  off(events, handler) {
	    const self = this;
	    if (!self.eventsListeners) return self;
	    events.split(' ').forEach(event => {
	      if (typeof handler === 'undefined') {
	        self.eventsListeners[event] = [];
	      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
	        self.eventsListeners[event].forEach((eventHandler, index) => {
	          if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
	            self.eventsListeners[event].splice(index, 1);
	          }
	        });
	      }
	    });
	    return self;
	  }
	  emit() {
	    const self = this;
	    if (!self.eventsListeners) return self;
	    let events;
	    let data;
	    let context;
	    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }
	    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	      events = args[0];
	      data = args.slice(1, args.length);
	      context = self;
	    } else {
	      events = args[0].events;
	      data = args[0].data;
	      context = args[0].context || self;
	    }
	    const eventsArray = Array.isArray(events) ? events : events.split(' ');
	    eventsArray.forEach(event => {
	      if (self.eventsListeners && self.eventsListeners[event]) {
	        const handlers = [];
	        self.eventsListeners[event].forEach(eventHandler => {
	          handlers.push(eventHandler);
	        });
	        handlers.forEach(eventHandler => {
	          eventHandler.apply(context, data);
	        });
	      }
	    });
	    return self;
	  }
	  useModulesParams(instanceParams) {
	    const instance = this;
	    if (!instance.modules) return;
	    Object.keys(instance.modules).forEach(moduleName => {
	      const module = instance.modules[moduleName];
	      // Extend params
	      if (module.params) {
	        Utils.extend(instanceParams, module.params);
	      }
	    });
	  }
	  useModules() {
	    let modulesParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    const instance = this;
	    if (!instance.modules) return;
	    Object.keys(instance.modules).forEach(moduleName => {
	      const module = instance.modules[moduleName];
	      const moduleParams = modulesParams[moduleName] || {};
	      // Extend instance methods and props
	      if (module.instance) {
	        Object.keys(module.instance).forEach(modulePropName => {
	          const moduleProp = module.instance[modulePropName];
	          if (typeof moduleProp === 'function') {
	            instance[modulePropName] = moduleProp.bind(instance);
	          } else {
	            instance[modulePropName] = moduleProp;
	          }
	        });
	      }
	      // Add event listeners
	      if (module.on && instance.on) {
	        Object.keys(module.on).forEach(moduleEventName => {
	          instance.on(moduleEventName, module.on[moduleEventName]);
	        });
	      }

	      // Module create callback
	      if (module.create) {
	        module.create.bind(instance)(moduleParams);
	      }
	    });
	  }
	  static set components(components) {
	    const Class = this;
	    if (!Class.use) return;
	    Class.use(components);
	  }
	  static installModule(module) {
	    const Class = this;
	    if (!Class.prototype.modules) Class.prototype.modules = {};
	    const name = module.name || `${Object.keys(Class.prototype.modules).length}_${Utils.now()}`;
	    Class.prototype.modules[name] = module;
	    // Prototype
	    if (module.proto) {
	      Object.keys(module.proto).forEach(key => {
	        Class.prototype[key] = module.proto[key];
	      });
	    }
	    // Class
	    if (module.static) {
	      Object.keys(module.static).forEach(key => {
	        Class[key] = module.static[key];
	      });
	    }
	    // Callback
	    if (module.install) {
	      for (var _len3 = arguments.length, params = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	        params[_key3 - 1] = arguments[_key3];
	      }
	      module.install.apply(Class, params);
	    }
	    return Class;
	  }
	  static use(module) {
	    const Class = this;
	    if (Array.isArray(module)) {
	      module.forEach(m => Class.installModule(m));
	      return Class;
	    }
	    for (var _len4 = arguments.length, params = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	      params[_key4 - 1] = arguments[_key4];
	    }
	    return Class.installModule(module, ...params);
	  }
	}
	function updateSize() {
	  const swiper = this;
	  let width;
	  let height;
	  const $el = swiper.$el;
	  if (typeof swiper.params.width !== 'undefined') {
	    width = swiper.params.width;
	  } else {
	    width = $el[0].clientWidth;
	  }
	  if (typeof swiper.params.height !== 'undefined') {
	    height = swiper.params.height;
	  } else {
	    height = $el[0].clientHeight;
	  }
	  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
	    return;
	  }

	  // Subtract paddings
	  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
	  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
	  Utils.extend(swiper, {
	    width,
	    height,
	    size: swiper.isHorizontal() ? width : height
	  });
	}
	function updateSlides() {
	  const swiper = this;
	  const params = swiper.params;
	  const {
	    $wrapperEl,
	    size: swiperSize,
	    rtlTranslate: rtl,
	    wrongRTL
	  } = swiper;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
	  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
	  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	  let snapGrid = [];
	  const slidesGrid = [];
	  const slidesSizesGrid = [];
	  let offsetBefore = params.slidesOffsetBefore;
	  if (typeof offsetBefore === 'function') {
	    offsetBefore = params.slidesOffsetBefore.call(swiper);
	  }
	  let offsetAfter = params.slidesOffsetAfter;
	  if (typeof offsetAfter === 'function') {
	    offsetAfter = params.slidesOffsetAfter.call(swiper);
	  }
	  const previousSnapGridLength = swiper.snapGrid.length;
	  const previousSlidesGridLength = swiper.snapGrid.length;
	  let spaceBetween = params.spaceBetween;
	  let slidePosition = -offsetBefore;
	  let prevSlideSize = 0;
	  let index = 0;
	  if (typeof swiperSize === 'undefined') {
	    return;
	  }
	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
	  }
	  swiper.virtualSize = -spaceBetween;

	  // reset margins
	  if (rtl) slides.css({
	    marginLeft: '',
	    marginTop: ''
	  });else slides.css({
	    marginRight: '',
	    marginBottom: ''
	  });
	  let slidesNumberEvenToRows;
	  if (params.slidesPerColumn > 1) {
	    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
	      slidesNumberEvenToRows = slidesLength;
	    } else {
	      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
	    }
	    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
	      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
	    }
	  }

	  // Calc slides
	  let slideSize;
	  const slidesPerColumn = params.slidesPerColumn;
	  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
	  for (let i = 0; i < slidesLength; i += 1) {
	    slideSize = 0;
	    const slide = slides.eq(i);
	    if (params.slidesPerColumn > 1) {
	      // Set slides order
	      let newSlideOrderIndex;
	      let column;
	      let row;
	      if (params.slidesPerColumnFill === 'column') {
	        column = Math.floor(i / slidesPerColumn);
	        row = i - column * slidesPerColumn;
	        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
	          row += 1;
	          if (row >= slidesPerColumn) {
	            row = 0;
	            column += 1;
	          }
	        }
	        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
	        slide.css({
	          '-webkit-box-ordinal-group': newSlideOrderIndex,
	          '-moz-box-ordinal-group': newSlideOrderIndex,
	          '-ms-flex-order': newSlideOrderIndex,
	          '-webkit-order': newSlideOrderIndex,
	          order: newSlideOrderIndex
	        });
	      } else {
	        row = Math.floor(i / slidesPerRow);
	        column = i - row * slidesPerRow;
	      }
	      slide.css(`margin-${swiper.isHorizontal() ? 'top' : 'left'}`, row !== 0 && params.spaceBetween && `${params.spaceBetween}px`).attr('data-swiper-column', column).attr('data-swiper-row', row);
	    }
	    if (slide.css('display') === 'none') continue; // eslint-disable-line

	    if (params.slidesPerView === 'auto') {
	      const slideStyles = win.getComputedStyle(slide[0], null);
	      const currentTransform = slide[0].style.transform;
	      const currentWebKitTransform = slide[0].style.webkitTransform;
	      if (currentTransform) {
	        slide[0].style.transform = 'none';
	      }
	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = 'none';
	      }
	      if (params.roundLengths) {
	        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
	      } else {
	        // eslint-disable-next-line
	        if (swiper.isHorizontal()) {
	          const width = parseFloat(slideStyles.getPropertyValue('width'));
	          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
	          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
	          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
	          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
	          const boxSizing = slideStyles.getPropertyValue('box-sizing');
	          if (boxSizing && boxSizing === 'border-box') {
	            slideSize = width + marginLeft + marginRight;
	          } else {
	            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
	          }
	        } else {
	          const height = parseFloat(slideStyles.getPropertyValue('height'));
	          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
	          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
	          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
	          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
	          const boxSizing = slideStyles.getPropertyValue('box-sizing');
	          if (boxSizing && boxSizing === 'border-box') {
	            slideSize = height + marginTop + marginBottom;
	          } else {
	            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
	          }
	        }
	      }
	      if (currentTransform) {
	        slide[0].style.transform = currentTransform;
	      }
	      if (currentWebKitTransform) {
	        slide[0].style.webkitTransform = currentWebKitTransform;
	      }
	      if (params.roundLengths) slideSize = Math.floor(slideSize);
	    } else {
	      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
	      if (params.roundLengths) slideSize = Math.floor(slideSize);
	      if (slides[i]) {
	        if (swiper.isHorizontal()) {
	          slides[i].style.width = `${slideSize}px`;
	        } else {
	          slides[i].style.height = `${slideSize}px`;
	        }
	      }
	    }
	    if (slides[i]) {
	      slides[i].swiperSlideSize = slideSize;
	    }
	    slidesSizesGrid.push(slideSize);
	    if (params.centeredSlides) {
	      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
	      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	    } else {
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	      slidePosition = slidePosition + slideSize + spaceBetween;
	    }
	    swiper.virtualSize += slideSize + spaceBetween;
	    prevSlideSize = slideSize;
	    index += 1;
	  }
	  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	  let newSlidesGrid;
	  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	    $wrapperEl.css({
	      width: `${swiper.virtualSize + params.spaceBetween}px`
	    });
	  }
	  if (!Support.flexbox || params.setWrapperSize) {
	    if (swiper.isHorizontal()) $wrapperEl.css({
	      width: `${swiper.virtualSize + params.spaceBetween}px`
	    });else $wrapperEl.css({
	      height: `${swiper.virtualSize + params.spaceBetween}px`
	    });
	  }
	  if (params.slidesPerColumn > 1) {
	    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
	    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
	    if (swiper.isHorizontal()) $wrapperEl.css({
	      width: `${swiper.virtualSize + params.spaceBetween}px`
	    });else $wrapperEl.css({
	      height: `${swiper.virtualSize + params.spaceBetween}px`
	    });
	    if (params.centeredSlides) {
	      newSlidesGrid = [];
	      for (let i = 0; i < snapGrid.length; i += 1) {
	        let slidesGridItem = snapGrid[i];
	        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
	        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
	      }
	      snapGrid = newSlidesGrid;
	    }
	  }

	  // Remove last grid elements depending on width
	  if (!params.centeredSlides) {
	    newSlidesGrid = [];
	    for (let i = 0; i < snapGrid.length; i += 1) {
	      let slidesGridItem = snapGrid[i];
	      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
	      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
	        newSlidesGrid.push(slidesGridItem);
	      }
	    }
	    snapGrid = newSlidesGrid;
	    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	      snapGrid.push(swiper.virtualSize - swiperSize);
	    }
	  }
	  if (snapGrid.length === 0) snapGrid = [0];
	  if (params.spaceBetween !== 0) {
	    if (swiper.isHorizontal()) {
	      if (rtl) slides.css({
	        marginLeft: `${spaceBetween}px`
	      });else slides.css({
	        marginRight: `${spaceBetween}px`
	      });
	    } else slides.css({
	      marginBottom: `${spaceBetween}px`
	    });
	  }
	  if (params.centerInsufficientSlides) {
	    let allSlidesSize = 0;
	    slidesSizesGrid.forEach(slideSizeValue => {
	      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
	    });
	    allSlidesSize -= params.spaceBetween;
	    if (allSlidesSize < swiperSize) {
	      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
	      snapGrid.forEach((snap, snapIndex) => {
	        snapGrid[snapIndex] = snap - allSlidesOffset;
	      });
	      slidesGrid.forEach((snap, snapIndex) => {
	        slidesGrid[snapIndex] = snap + allSlidesOffset;
	      });
	    }
	  }
	  Utils.extend(swiper, {
	    slides,
	    snapGrid,
	    slidesGrid,
	    slidesSizesGrid
	  });
	  if (slidesLength !== previousSlidesLength) {
	    swiper.emit('slidesLengthChange');
	  }
	  if (snapGrid.length !== previousSnapGridLength) {
	    if (swiper.params.watchOverflow) swiper.checkOverflow();
	    swiper.emit('snapGridLengthChange');
	  }
	  if (slidesGrid.length !== previousSlidesGridLength) {
	    swiper.emit('slidesGridLengthChange');
	  }
	  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateSlidesOffset();
	  }
	}
	function updateAutoHeight(speed) {
	  const swiper = this;
	  const activeSlides = [];
	  let newHeight = 0;
	  let i;
	  if (typeof speed === 'number') {
	    swiper.setTransition(speed);
	  } else if (speed === true) {
	    swiper.setTransition(swiper.params.speed);
	  }
	  // Find slides currently in view
	  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	      const index = swiper.activeIndex + i;
	      if (index > swiper.slides.length) break;
	      activeSlides.push(swiper.slides.eq(index)[0]);
	    }
	  } else {
	    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
	  }

	  // Find new height from highest slide in view
	  for (i = 0; i < activeSlides.length; i += 1) {
	    if (typeof activeSlides[i] !== 'undefined') {
	      const height = activeSlides[i].offsetHeight;
	      newHeight = height > newHeight ? height : newHeight;
	    }
	  }

	  // Update Height
	  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
	}
	function updateSlidesOffset() {
	  const swiper = this;
	  const slides = swiper.slides;
	  for (let i = 0; i < slides.length; i += 1) {
	    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
	  }
	}
	function updateSlidesProgress() {
	  let translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;
	  const swiper = this;
	  const params = swiper.params;
	  const {
	    slides,
	    rtlTranslate: rtl
	  } = swiper;
	  if (slides.length === 0) return;
	  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
	  let offsetCenter = -translate;
	  if (rtl) offsetCenter = translate;

	  // Visible Slides
	  slides.removeClass(params.slideVisibleClass);
	  swiper.visibleSlidesIndexes = [];
	  swiper.visibleSlides = [];
	  for (let i = 0; i < slides.length; i += 1) {
	    const slide = slides[i];
	    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
	    if (params.watchSlidesVisibility) {
	      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	      const isVisible = slideBefore >= 0 && slideBefore < swiper.size || slideAfter > 0 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
	      if (isVisible) {
	        swiper.visibleSlides.push(slide);
	        swiper.visibleSlidesIndexes.push(i);
	        slides.eq(i).addClass(params.slideVisibleClass);
	      }
	    }
	    slide.progress = rtl ? -slideProgress : slideProgress;
	  }
	  swiper.visibleSlides = $$1(swiper.visibleSlides);
	}
	function updateProgress() {
	  let translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;
	  const swiper = this;
	  const params = swiper.params;
	  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  let {
	    progress,
	    isBeginning,
	    isEnd
	  } = swiper;
	  const wasBeginning = isBeginning;
	  const wasEnd = isEnd;
	  if (translatesDiff === 0) {
	    progress = 0;
	    isBeginning = true;
	    isEnd = true;
	  } else {
	    progress = (translate - swiper.minTranslate()) / translatesDiff;
	    isBeginning = progress <= 0;
	    isEnd = progress >= 1;
	  }
	  Utils.extend(swiper, {
	    progress,
	    isBeginning,
	    isEnd
	  });
	  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);
	  if (isBeginning && !wasBeginning) {
	    swiper.emit('reachBeginning toEdge');
	  }
	  if (isEnd && !wasEnd) {
	    swiper.emit('reachEnd toEdge');
	  }
	  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
	    swiper.emit('fromEdge');
	  }
	  swiper.emit('progress', progress);
	}
	function updateSlidesClasses() {
	  const swiper = this;
	  const {
	    slides,
	    params,
	    $wrapperEl,
	    activeIndex,
	    realIndex
	  } = swiper;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
	  let activeSlide;
	  if (isVirtual) {
	    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
	  } else {
	    activeSlide = slides.eq(activeIndex);
	  }

	  // Active classes
	  activeSlide.addClass(params.slideActiveClass);
	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (activeSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
	    } else {
	      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
	    }
	  }
	  // Next Slide
	  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
	  if (params.loop && nextSlide.length === 0) {
	    nextSlide = slides.eq(0);
	    nextSlide.addClass(params.slideNextClass);
	  }
	  // Prev Slide
	  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
	  if (params.loop && prevSlide.length === 0) {
	    prevSlide = slides.eq(-1);
	    prevSlide.addClass(params.slidePrevClass);
	  }
	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (nextSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
	    } else {
	      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
	    }
	    if (prevSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
	    } else {
	      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
	    }
	  }
	}
	function updateActiveIndex(newActiveIndex) {
	  const swiper = this;
	  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  const {
	    slidesGrid,
	    snapGrid,
	    params,
	    activeIndex: previousIndex,
	    realIndex: previousRealIndex,
	    snapIndex: previousSnapIndex
	  } = swiper;
	  let activeIndex = newActiveIndex;
	  let snapIndex;
	  if (typeof activeIndex === 'undefined') {
	    for (let i = 0; i < slidesGrid.length; i += 1) {
	      if (typeof slidesGrid[i + 1] !== 'undefined') {
	        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
	          activeIndex = i;
	        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	          activeIndex = i + 1;
	        }
	      } else if (translate >= slidesGrid[i]) {
	        activeIndex = i;
	      }
	    }
	    // Normalize slideIndex
	    if (params.normalizeSlideIndex) {
	      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
	    }
	  }
	  if (snapGrid.indexOf(translate) >= 0) {
	    snapIndex = snapGrid.indexOf(translate);
	  } else {
	    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
	  }
	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
	  if (activeIndex === previousIndex) {
	    if (snapIndex !== previousSnapIndex) {
	      swiper.snapIndex = snapIndex;
	      swiper.emit('snapIndexChange');
	    }
	    return;
	  }

	  // Get real index
	  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
	  Utils.extend(swiper, {
	    snapIndex,
	    realIndex,
	    previousIndex,
	    activeIndex
	  });
	  swiper.emit('activeIndexChange');
	  swiper.emit('snapIndexChange');
	  if (previousRealIndex !== realIndex) {
	    swiper.emit('realIndexChange');
	  }
	  swiper.emit('slideChange');
	}
	function updateClickedSlide(e) {
	  const swiper = this;
	  const params = swiper.params;
	  const slide = $$1(e.target).closest(`.${params.slideClass}`)[0];
	  let slideFound = false;
	  if (slide) {
	    for (let i = 0; i < swiper.slides.length; i += 1) {
	      if (swiper.slides[i] === slide) slideFound = true;
	    }
	  }
	  if (slide && slideFound) {
	    swiper.clickedSlide = slide;
	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);
	    } else {
	      swiper.clickedIndex = $$1(slide).index();
	    }
	  } else {
	    swiper.clickedSlide = undefined;
	    swiper.clickedIndex = undefined;
	    return;
	  }
	  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	    swiper.slideToClickedSlide();
	  }
	}
	var update = {
	  updateSize,
	  updateSlides,
	  updateAutoHeight,
	  updateSlidesOffset,
	  updateSlidesProgress,
	  updateProgress,
	  updateSlidesClasses,
	  updateActiveIndex,
	  updateClickedSlide
	};
	function getTranslate() {
	  let axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isHorizontal() ? 'x' : 'y';
	  const swiper = this;
	  const {
	    params,
	    rtlTranslate: rtl,
	    translate,
	    $wrapperEl
	  } = swiper;
	  if (params.virtualTranslate) {
	    return rtl ? -translate : translate;
	  }
	  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
	  if (rtl) currentTranslate = -currentTranslate;
	  return currentTranslate || 0;
	}
	function setTranslate(translate, byController) {
	  const swiper = this;
	  const {
	    rtlTranslate: rtl,
	    params,
	    $wrapperEl,
	    progress
	  } = swiper;
	  let x = 0;
	  let y = 0;
	  const z = 0;
	  if (swiper.isHorizontal()) {
	    x = rtl ? -translate : translate;
	  } else {
	    y = translate;
	  }
	  if (params.roundLengths) {
	    x = Math.floor(x);
	    y = Math.floor(y);
	  }
	  if (!params.virtualTranslate) {
	    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
	  }
	  swiper.previousTranslate = swiper.translate;
	  swiper.translate = swiper.isHorizontal() ? x : y;

	  // Check if we need to update progress
	  let newProgress;
	  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
	  }
	  if (newProgress !== progress) {
	    swiper.updateProgress(translate);
	  }
	  swiper.emit('setTranslate', swiper.translate, byController);
	}
	function minTranslate() {
	  return -this.snapGrid[0];
	}
	function maxTranslate() {
	  return -this.snapGrid[this.snapGrid.length - 1];
	}
	var translate = {
	  getTranslate,
	  setTranslate,
	  minTranslate,
	  maxTranslate
	};
	function setTransition(duration, byController) {
	  const swiper = this;
	  swiper.$wrapperEl.transition(duration);
	  swiper.emit('setTransition', duration, byController);
	}
	function transitionStart() {
	  let runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	  let direction = arguments.length > 1 ? arguments[1] : undefined;
	  const swiper = this;
	  const {
	    activeIndex,
	    params,
	    previousIndex
	  } = swiper;
	  if (params.autoHeight) {
	    swiper.updateAutoHeight();
	  }
	  let dir = direction;
	  if (!dir) {
	    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
	  }
	  swiper.emit('transitionStart');
	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionStart');
	      return;
	    }
	    swiper.emit('slideChangeTransitionStart');
	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionStart');
	    } else {
	      swiper.emit('slidePrevTransitionStart');
	    }
	  }
	}
	function transitionEnd() {
	  let runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	  let direction = arguments.length > 1 ? arguments[1] : undefined;
	  const swiper = this;
	  const {
	    activeIndex,
	    previousIndex
	  } = swiper;
	  swiper.animating = false;
	  swiper.setTransition(0);
	  let dir = direction;
	  if (!dir) {
	    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
	  }
	  swiper.emit('transitionEnd');
	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit('slideResetTransitionEnd');
	      return;
	    }
	    swiper.emit('slideChangeTransitionEnd');
	    if (dir === 'next') {
	      swiper.emit('slideNextTransitionEnd');
	    } else {
	      swiper.emit('slidePrevTransitionEnd');
	    }
	  }
	}
	var transition = {
	  setTransition,
	  transitionStart,
	  transitionEnd
	};
	function slideTo() {
	  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
	  let runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  let internal = arguments.length > 3 ? arguments[3] : undefined;
	  const swiper = this;
	  let slideIndex = index;
	  if (slideIndex < 0) slideIndex = 0;
	  const {
	    params,
	    snapGrid,
	    slidesGrid,
	    previousIndex,
	    activeIndex,
	    rtlTranslate: rtl
	  } = swiper;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return false;
	  }
	  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
	  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
	    swiper.emit('beforeSlideChangeStart');
	  }
	  const translate = -snapGrid[snapIndex];

	  // Update progress
	  swiper.updateProgress(translate);

	  // Normalize slideIndex
	  if (params.normalizeSlideIndex) {
	    for (let i = 0; i < slidesGrid.length; i += 1) {
	      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
	        slideIndex = i;
	      }
	    }
	  }
	  // Directions locks
	  if (swiper.initialized && slideIndex !== activeIndex) {
	    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
	      return false;
	    }
	    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	      if ((activeIndex || 0) !== slideIndex) return false;
	    }
	  }
	  let direction;
	  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

	  // Update Index
	  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
	    swiper.updateActiveIndex(slideIndex);
	    // Update Height
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	    swiper.updateSlidesClasses();
	    if (params.effect !== 'slide') {
	      swiper.setTranslate(translate);
	    }
	    if (direction !== 'reset') {
	      swiper.transitionStart(runCallbacks, direction);
	      swiper.transitionEnd(runCallbacks, direction);
	    }
	    return false;
	  }
	  if (speed === 0 || !Support.transition) {
	    swiper.setTransition(0);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);
	    swiper.transitionEnd(runCallbacks, direction);
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks, direction);
	    if (!swiper.animating) {
	      swiper.animating = true;
	      if (!swiper.onSlideToWrapperTransitionEnd) {
	        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
	          if (!swiper || swiper.destroyed) return;
	          if (e.target !== this) return;
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	          swiper.onSlideToWrapperTransitionEnd = null;
	          delete swiper.onSlideToWrapperTransitionEnd;
	          swiper.transitionEnd(runCallbacks, direction);
	        };
	      }
	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	    }
	  }
	  return true;
	}
	function slideToLoop() {
	  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
	  let runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  let internal = arguments.length > 3 ? arguments[3] : undefined;
	  const swiper = this;
	  let newIndex = index;
	  if (swiper.params.loop) {
	    newIndex += swiper.loopedSlides;
	  }
	  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideNext() {
	  let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
	  let runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  let internal = arguments.length > 2 ? arguments[2] : undefined;
	  const swiper = this;
	  const {
	    params,
	    animating
	  } = swiper;
	  if (params.loop) {
	    if (animating) return false;
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	  }
	  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slidePrev() {
	  let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
	  let runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  let internal = arguments.length > 2 ? arguments[2] : undefined;
	  const swiper = this;
	  const {
	    params,
	    animating,
	    snapGrid,
	    slidesGrid,
	    rtlTranslate
	  } = swiper;
	  if (params.loop) {
	    if (animating) return false;
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	  }
	  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
	  function normalize(val) {
	    if (val < 0) return -Math.floor(Math.abs(val));
	    return Math.floor(val);
	  }
	  const normalizedTranslate = normalize(translate);
	  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
	  slidesGrid.map(val => normalize(val));
	  snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
	  const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
	  let prevIndex;
	  if (typeof prevSnap !== 'undefined') {
	    prevIndex = slidesGrid.indexOf(prevSnap);
	    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
	  }
	  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideReset() {
	  let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
	  let runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  let internal = arguments.length > 2 ? arguments[2] : undefined;
	  const swiper = this;
	  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideToClosest() {
	  let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
	  let runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  let internal = arguments.length > 2 ? arguments[2] : undefined;
	  const swiper = this;
	  let index = swiper.activeIndex;
	  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);
	  if (snapIndex < swiper.snapGrid.length - 1) {
	    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	    const currentSnap = swiper.snapGrid[snapIndex];
	    const nextSnap = swiper.snapGrid[snapIndex + 1];
	    if (translate - currentSnap > (nextSnap - currentSnap) / 2) {
	      index = swiper.params.slidesPerGroup;
	    }
	  }
	  return swiper.slideTo(index, speed, runCallbacks, internal);
	}
	function slideToClickedSlide() {
	  const swiper = this;
	  const {
	    params,
	    $wrapperEl
	  } = swiper;
	  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	  let slideToIndex = swiper.clickedIndex;
	  let realIndex;
	  if (params.loop) {
	    if (swiper.animating) return;
	    realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	    if (params.centeredSlides) {
	      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
	        swiper.loopFix();
	        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
	        Utils.nextTick(() => {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	      swiper.loopFix();
	      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
	      Utils.nextTick(() => {
	        swiper.slideTo(slideToIndex);
	      });
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  } else {
	    swiper.slideTo(slideToIndex);
	  }
	}
	var slide = {
	  slideTo,
	  slideToLoop,
	  slideNext,
	  slidePrev,
	  slideReset,
	  slideToClosest,
	  slideToClickedSlide
	};
	function loopCreate() {
	  const swiper = this;
	  const {
	    params,
	    $wrapperEl
	  } = swiper;
	  // Remove duplicated slides
	  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
	  let slides = $wrapperEl.children(`.${params.slideClass}`);
	  if (params.loopFillGroupWithBlank) {
	    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
	    if (blankSlidesNum !== params.slidesPerGroup) {
	      for (let i = 0; i < blankSlidesNum; i += 1) {
	        const blankNode = $$1(doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
	        $wrapperEl.append(blankNode);
	      }
	      slides = $wrapperEl.children(`.${params.slideClass}`);
	    }
	  }
	  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
	  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
	  swiper.loopedSlides += params.loopAdditionalSlides;
	  if (swiper.loopedSlides > slides.length) {
	    swiper.loopedSlides = slides.length;
	  }
	  const prependSlides = [];
	  const appendSlides = [];
	  slides.each((index, el) => {
	    const slide = $$1(el);
	    if (index < swiper.loopedSlides) appendSlides.push(el);
	    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
	    slide.attr('data-swiper-slide-index', index);
	  });
	  for (let i = 0; i < appendSlides.length; i += 1) {
	    $wrapperEl.append($$1(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
	    $wrapperEl.prepend($$1(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	}
	function loopFix() {
	  const swiper = this;
	  const {
	    params,
	    activeIndex,
	    slides,
	    loopedSlides,
	    allowSlidePrev,
	    allowSlideNext,
	    snapGrid,
	    rtlTranslate: rtl
	  } = swiper;
	  let newIndex;
	  swiper.allowSlidePrev = true;
	  swiper.allowSlideNext = true;
	  const snapTranslate = -snapGrid[activeIndex];
	  const diff = snapTranslate - swiper.getTranslate();

	  // Fix For Negative Oversliding
	  if (activeIndex < loopedSlides) {
	    newIndex = slides.length - loopedSlides * 3 + activeIndex;
	    newIndex += loopedSlides;
	    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
	    if (slideChanged && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  } else if (params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2 || activeIndex >= slides.length - loopedSlides) {
	    // Fix For Positive Oversliding
	    newIndex = -slides.length + activeIndex + loopedSlides;
	    newIndex += loopedSlides;
	    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
	    if (slideChanged && diff !== 0) {
	      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	    }
	  }
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	}
	function loopDestroy() {
	  const swiper = this;
	  const {
	    $wrapperEl,
	    params,
	    slides
	  } = swiper;
	  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
	  slides.removeAttr('data-swiper-slide-index');
	}
	var loop = {
	  loopCreate,
	  loopFix,
	  loopDestroy
	};
	function setGrabCursor(moving) {
	  const swiper = this;
	  if (Support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked) return;
	  const el = swiper.el;
	  el.style.cursor = 'move';
	  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	  el.style.cursor = moving ? 'grabbing' : 'grab';
	}
	function unsetGrabCursor() {
	  const swiper = this;
	  if (Support.touch || swiper.params.watchOverflow && swiper.isLocked) return;
	  swiper.el.style.cursor = '';
	}
	var grabCursor = {
	  setGrabCursor,
	  unsetGrabCursor
	};
	function appendSlide(slides) {
	  const swiper = this;
	  const {
	    $wrapperEl,
	    params
	  } = swiper;
	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (let i = 0; i < slides.length; i += 1) {
	      if (slides[i]) $wrapperEl.append(slides[i]);
	    }
	  } else {
	    $wrapperEl.append(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	}
	function prependSlide(slides) {
	  const swiper = this;
	  const {
	    params,
	    $wrapperEl,
	    activeIndex
	  } = swiper;
	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  let newActiveIndex = activeIndex + 1;
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (let i = 0; i < slides.length; i += 1) {
	      if (slides[i]) $wrapperEl.prepend(slides[i]);
	    }
	    newActiveIndex = activeIndex + slides.length;
	  } else {
	    $wrapperEl.prepend(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  swiper.slideTo(newActiveIndex, 0, false);
	}
	function addSlide(index, slides) {
	  const swiper = this;
	  const {
	    $wrapperEl,
	    params,
	    activeIndex
	  } = swiper;
	  let activeIndexBuffer = activeIndex;
	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
	  }
	  const baseLength = swiper.slides.length;
	  if (index <= 0) {
	    swiper.prependSlide(slides);
	    return;
	  }
	  if (index >= baseLength) {
	    swiper.appendSlide(slides);
	    return;
	  }
	  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
	  const slidesBuffer = [];
	  for (let i = baseLength - 1; i >= index; i -= 1) {
	    const currentSlide = swiper.slides.eq(i);
	    currentSlide.remove();
	    slidesBuffer.unshift(currentSlide);
	  }
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (let i = 0; i < slides.length; i += 1) {
	      if (slides[i]) $wrapperEl.append(slides[i]);
	    }
	    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
	  } else {
	    $wrapperEl.append(slides);
	  }
	  for (let i = 0; i < slidesBuffer.length; i += 1) {
	    $wrapperEl.append(slidesBuffer[i]);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}
	function removeSlide(slidesIndexes) {
	  const swiper = this;
	  const {
	    params,
	    $wrapperEl,
	    activeIndex
	  } = swiper;
	  let activeIndexBuffer = activeIndex;
	  if (params.loop) {
	    activeIndexBuffer -= swiper.loopedSlides;
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
	  }
	  let newActiveIndex = activeIndexBuffer;
	  let indexToRemove;
	  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
	    for (let i = 0; i < slidesIndexes.length; i += 1) {
	      indexToRemove = slidesIndexes[i];
	      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
	      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
	    }
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  } else {
	    indexToRemove = slidesIndexes;
	    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
	    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	}
	function removeAllSlides() {
	  const swiper = this;
	  const slidesIndexes = [];
	  for (let i = 0; i < swiper.slides.length; i += 1) {
	    slidesIndexes.push(i);
	  }
	  swiper.removeSlide(slidesIndexes);
	}
	var manipulation = {
	  appendSlide,
	  prependSlide,
	  addSlide,
	  removeSlide,
	  removeAllSlides
	};
	const Device = function Device() {
	  const ua = win.navigator.userAgent;
	  const device = {
	    ios: false,
	    android: false,
	    androidChrome: false,
	    desktop: false,
	    windows: false,
	    iphone: false,
	    ipod: false,
	    ipad: false,
	    cordova: win.cordova || win.phonegap,
	    phonegap: win.cordova || win.phonegap
	  };
	  const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);

	  // Windows
	  if (windows) {
	    device.os = 'windows';
	    device.osVersion = windows[2];
	    device.windows = true;
	  }
	  // Android
	  if (android && !windows) {
	    device.os = 'android';
	    device.osVersion = android[2];
	    device.android = true;
	    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
	  }
	  if (ipad || iphone || ipod) {
	    device.os = 'ios';
	    device.ios = true;
	  }
	  // iOS
	  if (iphone && !ipod) {
	    device.osVersion = iphone[2].replace(/_/g, '.');
	    device.iphone = true;
	  }
	  if (ipad) {
	    device.osVersion = ipad[2].replace(/_/g, '.');
	    device.ipad = true;
	  }
	  if (ipod) {
	    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	    device.iphone = true;
	  }
	  // iOS 8+ changed UA
	  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
	    if (device.osVersion.split('.')[0] === '10') {
	      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
	    }
	  }

	  // Desktop
	  device.desktop = !(device.os || device.android || device.webView);

	  // Webview
	  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

	  // Minimal UI
	  if (device.os && device.os === 'ios') {
	    const osVersionArr = device.osVersion.split('.');
	    const metaViewport = doc.querySelector('meta[name="viewport"]');
	    device.minimalUi = !device.webView && (ipod || iphone) && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
	  }

	  // Pixel Ratio
	  device.pixelRatio = win.devicePixelRatio || 1;

	  // Export object
	  return device;
	}();
	function onTouchStart(event) {
	  const swiper = this;
	  const data = swiper.touchEventsData;
	  const {
	    params,
	    touches
	  } = swiper;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return;
	  }
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  data.isTouchEvent = e.type === 'touchstart';
	  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
	  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
	  if (data.isTouched && data.isMoved) return;
	  if (params.noSwiping && $$1(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
	    swiper.allowClick = true;
	    return;
	  }
	  if (params.swipeHandler) {
	    if (!$$1(e).closest(params.swipeHandler)[0]) return;
	  }
	  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  const startX = touches.currentX;
	  const startY = touches.currentY;

	  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

	  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
	  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
	  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
	    return;
	  }
	  Utils.extend(data, {
	    isTouched: true,
	    isMoved: false,
	    allowTouchCallbacks: true,
	    isScrolling: undefined,
	    startMoving: undefined
	  });
	  touches.startX = startX;
	  touches.startY = startY;
	  data.touchStartTime = Utils.now();
	  swiper.allowClick = true;
	  swiper.updateSize();
	  swiper.swipeDirection = undefined;
	  if (params.threshold > 0) data.allowThresholdMove = false;
	  if (e.type !== 'touchstart') {
	    let preventDefault = true;
	    if ($$1(e.target).is(data.formElements)) preventDefault = false;
	    if (doc.activeElement && $$1(doc.activeElement).is(data.formElements) && doc.activeElement !== e.target) {
	      doc.activeElement.blur();
	    }
	    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
	    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
	      e.preventDefault();
	    }
	  }
	  swiper.emit('touchStart', e);
	}
	function onTouchMove(event) {
	  const swiper = this;
	  const data = swiper.touchEventsData;
	  const {
	    params,
	    touches,
	    rtlTranslate: rtl
	  } = swiper;
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  if (!data.isTouched) {
	    if (data.startMoving && data.isScrolling) {
	      swiper.emit('touchMoveOpposite', e);
	    }
	    return;
	  }
	  if (data.isTouchEvent && e.type === 'mousemove') return;
	  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	  if (e.preventedByNestedSwiper) {
	    touches.startX = pageX;
	    touches.startY = pageY;
	    return;
	  }
	  if (!swiper.allowTouchMove) {
	    // isMoved = true;
	    swiper.allowClick = false;
	    if (data.isTouched) {
	      Utils.extend(touches, {
	        startX: pageX,
	        startY: pageY,
	        currentX: pageX,
	        currentY: pageY
	      });
	      data.touchStartTime = Utils.now();
	    }
	    return;
	  }
	  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
	    if (swiper.isVertical()) {
	      // Vertical
	      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
	        data.isTouched = false;
	        data.isMoved = false;
	        return;
	      }
	    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
	      return;
	    }
	  }
	  if (data.isTouchEvent && doc.activeElement) {
	    if (e.target === doc.activeElement && $$1(e.target).is(data.formElements)) {
	      data.isMoved = true;
	      swiper.allowClick = false;
	      return;
	    }
	  }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchMove', e);
	  }
	  if (e.targetTouches && e.targetTouches.length > 1) return;
	  touches.currentX = pageX;
	  touches.currentY = pageY;
	  const diffX = touches.currentX - touches.startX;
	  const diffY = touches.currentY - touches.startY;
	  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
	  if (typeof data.isScrolling === 'undefined') {
	    let touchAngle;
	    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
	      data.isScrolling = false;
	    } else {
	      // eslint-disable-next-line
	      if (diffX * diffX + diffY * diffY >= 25) {
	        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
	        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
	      }
	    }
	  }
	  if (data.isScrolling) {
	    swiper.emit('touchMoveOpposite', e);
	  }
	  if (typeof data.startMoving === 'undefined') {
	    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	      data.startMoving = true;
	    }
	  }
	  if (data.isScrolling) {
	    data.isTouched = false;
	    return;
	  }
	  if (!data.startMoving) {
	    return;
	  }
	  swiper.allowClick = false;
	  e.preventDefault();
	  if (params.touchMoveStopPropagation && !params.nested) {
	    e.stopPropagation();
	  }
	  if (!data.isMoved) {
	    if (params.loop) {
	      swiper.loopFix();
	    }
	    data.startTranslate = swiper.getTranslate();
	    swiper.setTransition(0);
	    if (swiper.animating) {
	      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
	    }
	    data.allowMomentumBounce = false;
	    // Grab Cursor
	    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(true);
	    }
	    swiper.emit('sliderFirstMove', e);
	  }
	  swiper.emit('sliderMove', e);
	  data.isMoved = true;
	  let diff = swiper.isHorizontal() ? diffX : diffY;
	  touches.diff = diff;
	  diff *= params.touchRatio;
	  if (rtl) diff = -diff;
	  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	  data.currentTranslate = diff + data.startTranslate;
	  let disableParentSwiper = true;
	  let resistanceRatio = params.resistanceRatio;
	  if (params.touchReleaseOnEdges) {
	    resistanceRatio = 0;
	  }
	  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
	  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
	  }
	  if (disableParentSwiper) {
	    e.preventedByNestedSwiper = true;
	  }

	  // Directions locks
	  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }
	  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }

	  // Threshold
	  if (params.threshold > 0) {
	    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	      if (!data.allowThresholdMove) {
	        data.allowThresholdMove = true;
	        touches.startX = touches.currentX;
	        touches.startY = touches.currentY;
	        data.currentTranslate = data.startTranslate;
	        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	        return;
	      }
	    } else {
	      data.currentTranslate = data.startTranslate;
	      return;
	    }
	  }
	  if (!params.followFinger) return;

	  // Update active index in free mode
	  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  if (params.freeMode) {
	    // Velocity
	    if (data.velocities.length === 0) {
	      data.velocities.push({
	        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
	        time: data.touchStartTime
	      });
	    }
	    data.velocities.push({
	      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
	      time: Utils.now()
	    });
	  }
	  // Update progress
	  swiper.updateProgress(data.currentTranslate);
	  // Update translate
	  swiper.setTranslate(data.currentTranslate);
	}
	function onTouchEnd(event) {
	  const swiper = this;
	  const data = swiper.touchEventsData;
	  const {
	    params,
	    touches,
	    rtlTranslate: rtl,
	    $wrapperEl,
	    slidesGrid,
	    snapGrid
	  } = swiper;
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchEnd', e);
	  }
	  data.allowTouchCallbacks = false;
	  if (!data.isTouched) {
	    if (data.isMoved && params.grabCursor) {
	      swiper.setGrabCursor(false);
	    }
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  // Return Grab Cursor
	  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	    swiper.setGrabCursor(false);
	  }

	  // Time diff
	  const touchEndTime = Utils.now();
	  const timeDiff = touchEndTime - data.touchStartTime;

	  // Tap, doubleTap, Click
	  if (swiper.allowClick) {
	    swiper.updateClickedSlide(e);
	    swiper.emit('tap', e);
	    if (timeDiff < 300 && touchEndTime - data.lastClickTime > 300) {
	      if (data.clickTimeout) clearTimeout(data.clickTimeout);
	      data.clickTimeout = Utils.nextTick(() => {
	        if (!swiper || swiper.destroyed) return;
	        swiper.emit('click', e);
	      }, 300);
	    }
	    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
	      if (data.clickTimeout) clearTimeout(data.clickTimeout);
	      swiper.emit('doubleTap', e);
	    }
	  }
	  data.lastClickTime = Utils.now();
	  Utils.nextTick(() => {
	    if (!swiper.destroyed) swiper.allowClick = true;
	  });
	  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	    data.isTouched = false;
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  data.isTouched = false;
	  data.isMoved = false;
	  data.startMoving = false;
	  let currentPos;
	  if (params.followFinger) {
	    currentPos = rtl ? swiper.translate : -swiper.translate;
	  } else {
	    currentPos = -data.currentTranslate;
	  }
	  if (params.freeMode) {
	    if (currentPos < -swiper.minTranslate()) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (currentPos > -swiper.maxTranslate()) {
	      if (swiper.slides.length < snapGrid.length) {
	        swiper.slideTo(snapGrid.length - 1);
	      } else {
	        swiper.slideTo(swiper.slides.length - 1);
	      }
	      return;
	    }
	    if (params.freeModeMomentum) {
	      if (data.velocities.length > 1) {
	        const lastMoveEvent = data.velocities.pop();
	        const velocityEvent = data.velocities.pop();
	        const distance = lastMoveEvent.position - velocityEvent.position;
	        const time = lastMoveEvent.time - velocityEvent.time;
	        swiper.velocity = distance / time;
	        swiper.velocity /= 2;
	        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
	          swiper.velocity = 0;
	        }
	        // this implies that the user stopped moving a finger then released.
	        // There would be no events with distance zero, so the last event is stale.
	        if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
	          swiper.velocity = 0;
	        }
	      } else {
	        swiper.velocity = 0;
	      }
	      swiper.velocity *= params.freeModeMomentumVelocityRatio;
	      data.velocities.length = 0;
	      let momentumDuration = 1000 * params.freeModeMomentumRatio;
	      const momentumDistance = swiper.velocity * momentumDuration;
	      let newPosition = swiper.translate + momentumDistance;
	      if (rtl) newPosition = -newPosition;
	      let doBounce = false;
	      let afterBouncePosition;
	      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
	      let needsLoopFix;
	      if (newPosition < swiper.maxTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
	            newPosition = swiper.maxTranslate() - bounceAmount;
	          }
	          afterBouncePosition = swiper.maxTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.maxTranslate();
	        }
	        if (params.loop && params.centeredSlides) needsLoopFix = true;
	      } else if (newPosition > swiper.minTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition - swiper.minTranslate() > bounceAmount) {
	            newPosition = swiper.minTranslate() + bounceAmount;
	          }
	          afterBouncePosition = swiper.minTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.minTranslate();
	        }
	        if (params.loop && params.centeredSlides) needsLoopFix = true;
	      } else if (params.freeModeSticky) {
	        let nextSlide;
	        for (let j = 0; j < snapGrid.length; j += 1) {
	          if (snapGrid[j] > -newPosition) {
	            nextSlide = j;
	            break;
	          }
	        }
	        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
	          newPosition = snapGrid[nextSlide];
	        } else {
	          newPosition = snapGrid[nextSlide - 1];
	        }
	        newPosition = -newPosition;
	      }
	      if (needsLoopFix) {
	        swiper.once('transitionEnd', () => {
	          swiper.loopFix();
	        });
	      }
	      // Fix duration
	      if (swiper.velocity !== 0) {
	        if (rtl) {
	          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
	        } else {
	          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
	        }
	      } else if (params.freeModeSticky) {
	        swiper.slideToClosest();
	        return;
	      }
	      if (params.freeModeMomentumBounce && doBounce) {
	        swiper.updateProgress(afterBouncePosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);
	        swiper.animating = true;
	        $wrapperEl.transitionEnd(() => {
	          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
	          swiper.emit('momentumBounce');
	          swiper.setTransition(params.speed);
	          swiper.setTranslate(afterBouncePosition);
	          $wrapperEl.transitionEnd(() => {
	            if (!swiper || swiper.destroyed) return;
	            swiper.transitionEnd();
	          });
	        });
	      } else if (swiper.velocity) {
	        swiper.updateProgress(newPosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart(true, swiper.swipeDirection);
	        if (!swiper.animating) {
	          swiper.animating = true;
	          $wrapperEl.transitionEnd(() => {
	            if (!swiper || swiper.destroyed) return;
	            swiper.transitionEnd();
	          });
	        }
	      } else {
	        swiper.updateProgress(newPosition);
	      }
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    } else if (params.freeModeSticky) {
	      swiper.slideToClosest();
	      return;
	    }
	    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
	      swiper.updateProgress();
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    return;
	  }

	  // Find current slide
	  let stopIndex = 0;
	  let groupSize = swiper.slidesSizesGrid[0];
	  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
	    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
	      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
	        stopIndex = i;
	        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
	      }
	    } else if (currentPos >= slidesGrid[i]) {
	      stopIndex = i;
	      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	    }
	  }

	  // Find current slide size
	  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
	  if (timeDiff > params.longSwipesMs) {
	    // Long touches
	    if (!params.longSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);else swiper.slideTo(stopIndex);
	    }
	    if (swiper.swipeDirection === 'prev') {
	      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);else swiper.slideTo(stopIndex);
	    }
	  } else {
	    // Short swipes
	    if (!params.shortSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      swiper.slideTo(stopIndex + params.slidesPerGroup);
	    }
	    if (swiper.swipeDirection === 'prev') {
	      swiper.slideTo(stopIndex);
	    }
	  }
	}
	function onResize() {
	  const swiper = this;
	  const {
	    params,
	    el
	  } = swiper;
	  if (el && el.offsetWidth === 0) return;

	  // Breakpoints
	  if (params.breakpoints) {
	    swiper.setBreakpoint();
	  }

	  // Save locks
	  const {
	    allowSlideNext,
	    allowSlidePrev,
	    snapGrid
	  } = swiper;

	  // Disable locks on resize
	  swiper.allowSlideNext = true;
	  swiper.allowSlidePrev = true;
	  swiper.updateSize();
	  swiper.updateSlides();
	  if (params.freeMode) {
	    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
	    swiper.setTranslate(newTranslate);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	  } else {
	    swiper.updateSlidesClasses();
	    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	    } else {
	      swiper.slideTo(swiper.activeIndex, 0, false, true);
	    }
	  }
	  // Return locks after resize
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
	    swiper.checkOverflow();
	  }
	}
	function onClick(e) {
	  const swiper = this;
	  if (!swiper.allowClick) {
	    if (swiper.params.preventClicks) e.preventDefault();
	    if (swiper.params.preventClicksPropagation && swiper.animating) {
	      e.stopPropagation();
	      e.stopImmediatePropagation();
	    }
	  }
	}
	function attachEvents() {
	  const swiper = this;
	  const {
	    params,
	    touchEvents,
	    el,
	    wrapperEl
	  } = swiper;
	  {
	    swiper.onTouchStart = onTouchStart.bind(swiper);
	    swiper.onTouchMove = onTouchMove.bind(swiper);
	    swiper.onTouchEnd = onTouchEnd.bind(swiper);
	  }
	  swiper.onClick = onClick.bind(swiper);
	  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  const capture = !!params.nested;

	  // Touch Events
	  {
	    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
	      doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
	          passive: true,
	          capture: false
	        } : false;
	        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
	          passive: false,
	          capture
	        } : capture);
	        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
	        target.addEventListener('mousedown', swiper.onTouchStart, false);
	        doc.addEventListener('mousemove', swiper.onTouchMove, capture);
	        doc.addEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.addEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.on(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
	}
	function detachEvents() {
	  const swiper = this;
	  const {
	    params,
	    touchEvents,
	    el,
	    wrapperEl
	  } = swiper;
	  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  const capture = !!params.nested;

	  // Touch Events
	  {
	    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
	      doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
	          passive: true,
	          capture: false
	        } : false;
	        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
	        target.removeEventListener('mousedown', swiper.onTouchStart, false);
	        doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
	        doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.removeEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.off(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
	}
	var events = {
	  attachEvents,
	  detachEvents
	};
	function setBreakpoint() {
	  const swiper = this;
	  const {
	    activeIndex,
	    initialized,
	    loopedSlides = 0,
	    params
	  } = swiper;
	  const breakpoints = params.breakpoints;
	  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

	  // Set breakpoint for window width and update parameters
	  const breakpoint = swiper.getBreakpoint(breakpoints);
	  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
	    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
	    if (breakpointOnlyParams) {
	      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(param => {
	        const paramValue = breakpointOnlyParams[param];
	        if (typeof paramValue === 'undefined') return;
	        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
	          breakpointOnlyParams[param] = 'auto';
	        } else if (param === 'slidesPerView') {
	          breakpointOnlyParams[param] = parseFloat(paramValue);
	        } else {
	          breakpointOnlyParams[param] = parseInt(paramValue, 10);
	        }
	      });
	    }
	    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
	    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
	    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
	    if (directionChanged && initialized) {
	      swiper.changeDirection();
	    }
	    Utils.extend(swiper.params, breakpointParams);
	    Utils.extend(swiper, {
	      allowTouchMove: swiper.params.allowTouchMove,
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev
	    });
	    swiper.currentBreakpoint = breakpoint;
	    if (needsReLoop && initialized) {
	      swiper.loopDestroy();
	      swiper.loopCreate();
	      swiper.updateSlides();
	      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
	    }
	    swiper.emit('breakpoint', breakpointParams);
	  }
	}
	function getBreakpoint(breakpoints) {
	  const swiper = this;
	  // Get breakpoint for window width
	  if (!breakpoints) return undefined;
	  let breakpoint = false;
	  const points = [];
	  Object.keys(breakpoints).forEach(point => {
	    points.push(point);
	  });
	  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
	  for (let i = 0; i < points.length; i += 1) {
	    const point = points[i];
	    if (swiper.params.breakpointsInverse) {
	      if (point <= win.innerWidth) {
	        breakpoint = point;
	      }
	    } else if (point >= win.innerWidth && !breakpoint) {
	      breakpoint = point;
	    }
	  }
	  return breakpoint || 'max';
	}
	var breakpoints = {
	  setBreakpoint,
	  getBreakpoint
	};
	function addClasses() {
	  const swiper = this;
	  const {
	    classNames,
	    params,
	    rtl,
	    $el
	  } = swiper;
	  const suffixes = [];
	  suffixes.push('initialized');
	  suffixes.push(params.direction);
	  if (params.freeMode) {
	    suffixes.push('free-mode');
	  }
	  if (!Support.flexbox) {
	    suffixes.push('no-flexbox');
	  }
	  if (params.autoHeight) {
	    suffixes.push('autoheight');
	  }
	  if (rtl) {
	    suffixes.push('rtl');
	  }
	  if (params.slidesPerColumn > 1) {
	    suffixes.push('multirow');
	  }
	  if (Device.android) {
	    suffixes.push('android');
	  }
	  if (Device.ios) {
	    suffixes.push('ios');
	  }
	  // WP8 Touch Events Fix
	  if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	    suffixes.push(`wp8-${params.direction}`);
	  }
	  suffixes.forEach(suffix => {
	    classNames.push(params.containerModifierClass + suffix);
	  });
	  $el.addClass(classNames.join(' '));
	}
	function removeClasses() {
	  const swiper = this;
	  const {
	    $el,
	    classNames
	  } = swiper;
	  $el.removeClass(classNames.join(' '));
	}
	var classes$3 = {
	  addClasses,
	  removeClasses
	};
	function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
	  let image;
	  function onReady() {
	    if (callback) callback();
	  }
	  if (!imageEl.complete || !checkForComplete) {
	    if (src) {
	      image = new win.Image();
	      image.onload = onReady;
	      image.onerror = onReady;
	      if (sizes) {
	        image.sizes = sizes;
	      }
	      if (srcset) {
	        image.srcset = srcset;
	      }
	      if (src) {
	        image.src = src;
	      }
	    } else {
	      onReady();
	    }
	  } else {
	    // image already loaded...
	    onReady();
	  }
	}
	function preloadImages() {
	  const swiper = this;
	  swiper.imagesToLoad = swiper.$el.find('img');
	  function onReady() {
	    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
	    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
	    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
	      if (swiper.params.updateOnImagesReady) swiper.update();
	      swiper.emit('imagesReady');
	    }
	  }
	  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
	    const imageEl = swiper.imagesToLoad[i];
	    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
	  }
	}
	var images = {
	  loadImage,
	  preloadImages
	};
	function checkOverflow() {
	  const swiper = this;
	  const wasLocked = swiper.isLocked;
	  swiper.isLocked = swiper.snapGrid.length === 1;
	  swiper.allowSlideNext = !swiper.isLocked;
	  swiper.allowSlidePrev = !swiper.isLocked;

	  // events
	  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
	  if (wasLocked && wasLocked !== swiper.isLocked) {
	    swiper.isEnd = false;
	    swiper.navigation.update();
	  }
	}
	var checkOverflow$1 = {
	  checkOverflow
	};
	var defaults = {
	  init: true,
	  direction: 'horizontal',
	  touchEventsTarget: 'container',
	  initialSlide: 0,
	  speed: 300,
	  //
	  preventInteractionOnTransition: false,
	  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	  edgeSwipeDetection: false,
	  edgeSwipeThreshold: 20,
	  // Free mode
	  freeMode: false,
	  freeModeMomentum: true,
	  freeModeMomentumRatio: 1,
	  freeModeMomentumBounce: true,
	  freeModeMomentumBounceRatio: 1,
	  freeModeMomentumVelocityRatio: 1,
	  freeModeSticky: false,
	  freeModeMinimumVelocity: 0.02,
	  // Autoheight
	  autoHeight: false,
	  // Set wrapper width
	  setWrapperSize: false,
	  // Virtual Translate
	  virtualTranslate: false,
	  // Effects
	  effect: 'slide',
	  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

	  // Breakpoints
	  breakpoints: undefined,
	  breakpointsInverse: false,
	  // Slides grid
	  spaceBetween: 0,
	  slidesPerView: 1,
	  slidesPerColumn: 1,
	  slidesPerColumnFill: 'column',
	  slidesPerGroup: 1,
	  centeredSlides: false,
	  slidesOffsetBefore: 0,
	  // in px
	  slidesOffsetAfter: 0,
	  // in px
	  normalizeSlideIndex: true,
	  centerInsufficientSlides: false,
	  // Disable swiper and hide navigation when container not overflow
	  watchOverflow: false,
	  // Round length
	  roundLengths: false,
	  // Touches
	  touchRatio: 1,
	  touchAngle: 45,
	  simulateTouch: true,
	  shortSwipes: true,
	  longSwipes: true,
	  longSwipesRatio: 0.5,
	  longSwipesMs: 300,
	  followFinger: true,
	  allowTouchMove: true,
	  threshold: 0,
	  touchMoveStopPropagation: true,
	  touchStartPreventDefault: true,
	  touchStartForcePreventDefault: false,
	  touchReleaseOnEdges: false,
	  // Unique Navigation Elements
	  uniqueNavElements: true,
	  // Resistance
	  resistance: true,
	  resistanceRatio: 0.85,
	  // Progress
	  watchSlidesProgress: false,
	  watchSlidesVisibility: false,
	  // Cursor
	  grabCursor: false,
	  // Clicks
	  preventClicks: true,
	  preventClicksPropagation: true,
	  slideToClickedSlide: false,
	  // Images
	  preloadImages: true,
	  updateOnImagesReady: true,
	  // loop
	  loop: false,
	  loopAdditionalSlides: 0,
	  loopedSlides: null,
	  loopFillGroupWithBlank: false,
	  // Swiping/no swiping
	  allowSlidePrev: true,
	  allowSlideNext: true,
	  swipeHandler: null,
	  // '.swipe-handler',
	  noSwiping: true,
	  noSwipingClass: 'swiper-no-swiping',
	  noSwipingSelector: null,
	  // Passive Listeners
	  passiveListeners: true,
	  // NS
	  containerModifierClass: 'swiper-container-',
	  // NEW
	  slideClass: 'swiper-slide',
	  slideBlankClass: 'swiper-slide-invisible-blank',
	  slideActiveClass: 'swiper-slide-active',
	  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	  slideVisibleClass: 'swiper-slide-visible',
	  slideDuplicateClass: 'swiper-slide-duplicate',
	  slideNextClass: 'swiper-slide-next',
	  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	  slidePrevClass: 'swiper-slide-prev',
	  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	  wrapperClass: 'swiper-wrapper',
	  // Callbacks
	  runCallbacksOnInit: true
	};

	/* eslint no-param-reassign: "off" */

	const prototypes = {
	  update,
	  translate,
	  transition,
	  slide,
	  loop,
	  grabCursor,
	  manipulation,
	  events,
	  breakpoints,
	  checkOverflow: checkOverflow$1,
	  classes: classes$3,
	  images
	};
	const extendedDefaults = {};
	class Swiper extends SwiperClass {
	  constructor() {
	    let el;
	    let params;
	    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      args[_key5] = arguments[_key5];
	    }
	    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
	      params = args[0];
	    } else {
	      [el, params] = args;
	    }
	    if (!params) params = {};
	    params = Utils.extend({}, params);
	    if (el && !params.el) params.el = el;
	    super(params);
	    Object.keys(prototypes).forEach(prototypeGroup => {
	      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
	        if (!Swiper.prototype[protoMethod]) {
	          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	        }
	      });
	    });

	    // Swiper Instance
	    const swiper = this;
	    if (typeof swiper.modules === 'undefined') {
	      swiper.modules = {};
	    }
	    Object.keys(swiper.modules).forEach(moduleName => {
	      const module = swiper.modules[moduleName];
	      if (module.params) {
	        const moduleParamName = Object.keys(module.params)[0];
	        const moduleParams = module.params[moduleParamName];
	        if (typeof moduleParams !== 'object' || moduleParams === null) return;
	        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
	        if (params[moduleParamName] === true) {
	          params[moduleParamName] = {
	            enabled: true
	          };
	        }
	        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
	          params[moduleParamName].enabled = true;
	        }
	        if (!params[moduleParamName]) params[moduleParamName] = {
	          enabled: false
	        };
	      }
	    });

	    // Extend defaults with modules params
	    const swiperParams = Utils.extend({}, defaults);
	    swiper.useModulesParams(swiperParams);

	    // Extend defaults with passed params
	    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
	    swiper.originalParams = Utils.extend({}, swiper.params);
	    swiper.passedParams = Utils.extend({}, params);

	    // Save Dom lib
	    swiper.$ = $$1;

	    // Find el
	    const $el = $$1(swiper.params.el);
	    el = $el[0];
	    if (!el) {
	      return undefined;
	    }
	    if ($el.length > 1) {
	      const swipers = [];
	      $el.each((index, containerEl) => {
	        const newParams = Utils.extend({}, params, {
	          el: containerEl
	        });
	        swipers.push(new Swiper(newParams));
	      });
	      return swipers;
	    }
	    el.swiper = swiper;
	    $el.data('swiper', swiper);

	    // Find Wrapper
	    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);

	    // Extend Swiper
	    Utils.extend(swiper, {
	      $el,
	      el,
	      $wrapperEl,
	      wrapperEl: $wrapperEl[0],
	      // Classes
	      classNames: [],
	      // Slides
	      slides: $$1(),
	      slidesGrid: [],
	      snapGrid: [],
	      slidesSizesGrid: [],
	      // isDirection
	      isHorizontal() {
	        return swiper.params.direction === 'horizontal';
	      },
	      isVertical() {
	        return swiper.params.direction === 'vertical';
	      },
	      // RTL
	      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
	      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	      wrongRTL: $wrapperEl.css('display') === '-webkit-box',
	      // Indexes
	      activeIndex: 0,
	      realIndex: 0,
	      //
	      isBeginning: true,
	      isEnd: false,
	      // Props
	      translate: 0,
	      previousTranslate: 0,
	      progress: 0,
	      velocity: 0,
	      animating: false,
	      // Locks
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,
	      // Touch Events
	      touchEvents: function touchEvents() {
	        const touch = ['touchstart', 'touchmove', 'touchend'];
	        let desktop = ['mousedown', 'mousemove', 'mouseup'];
	        if (Support.pointerEvents) {
	          desktop = ['pointerdown', 'pointermove', 'pointerup'];
	        } else if (Support.prefixedPointerEvents) {
	          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
	        }
	        swiper.touchEventsTouch = {
	          start: touch[0],
	          move: touch[1],
	          end: touch[2]
	        };
	        swiper.touchEventsDesktop = {
	          start: desktop[0],
	          move: desktop[1],
	          end: desktop[2]
	        };
	        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
	      }(),
	      touchEventsData: {
	        isTouched: undefined,
	        isMoved: undefined,
	        allowTouchCallbacks: undefined,
	        touchStartTime: undefined,
	        isScrolling: undefined,
	        currentTranslate: undefined,
	        startTranslate: undefined,
	        allowThresholdMove: undefined,
	        // Form elements to match
	        formElements: 'input, select, option, textarea, button, video',
	        // Last click time
	        lastClickTime: Utils.now(),
	        clickTimeout: undefined,
	        // Velocities
	        velocities: [],
	        allowMomentumBounce: undefined,
	        isTouchEvent: undefined,
	        startMoving: undefined
	      },
	      // Clicks
	      allowClick: true,
	      // Touches
	      allowTouchMove: swiper.params.allowTouchMove,
	      touches: {
	        startX: 0,
	        startY: 0,
	        currentX: 0,
	        currentY: 0,
	        diff: 0
	      },
	      // Images
	      imagesToLoad: [],
	      imagesLoaded: 0
	    });

	    // Install Modules
	    swiper.useModules();

	    // Init
	    if (swiper.params.init) {
	      swiper.init();
	    }

	    // Return app instance
	    return swiper;
	  }
	  slidesPerViewDynamic() {
	    const swiper = this;
	    const {
	      params,
	      slides,
	      slidesGrid,
	      size: swiperSize,
	      activeIndex
	    } = swiper;
	    let spv = 1;
	    if (params.centeredSlides) {
	      let slideSize = slides[activeIndex].swiperSlideSize;
	      let breakLoop;
	      for (let i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }
	      for (let i = activeIndex - 1; i >= 0; i -= 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }
	    } else {
	      for (let i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
	          spv += 1;
	        }
	      }
	    }
	    return spv;
	  }
	  update() {
	    const swiper = this;
	    if (!swiper || swiper.destroyed) return;
	    const {
	      snapGrid,
	      params
	    } = swiper;
	    // Breakpoints
	    if (params.breakpoints) {
	      swiper.setBreakpoint();
	    }
	    swiper.updateSize();
	    swiper.updateSlides();
	    swiper.updateProgress();
	    swiper.updateSlidesClasses();
	    function setTranslate() {
	      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
	      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    let translated;
	    if (swiper.params.freeMode) {
	      setTranslate();
	      if (swiper.params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	      } else {
	        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }
	      if (!translated) {
	        setTranslate();
	      }
	    }
	    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
	      swiper.checkOverflow();
	    }
	    swiper.emit('update');
	  }
	  changeDirection(newDirection) {
	    let needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    const swiper = this;
	    const currentDirection = swiper.params.direction;
	    if (!newDirection) {
	      // eslint-disable-next-line
	      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
	    }
	    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
	      return swiper;
	    }
	    if (currentDirection === 'vertical') {
	      swiper.$el.removeClass(`${swiper.params.containerModifierClass}vertical wp8-vertical`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
	      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);
	      }
	    }
	    if (currentDirection === 'horizontal') {
	      swiper.$el.removeClass(`${swiper.params.containerModifierClass}horizontal wp8-horizontal`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
	      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);
	      }
	    }
	    swiper.params.direction = newDirection;
	    swiper.slides.each((slideIndex, slideEl) => {
	      if (newDirection === 'vertical') {
	        slideEl.style.width = '';
	      } else {
	        slideEl.style.height = '';
	      }
	    });
	    swiper.emit('changeDirection');
	    if (needUpdate) swiper.update();
	    return swiper;
	  }
	  init() {
	    const swiper = this;
	    if (swiper.initialized) return;
	    swiper.emit('beforeInit');

	    // Set breakpoint
	    if (swiper.params.breakpoints) {
	      swiper.setBreakpoint();
	    }

	    // Add Classes
	    swiper.addClasses();

	    // Create loop
	    if (swiper.params.loop) {
	      swiper.loopCreate();
	    }

	    // Update size
	    swiper.updateSize();

	    // Update slides
	    swiper.updateSlides();
	    if (swiper.params.watchOverflow) {
	      swiper.checkOverflow();
	    }

	    // Set Grab Cursor
	    if (swiper.params.grabCursor) {
	      swiper.setGrabCursor();
	    }
	    if (swiper.params.preloadImages) {
	      swiper.preloadImages();
	    }

	    // Slide To Initial Slide
	    if (swiper.params.loop) {
	      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
	    } else {
	      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
	    }

	    // Attach events
	    swiper.attachEvents();

	    // Init Flag
	    swiper.initialized = true;

	    // Emit
	    swiper.emit('init');
	  }
	  destroy() {
	    let deleteInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    let cleanStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    const swiper = this;
	    const {
	      params,
	      $el,
	      $wrapperEl,
	      slides
	    } = swiper;
	    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
	      return null;
	    }
	    swiper.emit('beforeDestroy');

	    // Init Flag
	    swiper.initialized = false;

	    // Detach events
	    swiper.detachEvents();

	    // Destroy loop
	    if (params.loop) {
	      swiper.loopDestroy();
	    }

	    // Cleanup styles
	    if (cleanStyles) {
	      swiper.removeClasses();
	      $el.removeAttr('style');
	      $wrapperEl.removeAttr('style');
	      if (slides && slides.length) {
	        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
	      }
	    }
	    swiper.emit('destroy');

	    // Detach emitter events
	    Object.keys(swiper.eventsListeners).forEach(eventName => {
	      swiper.off(eventName);
	    });
	    if (deleteInstance !== false) {
	      swiper.$el[0].swiper = null;
	      swiper.$el.data('swiper', null);
	      Utils.deleteProps(swiper);
	    }
	    swiper.destroyed = true;
	    return null;
	  }
	  static extendDefaults(newDefaults) {
	    Utils.extend(extendedDefaults, newDefaults);
	  }
	  static get extendedDefaults() {
	    return extendedDefaults;
	  }
	  static get defaults() {
	    return defaults;
	  }
	  static get Class() {
	    return SwiperClass;
	  }
	  static get $() {
	    return $$1;
	  }
	}
	var Device$1 = {
	  name: 'device',
	  proto: {
	    device: Device
	  },
	  static: {
	    device: Device
	  }
	};
	var Support$1 = {
	  name: 'support',
	  proto: {
	    support: Support
	  },
	  static: {
	    support: Support
	  }
	};
	var Browser$1 = {
	  name: 'browser',
	  proto: {
	    browser: Browser
	  },
	  static: {
	    browser: Browser
	  }
	};
	var Resize = {
	  name: 'resize',
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      resize: {
	        resizeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) return;
	          swiper.emit('beforeResize');
	          swiper.emit('resize');
	        },
	        orientationChangeHandler() {
	          if (!swiper || swiper.destroyed || !swiper.initialized) return;
	          swiper.emit('orientationchange');
	        }
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      // Emit resize
	      win.addEventListener('resize', swiper.resize.resizeHandler);

	      // Emit orientationchange
	      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	    destroy() {
	      const swiper = this;
	      win.removeEventListener('resize', swiper.resize.resizeHandler);
	      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    }
	  }
	};
	const Observer = {
	  func: win.MutationObserver || win.WebkitMutationObserver,
	  attach(target) {
	    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    const swiper = this;
	    const ObserverFunc = Observer.func;
	    const observer = new ObserverFunc(mutations => {
	      // The observerUpdate event should only be triggered
	      // once despite the number of mutations.  Additional
	      // triggers are redundant and are very costly
	      if (mutations.length === 1) {
	        swiper.emit('observerUpdate', mutations[0]);
	        return;
	      }
	      const observerUpdate = function observerUpdate() {
	        swiper.emit('observerUpdate', mutations[0]);
	      };
	      if (win.requestAnimationFrame) {
	        win.requestAnimationFrame(observerUpdate);
	      } else {
	        win.setTimeout(observerUpdate, 0);
	      }
	    });
	    observer.observe(target, {
	      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	      childList: typeof options.childList === 'undefined' ? true : options.childList,
	      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
	    });
	    swiper.observer.observers.push(observer);
	  },
	  init() {
	    const swiper = this;
	    if (!Support.observer || !swiper.params.observer) return;
	    if (swiper.params.observeParents) {
	      const containerParents = swiper.$el.parents();
	      for (let i = 0; i < containerParents.length; i += 1) {
	        swiper.observer.attach(containerParents[i]);
	      }
	    }
	    // Observe container
	    swiper.observer.attach(swiper.$el[0], {
	      childList: swiper.params.observeSlideChildren
	    });

	    // Observe wrapper
	    swiper.observer.attach(swiper.$wrapperEl[0], {
	      attributes: false
	    });
	  },
	  destroy() {
	    const swiper = this;
	    swiper.observer.observers.forEach(observer => {
	      observer.disconnect();
	    });
	    swiper.observer.observers = [];
	  }
	};
	var Observer$1 = {
	  name: 'observer',
	  params: {
	    observer: false,
	    observeParents: false,
	    observeSlideChildren: false
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      observer: {
	        init: Observer.init.bind(swiper),
	        attach: Observer.attach.bind(swiper),
	        destroy: Observer.destroy.bind(swiper),
	        observers: []
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      swiper.observer.init();
	    },
	    destroy() {
	      const swiper = this;
	      swiper.observer.destroy();
	    }
	  }
	};
	const Virtual = {
	  update(force) {
	    const swiper = this;
	    const {
	      slidesPerView,
	      slidesPerGroup,
	      centeredSlides
	    } = swiper.params;
	    const {
	      addSlidesBefore,
	      addSlidesAfter
	    } = swiper.params.virtual;
	    const {
	      from: previousFrom,
	      to: previousTo,
	      slides,
	      slidesGrid: previousSlidesGrid,
	      renderSlide,
	      offset: previousOffset
	    } = swiper.virtual;
	    swiper.updateActiveIndex();
	    const activeIndex = swiper.activeIndex || 0;
	    let offsetProp;
	    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
	    let slidesAfter;
	    let slidesBefore;
	    if (centeredSlides) {
	      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
	      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
	    } else {
	      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
	      slidesBefore = slidesPerGroup + addSlidesAfter;
	    }
	    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
	    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
	    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
	    Utils.extend(swiper.virtual, {
	      from,
	      to,
	      offset,
	      slidesGrid: swiper.slidesGrid
	    });
	    function onRendered() {
	      swiper.updateSlides();
	      swiper.updateProgress();
	      swiper.updateSlidesClasses();
	      if (swiper.lazy && swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    }
	    if (previousFrom === from && previousTo === to && !force) {
	      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
	        swiper.slides.css(offsetProp, `${offset}px`);
	      }
	      swiper.updateProgress();
	      return;
	    }
	    if (swiper.params.virtual.renderExternal) {
	      swiper.params.virtual.renderExternal.call(swiper, {
	        offset,
	        from,
	        to,
	        slides: function getSlides() {
	          const slidesToRender = [];
	          for (let i = from; i <= to; i += 1) {
	            slidesToRender.push(slides[i]);
	          }
	          return slidesToRender;
	        }()
	      });
	      onRendered();
	      return;
	    }
	    const prependIndexes = [];
	    const appendIndexes = [];
	    if (force) {
	      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
	    } else {
	      for (let i = previousFrom; i <= previousTo; i += 1) {
	        if (i < from || i > to) {
	          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
	        }
	      }
	    }
	    for (let i = 0; i < slides.length; i += 1) {
	      if (i >= from && i <= to) {
	        if (typeof previousTo === 'undefined' || force) {
	          appendIndexes.push(i);
	        } else {
	          if (i > previousTo) appendIndexes.push(i);
	          if (i < previousFrom) prependIndexes.push(i);
	        }
	      }
	    }
	    appendIndexes.forEach(index => {
	      swiper.$wrapperEl.append(renderSlide(slides[index], index));
	    });
	    prependIndexes.sort((a, b) => b - a).forEach(index => {
	      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
	    });
	    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
	    onRendered();
	  },
	  renderSlide(slide, index) {
	    const swiper = this;
	    const params = swiper.params.virtual;
	    if (params.cache && swiper.virtual.cache[index]) {
	      return swiper.virtual.cache[index];
	    }
	    const $slideEl = params.renderSlide ? $$1(params.renderSlide.call(swiper, slide, index)) : $$1(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
	    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
	    if (params.cache) swiper.virtual.cache[index] = $slideEl;
	    return $slideEl;
	  },
	  appendSlide(slides) {
	    const swiper = this;
	    if (typeof slides === 'object' && 'length' in slides) {
	      for (let i = 0; i < slides.length; i += 1) {
	        if (slides[i]) swiper.virtual.slides.push(slides[i]);
	      }
	    } else {
	      swiper.virtual.slides.push(slides);
	    }
	    swiper.virtual.update(true);
	  },
	  prependSlide(slides) {
	    const swiper = this;
	    const activeIndex = swiper.activeIndex;
	    let newActiveIndex = activeIndex + 1;
	    let numberOfNewSlides = 1;
	    if (Array.isArray(slides)) {
	      for (let i = 0; i < slides.length; i += 1) {
	        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
	      }
	      newActiveIndex = activeIndex + slides.length;
	      numberOfNewSlides = slides.length;
	    } else {
	      swiper.virtual.slides.unshift(slides);
	    }
	    if (swiper.params.virtual.cache) {
	      const cache = swiper.virtual.cache;
	      const newCache = {};
	      Object.keys(cache).forEach(cachedIndex => {
	        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
	      });
	      swiper.virtual.cache = newCache;
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(newActiveIndex, 0);
	  },
	  removeSlide(slidesIndexes) {
	    const swiper = this;
	    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
	    let activeIndex = swiper.activeIndex;
	    if (Array.isArray(slidesIndexes)) {
	      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
	        swiper.virtual.slides.splice(slidesIndexes[i], 1);
	        if (swiper.params.virtual.cache) {
	          delete swiper.virtual.cache[slidesIndexes[i]];
	        }
	        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
	        activeIndex = Math.max(activeIndex, 0);
	      }
	    } else {
	      swiper.virtual.slides.splice(slidesIndexes, 1);
	      if (swiper.params.virtual.cache) {
	        delete swiper.virtual.cache[slidesIndexes];
	      }
	      if (slidesIndexes < activeIndex) activeIndex -= 1;
	      activeIndex = Math.max(activeIndex, 0);
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(activeIndex, 0);
	  },
	  removeAllSlides() {
	    const swiper = this;
	    swiper.virtual.slides = [];
	    if (swiper.params.virtual.cache) {
	      swiper.virtual.cache = {};
	    }
	    swiper.virtual.update(true);
	    swiper.slideTo(0, 0);
	  }
	};
	var Virtual$1 = {
	  name: 'virtual',
	  params: {
	    virtual: {
	      enabled: false,
	      slides: [],
	      cache: true,
	      renderSlide: null,
	      renderExternal: null,
	      addSlidesBefore: 0,
	      addSlidesAfter: 0
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      virtual: {
	        update: Virtual.update.bind(swiper),
	        appendSlide: Virtual.appendSlide.bind(swiper),
	        prependSlide: Virtual.prependSlide.bind(swiper),
	        removeSlide: Virtual.removeSlide.bind(swiper),
	        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
	        renderSlide: Virtual.renderSlide.bind(swiper),
	        slides: swiper.params.virtual.slides,
	        cache: {}
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (!swiper.params.virtual.enabled) return;
	      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
	      const overwriteParams = {
	        watchSlidesProgress: true
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	      if (!swiper.params.initialSlide) {
	        swiper.virtual.update();
	      }
	    },
	    setTranslate() {
	      const swiper = this;
	      if (!swiper.params.virtual.enabled) return;
	      swiper.virtual.update();
	    }
	  }
	};
	const Keyboard = {
	  handle(event) {
	    const swiper = this;
	    const {
	      rtlTranslate: rtl
	    } = swiper;
	    let e = event;
	    if (e.originalEvent) e = e.originalEvent; // jquery fix
	    const kc = e.keyCode || e.charCode;
	    // Directions locks
	    if (!swiper.allowSlideNext && (swiper.isHorizontal() && kc === 39 || swiper.isVertical() && kc === 40)) {
	      return false;
	    }
	    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && kc === 37 || swiper.isVertical() && kc === 38)) {
	      return false;
	    }
	    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
	      return undefined;
	    }
	    if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
	      return undefined;
	    }
	    if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
	      let inView = false;
	      // Check that swiper should be inside of visible area of window
	      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
	        return undefined;
	      }
	      const windowWidth = win.innerWidth;
	      const windowHeight = win.innerHeight;
	      const swiperOffset = swiper.$el.offset();
	      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
	      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
	      for (let i = 0; i < swiperCoord.length; i += 1) {
	        const point = swiperCoord[i];
	        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
	          inView = true;
	        }
	      }
	      if (!inView) return undefined;
	    }
	    if (swiper.isHorizontal()) {
	      if (kc === 37 || kc === 39) {
	        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	      }
	      if (kc === 39 && !rtl || kc === 37 && rtl) swiper.slideNext();
	      if (kc === 37 && !rtl || kc === 39 && rtl) swiper.slidePrev();
	    } else {
	      if (kc === 38 || kc === 40) {
	        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	      }
	      if (kc === 40) swiper.slideNext();
	      if (kc === 38) swiper.slidePrev();
	    }
	    swiper.emit('keyPress', kc);
	    return undefined;
	  },
	  enable() {
	    const swiper = this;
	    if (swiper.keyboard.enabled) return;
	    $$1(doc).on('keydown', swiper.keyboard.handle);
	    swiper.keyboard.enabled = true;
	  },
	  disable() {
	    const swiper = this;
	    if (!swiper.keyboard.enabled) return;
	    $$1(doc).off('keydown', swiper.keyboard.handle);
	    swiper.keyboard.enabled = false;
	  }
	};
	var Keyboard$1 = {
	  name: 'keyboard',
	  params: {
	    keyboard: {
	      enabled: false,
	      onlyInViewport: true
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      keyboard: {
	        enabled: false,
	        enable: Keyboard.enable.bind(swiper),
	        disable: Keyboard.disable.bind(swiper),
	        handle: Keyboard.handle.bind(swiper)
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.keyboard.enabled) {
	        swiper.keyboard.enable();
	      }
	    },
	    destroy() {
	      const swiper = this;
	      if (swiper.keyboard.enabled) {
	        swiper.keyboard.disable();
	      }
	    }
	  }
	};
	function isEventSupported() {
	  const eventName = 'onwheel';
	  let isSupported = (eventName in doc);
	  if (!isSupported) {
	    const element = doc.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	  if (!isSupported && doc.implementation && doc.implementation.hasFeature
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  && doc.implementation.hasFeature('', '') !== true) {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
	  }
	  return isSupported;
	}
	const Mousewheel = {
	  lastScrollTime: Utils.now(),
	  event: function getEvent() {
	    if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
	    return isEventSupported() ? 'wheel' : 'mousewheel';
	  }(),
	  normalize(e) {
	    // Reasonable defaults
	    const PIXEL_STEP = 10;
	    const LINE_HEIGHT = 40;
	    const PAGE_HEIGHT = 800;
	    let sX = 0;
	    let sY = 0; // spinX, spinY
	    let pX = 0;
	    let pY = 0; // pixelX, pixelY

	    // Legacy
	    if ('detail' in e) {
	      sY = e.detail;
	    }
	    if ('wheelDelta' in e) {
	      sY = -e.wheelDelta / 120;
	    }
	    if ('wheelDeltaY' in e) {
	      sY = -e.wheelDeltaY / 120;
	    }
	    if ('wheelDeltaX' in e) {
	      sX = -e.wheelDeltaX / 120;
	    }

	    // side scrolling on FF with DOMMouseScroll
	    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
	      sX = sY;
	      sY = 0;
	    }
	    pX = sX * PIXEL_STEP;
	    pY = sY * PIXEL_STEP;
	    if ('deltaY' in e) {
	      pY = e.deltaY;
	    }
	    if ('deltaX' in e) {
	      pX = e.deltaX;
	    }
	    if ((pX || pY) && e.deltaMode) {
	      if (e.deltaMode === 1) {
	        // delta in LINE units
	        pX *= LINE_HEIGHT;
	        pY *= LINE_HEIGHT;
	      } else {
	        // delta in PAGE units
	        pX *= PAGE_HEIGHT;
	        pY *= PAGE_HEIGHT;
	      }
	    }

	    // Fall-back if spin cannot be determined
	    if (pX && !sX) {
	      sX = pX < 1 ? -1 : 1;
	    }
	    if (pY && !sY) {
	      sY = pY < 1 ? -1 : 1;
	    }
	    return {
	      spinX: sX,
	      spinY: sY,
	      pixelX: pX,
	      pixelY: pY
	    };
	  },
	  handleMouseEnter() {
	    const swiper = this;
	    swiper.mouseEntered = true;
	  },
	  handleMouseLeave() {
	    const swiper = this;
	    swiper.mouseEntered = false;
	  },
	  handle(event) {
	    let e = event;
	    const swiper = this;
	    const params = swiper.params.mousewheel;
	    if (!swiper.mouseEntered && !params.releaseOnEdges) return true;
	    if (e.originalEvent) e = e.originalEvent; // jquery fix
	    let delta = 0;
	    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
	    const data = Mousewheel.normalize(e);
	    if (params.forceToAxis) {
	      if (swiper.isHorizontal()) {
	        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;else return true;
	      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;else return true;
	    } else {
	      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
	    }
	    if (delta === 0) return true;
	    if (params.invert) delta = -delta;
	    if (!swiper.params.freeMode) {
	      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
	        if (delta < 0) {
	          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
	            swiper.slideNext();
	            swiper.emit('scroll', e);
	          } else if (params.releaseOnEdges) return true;
	        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
	          swiper.slidePrev();
	          swiper.emit('scroll', e);
	        } else if (params.releaseOnEdges) return true;
	      }
	      swiper.mousewheel.lastScrollTime = new win.Date().getTime();
	    } else {
	      // Freemode or scrollContainer:
	      if (swiper.params.loop) {
	        swiper.loopFix();
	      }
	      let position = swiper.getTranslate() + delta * params.sensitivity;
	      const wasBeginning = swiper.isBeginning;
	      const wasEnd = swiper.isEnd;
	      if (position >= swiper.minTranslate()) position = swiper.minTranslate();
	      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
	      swiper.setTransition(0);
	      swiper.setTranslate(position);
	      swiper.updateProgress();
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	      if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
	        swiper.updateSlidesClasses();
	      }
	      if (swiper.params.freeModeSticky) {
	        clearTimeout(swiper.mousewheel.timeout);
	        swiper.mousewheel.timeout = Utils.nextTick(() => {
	          swiper.slideToClosest();
	        }, 300);
	      }
	      // Emit event
	      swiper.emit('scroll', e);

	      // Stop autoplay
	      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
	      // Return page scroll on edge positions
	      if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
	    }
	    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	    return false;
	  },
	  enable() {
	    const swiper = this;
	    if (!Mousewheel.event) return false;
	    if (swiper.mousewheel.enabled) return false;
	    let target = swiper.$el;
	    if (swiper.params.mousewheel.eventsTarged !== 'container') {
	      target = $$1(swiper.params.mousewheel.eventsTarged);
	    }
	    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
	    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
	    target.on(Mousewheel.event, swiper.mousewheel.handle);
	    swiper.mousewheel.enabled = true;
	    return true;
	  },
	  disable() {
	    const swiper = this;
	    if (!Mousewheel.event) return false;
	    if (!swiper.mousewheel.enabled) return false;
	    let target = swiper.$el;
	    if (swiper.params.mousewheel.eventsTarged !== 'container') {
	      target = $$1(swiper.params.mousewheel.eventsTarged);
	    }
	    target.off(Mousewheel.event, swiper.mousewheel.handle);
	    swiper.mousewheel.enabled = false;
	    return true;
	  }
	};
	var Mousewheel$1 = {
	  name: 'mousewheel',
	  params: {
	    mousewheel: {
	      enabled: false,
	      releaseOnEdges: false,
	      invert: false,
	      forceToAxis: false,
	      sensitivity: 1,
	      eventsTarged: 'container'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      mousewheel: {
	        enabled: false,
	        enable: Mousewheel.enable.bind(swiper),
	        disable: Mousewheel.disable.bind(swiper),
	        handle: Mousewheel.handle.bind(swiper),
	        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
	        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
	        lastScrollTime: Utils.now()
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
	    },
	    destroy() {
	      const swiper = this;
	      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
	    }
	  }
	};
	const Navigation = {
	  update() {
	    // Update Navigation Buttons
	    const swiper = this;
	    const params = swiper.params.navigation;
	    if (swiper.params.loop) return;
	    const {
	      $nextEl,
	      $prevEl
	    } = swiper.navigation;
	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        $prevEl.addClass(params.disabledClass);
	      } else {
	        $prevEl.removeClass(params.disabledClass);
	      }
	      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        $nextEl.addClass(params.disabledClass);
	      } else {
	        $nextEl.removeClass(params.disabledClass);
	      }
	      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	    }
	  },
	  onPrevClick(e) {
	    const swiper = this;
	    e.preventDefault();
	    if (swiper.isBeginning && !swiper.params.loop) return;
	    swiper.slidePrev();
	  },
	  onNextClick(e) {
	    const swiper = this;
	    e.preventDefault();
	    if (swiper.isEnd && !swiper.params.loop) return;
	    swiper.slideNext();
	  },
	  init() {
	    const swiper = this;
	    const params = swiper.params.navigation;
	    if (!(params.nextEl || params.prevEl)) return;
	    let $nextEl;
	    let $prevEl;
	    if (params.nextEl) {
	      $nextEl = $$1(params.nextEl);
	      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
	        $nextEl = swiper.$el.find(params.nextEl);
	      }
	    }
	    if (params.prevEl) {
	      $prevEl = $$1(params.prevEl);
	      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
	        $prevEl = swiper.$el.find(params.prevEl);
	      }
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      $nextEl.on('click', swiper.navigation.onNextClick);
	    }
	    if ($prevEl && $prevEl.length > 0) {
	      $prevEl.on('click', swiper.navigation.onPrevClick);
	    }
	    Utils.extend(swiper.navigation, {
	      $nextEl,
	      nextEl: $nextEl && $nextEl[0],
	      $prevEl,
	      prevEl: $prevEl && $prevEl[0]
	    });
	  },
	  destroy() {
	    const swiper = this;
	    const {
	      $nextEl,
	      $prevEl
	    } = swiper.navigation;
	    if ($nextEl && $nextEl.length) {
	      $nextEl.off('click', swiper.navigation.onNextClick);
	      $nextEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	    if ($prevEl && $prevEl.length) {
	      $prevEl.off('click', swiper.navigation.onPrevClick);
	      $prevEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	  }
	};
	var Navigation$1 = {
	  name: 'navigation',
	  params: {
	    navigation: {
	      nextEl: null,
	      prevEl: null,
	      hideOnClick: false,
	      disabledClass: 'swiper-button-disabled',
	      hiddenClass: 'swiper-button-hidden',
	      lockClass: 'swiper-button-lock'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      navigation: {
	        init: Navigation.init.bind(swiper),
	        update: Navigation.update.bind(swiper),
	        destroy: Navigation.destroy.bind(swiper),
	        onNextClick: Navigation.onNextClick.bind(swiper),
	        onPrevClick: Navigation.onPrevClick.bind(swiper)
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      swiper.navigation.init();
	      swiper.navigation.update();
	    },
	    toEdge() {
	      const swiper = this;
	      swiper.navigation.update();
	    },
	    fromEdge() {
	      const swiper = this;
	      swiper.navigation.update();
	    },
	    destroy() {
	      const swiper = this;
	      swiper.navigation.destroy();
	    },
	    click(e) {
	      const swiper = this;
	      const {
	        $nextEl,
	        $prevEl
	      } = swiper.navigation;
	      if (swiper.params.navigation.hideOnClick && !$$1(e.target).is($prevEl) && !$$1(e.target).is($nextEl)) {
	        let isHidden;
	        if ($nextEl) {
	          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
	        } else if ($prevEl) {
	          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
	        }
	        if (isHidden === true) {
	          swiper.emit('navigationShow', swiper);
	        } else {
	          swiper.emit('navigationHide', swiper);
	        }
	        if ($nextEl) {
	          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
	        }
	        if ($prevEl) {
	          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
	        }
	      }
	    }
	  }
	};
	const Pagination = {
	  update() {
	    // Render || Update Pagination bullets/items
	    const swiper = this;
	    const rtl = swiper.rtl;
	    const params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
	    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    const $el = swiper.pagination.$el;
	    // Current/Total
	    let current;
	    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	    if (swiper.params.loop) {
	      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
	      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
	        current -= slidesLength - swiper.loopedSlides * 2;
	      }
	      if (current > total - 1) current -= total;
	      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
	    } else if (typeof swiper.snapIndex !== 'undefined') {
	      current = swiper.snapIndex;
	    } else {
	      current = swiper.activeIndex || 0;
	    }
	    // Types
	    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
	      const bullets = swiper.pagination.bullets;
	      let firstIndex;
	      let lastIndex;
	      let midIndex;
	      if (params.dynamicBullets) {
	        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
	        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
	        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
	          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;
	          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
	            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
	          } else if (swiper.pagination.dynamicBulletIndex < 0) {
	            swiper.pagination.dynamicBulletIndex = 0;
	          }
	        }
	        firstIndex = current - swiper.pagination.dynamicBulletIndex;
	        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
	        midIndex = (lastIndex + firstIndex) / 2;
	      }
	      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
	      if ($el.length > 1) {
	        bullets.each((index, bullet) => {
	          const $bullet = $$1(bullet);
	          const bulletIndex = $bullet.index();
	          if (bulletIndex === current) {
	            $bullet.addClass(params.bulletActiveClass);
	          }
	          if (params.dynamicBullets) {
	            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
	              $bullet.addClass(`${params.bulletActiveClass}-main`);
	            }
	            if (bulletIndex === firstIndex) {
	              $bullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
	            }
	            if (bulletIndex === lastIndex) {
	              $bullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
	            }
	          }
	        });
	      } else {
	        const $bullet = bullets.eq(current);
	        $bullet.addClass(params.bulletActiveClass);
	        if (params.dynamicBullets) {
	          const $firstDisplayedBullet = bullets.eq(firstIndex);
	          const $lastDisplayedBullet = bullets.eq(lastIndex);
	          for (let i = firstIndex; i <= lastIndex; i += 1) {
	            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
	          }
	          $firstDisplayedBullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
	          $lastDisplayedBullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
	        }
	      }
	      if (params.dynamicBullets) {
	        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
	        const bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
	        const offsetProp = rtl ? 'right' : 'left';
	        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
	      }
	    }
	    if (params.type === 'fraction') {
	      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
	      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
	    }
	    if (params.type === 'progressbar') {
	      let progressbarDirection;
	      if (params.progressbarOpposite) {
	        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
	      } else {
	        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
	      }
	      const scale = (current + 1) / total;
	      let scaleX = 1;
	      let scaleY = 1;
	      if (progressbarDirection === 'horizontal') {
	        scaleX = scale;
	      } else {
	        scaleY = scale;
	      }
	      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
	    }
	    if (params.type === 'custom' && params.renderCustom) {
	      $el.html(params.renderCustom(swiper, current + 1, total));
	      swiper.emit('paginationRender', swiper, $el[0]);
	    } else {
	      swiper.emit('paginationUpdate', swiper, $el[0]);
	    }
	    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	  },
	  render() {
	    // Render Container
	    const swiper = this;
	    const params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
	    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    const $el = swiper.pagination.$el;
	    let paginationHTML = '';
	    if (params.type === 'bullets') {
	      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	      for (let i = 0; i < numberOfBullets; i += 1) {
	        if (params.renderBullet) {
	          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
	        } else {
	          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
	        }
	      }
	      $el.html(paginationHTML);
	      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
	    }
	    if (params.type === 'fraction') {
	      if (params.renderFraction) {
	        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
	      } else {
	        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type === 'progressbar') {
	      if (params.renderProgressbar) {
	        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
	      } else {
	        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type !== 'custom') {
	      swiper.emit('paginationRender', swiper.pagination.$el[0]);
	    }
	  },
	  init() {
	    const swiper = this;
	    const params = swiper.params.pagination;
	    if (!params.el) return;
	    let $el = $$1(params.el);
	    if ($el.length === 0) return;
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
	      $el = swiper.$el.find(params.el);
	    }
	    if (params.type === 'bullets' && params.clickable) {
	      $el.addClass(params.clickableClass);
	    }
	    $el.addClass(params.modifierClass + params.type);
	    if (params.type === 'bullets' && params.dynamicBullets) {
	      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
	      swiper.pagination.dynamicBulletIndex = 0;
	      if (params.dynamicMainBullets < 1) {
	        params.dynamicMainBullets = 1;
	      }
	    }
	    if (params.type === 'progressbar' && params.progressbarOpposite) {
	      $el.addClass(params.progressbarOppositeClass);
	    }
	    if (params.clickable) {
	      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
	        e.preventDefault();
	        let index = $$1(this).index() * swiper.params.slidesPerGroup;
	        if (swiper.params.loop) index += swiper.loopedSlides;
	        swiper.slideTo(index);
	      });
	    }
	    Utils.extend(swiper.pagination, {
	      $el,
	      el: $el[0]
	    });
	  },
	  destroy() {
	    const swiper = this;
	    const params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
	    const $el = swiper.pagination.$el;
	    $el.removeClass(params.hiddenClass);
	    $el.removeClass(params.modifierClass + params.type);
	    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
	    if (params.clickable) {
	      $el.off('click', `.${params.bulletClass}`);
	    }
	  }
	};
	var Pagination$1 = {
	  name: 'pagination',
	  params: {
	    pagination: {
	      el: null,
	      bulletElement: 'span',
	      clickable: false,
	      hideOnClick: false,
	      renderBullet: null,
	      renderProgressbar: null,
	      renderFraction: null,
	      renderCustom: null,
	      progressbarOpposite: false,
	      type: 'bullets',
	      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
	      dynamicBullets: false,
	      dynamicMainBullets: 1,
	      formatFractionCurrent: number => number,
	      formatFractionTotal: number => number,
	      bulletClass: 'swiper-pagination-bullet',
	      bulletActiveClass: 'swiper-pagination-bullet-active',
	      modifierClass: 'swiper-pagination-',
	      // NEW
	      currentClass: 'swiper-pagination-current',
	      totalClass: 'swiper-pagination-total',
	      hiddenClass: 'swiper-pagination-hidden',
	      progressbarFillClass: 'swiper-pagination-progressbar-fill',
	      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
	      clickableClass: 'swiper-pagination-clickable',
	      // NEW
	      lockClass: 'swiper-pagination-lock'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      pagination: {
	        init: Pagination.init.bind(swiper),
	        render: Pagination.render.bind(swiper),
	        update: Pagination.update.bind(swiper),
	        destroy: Pagination.destroy.bind(swiper),
	        dynamicBulletIndex: 0
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      swiper.pagination.init();
	      swiper.pagination.render();
	      swiper.pagination.update();
	    },
	    activeIndexChange() {
	      const swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.update();
	      } else if (typeof swiper.snapIndex === 'undefined') {
	        swiper.pagination.update();
	      }
	    },
	    snapIndexChange() {
	      const swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.update();
	      }
	    },
	    slidesLengthChange() {
	      const swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    snapGridLengthChange() {
	      const swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    destroy() {
	      const swiper = this;
	      swiper.pagination.destroy();
	    },
	    click(e) {
	      const swiper = this;
	      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$$1(e.target).hasClass(swiper.params.pagination.bulletClass)) {
	        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
	        if (isHidden === true) {
	          swiper.emit('paginationShow', swiper);
	        } else {
	          swiper.emit('paginationHide', swiper);
	        }
	        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
	      }
	    }
	  }
	};
	const Scrollbar = {
	  setTranslate() {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    const {
	      scrollbar,
	      rtlTranslate: rtl,
	      progress
	    } = swiper;
	    const {
	      dragSize,
	      trackSize,
	      $dragEl,
	      $el
	    } = scrollbar;
	    const params = swiper.params.scrollbar;
	    let newSize = dragSize;
	    let newPos = (trackSize - dragSize) * progress;
	    if (rtl) {
	      newPos = -newPos;
	      if (newPos > 0) {
	        newSize = dragSize - newPos;
	        newPos = 0;
	      } else if (-newPos + dragSize > trackSize) {
	        newSize = trackSize + newPos;
	      }
	    } else if (newPos < 0) {
	      newSize = dragSize + newPos;
	      newPos = 0;
	    } else if (newPos + dragSize > trackSize) {
	      newSize = trackSize - newPos;
	    }
	    if (swiper.isHorizontal()) {
	      if (Support.transforms3d) {
	        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
	      } else {
	        $dragEl.transform(`translateX(${newPos}px)`);
	      }
	      $dragEl[0].style.width = `${newSize}px`;
	    } else {
	      if (Support.transforms3d) {
	        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
	      } else {
	        $dragEl.transform(`translateY(${newPos}px)`);
	      }
	      $dragEl[0].style.height = `${newSize}px`;
	    }
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.timeout);
	      $el[0].style.opacity = 1;
	      swiper.scrollbar.timeout = setTimeout(() => {
	        $el[0].style.opacity = 0;
	        $el.transition(400);
	      }, 1000);
	    }
	  },
	  setTransition(duration) {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    swiper.scrollbar.$dragEl.transition(duration);
	  },
	  updateSize() {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    const {
	      scrollbar
	    } = swiper;
	    const {
	      $dragEl,
	      $el
	    } = scrollbar;
	    $dragEl[0].style.width = '';
	    $dragEl[0].style.height = '';
	    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
	    const divider = swiper.size / swiper.virtualSize;
	    const moveDivider = divider * (trackSize / swiper.size);
	    let dragSize;
	    if (swiper.params.scrollbar.dragSize === 'auto') {
	      dragSize = trackSize * divider;
	    } else {
	      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
	    }
	    if (swiper.isHorizontal()) {
	      $dragEl[0].style.width = `${dragSize}px`;
	    } else {
	      $dragEl[0].style.height = `${dragSize}px`;
	    }
	    if (divider >= 1) {
	      $el[0].style.display = 'none';
	    } else {
	      $el[0].style.display = '';
	    }
	    if (swiper.params.scrollbar.hide) {
	      $el[0].style.opacity = 0;
	    }
	    Utils.extend(scrollbar, {
	      trackSize,
	      divider,
	      moveDivider,
	      dragSize
	    });
	    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
	  },
	  setDragPosition(e) {
	    const swiper = this;
	    const {
	      scrollbar,
	      rtlTranslate: rtl
	    } = swiper;
	    const {
	      $el,
	      dragSize,
	      trackSize
	    } = scrollbar;
	    let pointerPosition;
	    if (swiper.isHorizontal()) {
	      pointerPosition = e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX || e.clientX;
	    } else {
	      pointerPosition = e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY || e.clientY;
	    }
	    let positionRatio;
	    positionRatio = (pointerPosition - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - dragSize / 2) / (trackSize - dragSize);
	    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
	    if (rtl) {
	      positionRatio = 1 - positionRatio;
	    }
	    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
	    swiper.updateProgress(position);
	    swiper.setTranslate(position);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  },
	  onDragStart(e) {
	    const swiper = this;
	    const params = swiper.params.scrollbar;
	    const {
	      scrollbar,
	      $wrapperEl
	    } = swiper;
	    const {
	      $el,
	      $dragEl
	    } = scrollbar;
	    swiper.scrollbar.isTouched = true;
	    e.preventDefault();
	    e.stopPropagation();
	    $wrapperEl.transition(100);
	    $dragEl.transition(100);
	    scrollbar.setDragPosition(e);
	    clearTimeout(swiper.scrollbar.dragTimeout);
	    $el.transition(0);
	    if (params.hide) {
	      $el.css('opacity', 1);
	    }
	    swiper.emit('scrollbarDragStart', e);
	  },
	  onDragMove(e) {
	    const swiper = this;
	    const {
	      scrollbar,
	      $wrapperEl
	    } = swiper;
	    const {
	      $el,
	      $dragEl
	    } = scrollbar;
	    if (!swiper.scrollbar.isTouched) return;
	    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	    scrollbar.setDragPosition(e);
	    $wrapperEl.transition(0);
	    $el.transition(0);
	    $dragEl.transition(0);
	    swiper.emit('scrollbarDragMove', e);
	  },
	  onDragEnd(e) {
	    const swiper = this;
	    const params = swiper.params.scrollbar;
	    const {
	      scrollbar
	    } = swiper;
	    const {
	      $el
	    } = scrollbar;
	    if (!swiper.scrollbar.isTouched) return;
	    swiper.scrollbar.isTouched = false;
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.dragTimeout);
	      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
	        $el.css('opacity', 0);
	        $el.transition(400);
	      }, 1000);
	    }
	    swiper.emit('scrollbarDragEnd', e);
	    if (params.snapOnRelease) {
	      swiper.slideToClosest();
	    }
	  },
	  enableDraggable() {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el) return;
	    const {
	      scrollbar,
	      touchEventsTouch,
	      touchEventsDesktop,
	      params
	    } = swiper;
	    const $el = scrollbar.$el;
	    const target = $el[0];
	    const activeListener = Support.passiveListener && params.passiveListeners ? {
	      passive: false,
	      capture: false
	    } : false;
	    const passiveListener = Support.passiveListener && params.passiveListeners ? {
	      passive: true,
	      capture: false
	    } : false;
	    if (!Support.touch) {
	      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	      doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	      doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	    } else {
	      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	    }
	  },
	  disableDraggable() {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el) return;
	    const {
	      scrollbar,
	      touchEventsTouch,
	      touchEventsDesktop,
	      params
	    } = swiper;
	    const $el = scrollbar.$el;
	    const target = $el[0];
	    const activeListener = Support.passiveListener && params.passiveListeners ? {
	      passive: false,
	      capture: false
	    } : false;
	    const passiveListener = Support.passiveListener && params.passiveListeners ? {
	      passive: true,
	      capture: false
	    } : false;
	    if (!Support.touch) {
	      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	      doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	      doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	    } else {
	      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	    }
	  },
	  init() {
	    const swiper = this;
	    if (!swiper.params.scrollbar.el) return;
	    const {
	      scrollbar,
	      $el: $swiperEl
	    } = swiper;
	    const params = swiper.params.scrollbar;
	    let $el = $$1(params.el);
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
	      $el = $swiperEl.find(params.el);
	    }
	    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
	    if ($dragEl.length === 0) {
	      $dragEl = $$1(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
	      $el.append($dragEl);
	    }
	    Utils.extend(scrollbar, {
	      $el,
	      el: $el[0],
	      $dragEl,
	      dragEl: $dragEl[0]
	    });
	    if (params.draggable) {
	      scrollbar.enableDraggable();
	    }
	  },
	  destroy() {
	    const swiper = this;
	    swiper.scrollbar.disableDraggable();
	  }
	};
	var Scrollbar$1 = {
	  name: 'scrollbar',
	  params: {
	    scrollbar: {
	      el: null,
	      dragSize: 'auto',
	      hide: false,
	      draggable: false,
	      snapOnRelease: true,
	      lockClass: 'swiper-scrollbar-lock',
	      dragClass: 'swiper-scrollbar-drag'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      scrollbar: {
	        init: Scrollbar.init.bind(swiper),
	        destroy: Scrollbar.destroy.bind(swiper),
	        updateSize: Scrollbar.updateSize.bind(swiper),
	        setTranslate: Scrollbar.setTranslate.bind(swiper),
	        setTransition: Scrollbar.setTransition.bind(swiper),
	        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
	        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
	        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
	        onDragStart: Scrollbar.onDragStart.bind(swiper),
	        onDragMove: Scrollbar.onDragMove.bind(swiper),
	        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
	        isTouched: false,
	        timeout: null,
	        dragTimeout: null
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      swiper.scrollbar.init();
	      swiper.scrollbar.updateSize();
	      swiper.scrollbar.setTranslate();
	    },
	    update() {
	      const swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    resize() {
	      const swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    observerUpdate() {
	      const swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    setTranslate() {
	      const swiper = this;
	      swiper.scrollbar.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      swiper.scrollbar.setTransition(duration);
	    },
	    destroy() {
	      const swiper = this;
	      swiper.scrollbar.destroy();
	    }
	  }
	};
	const Parallax = {
	  setTransform(el, progress) {
	    const swiper = this;
	    const {
	      rtl
	    } = swiper;
	    const $el = $$1(el);
	    const rtlFactor = rtl ? -1 : 1;
	    const p = $el.attr('data-swiper-parallax') || '0';
	    let x = $el.attr('data-swiper-parallax-x');
	    let y = $el.attr('data-swiper-parallax-y');
	    const scale = $el.attr('data-swiper-parallax-scale');
	    const opacity = $el.attr('data-swiper-parallax-opacity');
	    if (x || y) {
	      x = x || '0';
	      y = y || '0';
	    } else if (swiper.isHorizontal()) {
	      x = p;
	      y = '0';
	    } else {
	      y = p;
	      x = '0';
	    }
	    if (x.indexOf('%') >= 0) {
	      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
	    } else {
	      x = `${x * progress * rtlFactor}px`;
	    }
	    if (y.indexOf('%') >= 0) {
	      y = `${parseInt(y, 10) * progress}%`;
	    } else {
	      y = `${y * progress}px`;
	    }
	    if (typeof opacity !== 'undefined' && opacity !== null) {
	      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
	      $el[0].style.opacity = currentOpacity;
	    }
	    if (typeof scale === 'undefined' || scale === null) {
	      $el.transform(`translate3d(${x}, ${y}, 0px)`);
	    } else {
	      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
	      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
	    }
	  },
	  setTranslate() {
	    const swiper = this;
	    const {
	      $el,
	      slides,
	      progress,
	      snapGrid
	    } = swiper;
	    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index, el) => {
	      swiper.parallax.setTransform(el, progress);
	    });
	    slides.each((slideIndex, slideEl) => {
	      let slideProgress = slideEl.progress;
	      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
	        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
	      }
	      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
	      $$1(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index, el) => {
	        swiper.parallax.setTransform(el, slideProgress);
	      });
	    });
	  },
	  setTransition() {
	    let duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
	    const swiper = this;
	    const {
	      $el
	    } = swiper;
	    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index, parallaxEl) => {
	      const $parallaxEl = $$1(parallaxEl);
	      let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
	      if (duration === 0) parallaxDuration = 0;
	      $parallaxEl.transition(parallaxDuration);
	    });
	  }
	};
	var Parallax$1 = {
	  name: 'parallax',
	  params: {
	    parallax: {
	      enabled: false
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      parallax: {
	        setTransform: Parallax.setTransform.bind(swiper),
	        setTranslate: Parallax.setTranslate.bind(swiper),
	        setTransition: Parallax.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (!swiper.params.parallax.enabled) return;
	      swiper.params.watchSlidesProgress = true;
	      swiper.originalParams.watchSlidesProgress = true;
	    },
	    init() {
	      const swiper = this;
	      if (!swiper.params.parallax.enabled) return;
	      swiper.parallax.setTranslate();
	    },
	    setTranslate() {
	      const swiper = this;
	      if (!swiper.params.parallax.enabled) return;
	      swiper.parallax.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      if (!swiper.params.parallax.enabled) return;
	      swiper.parallax.setTransition(duration);
	    }
	  }
	};
	const Zoom = {
	  // Calc Scale From Multi-touches
	  getDistanceBetweenTouches(e) {
	    if (e.targetTouches.length < 2) return 1;
	    const x1 = e.targetTouches[0].pageX;
	    const y1 = e.targetTouches[0].pageY;
	    const x2 = e.targetTouches[1].pageX;
	    const y2 = e.targetTouches[1].pageY;
	    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
	    return distance;
	  },
	  // Events
	  onGestureStart(e) {
	    const swiper = this;
	    const params = swiper.params.zoom;
	    const zoom = swiper.zoom;
	    const {
	      gesture
	    } = zoom;
	    zoom.fakeGestureTouched = false;
	    zoom.fakeGestureMoved = false;
	    if (!Support.gestures) {
	      if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
	        return;
	      }
	      zoom.fakeGestureTouched = true;
	      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$slideEl || !gesture.$slideEl.length) {
	      gesture.$slideEl = $$1(e.target).closest('.swiper-slide');
	      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
	      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	      if (gesture.$imageWrapEl.length === 0) {
	        gesture.$imageEl = undefined;
	        return;
	      }
	    }
	    gesture.$imageEl.transition(0);
	    swiper.zoom.isScaling = true;
	  },
	  onGestureChange(e) {
	    const swiper = this;
	    const params = swiper.params.zoom;
	    const zoom = swiper.zoom;
	    const {
	      gesture
	    } = zoom;
	    if (!Support.gestures) {
	      if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
	        return;
	      }
	      zoom.fakeGestureMoved = true;
	      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    if (Support.gestures) {
	      zoom.scale = e.scale * zoom.currentScale;
	    } else {
	      zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
	    }
	    if (zoom.scale > gesture.maxRatio) {
	      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
	    }
	    if (zoom.scale < params.minRatio) {
	      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
	    }
	    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
	  },
	  onGestureEnd(e) {
	    const swiper = this;
	    const params = swiper.params.zoom;
	    const zoom = swiper.zoom;
	    const {
	      gesture
	    } = zoom;
	    if (!Support.gestures) {
	      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
	        return;
	      }
	      if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android) {
	        return;
	      }
	      zoom.fakeGestureTouched = false;
	      zoom.fakeGestureMoved = false;
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
	    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
	    zoom.currentScale = zoom.scale;
	    zoom.isScaling = false;
	    if (zoom.scale === 1) gesture.$slideEl = undefined;
	  },
	  onTouchStart(e) {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const {
	      gesture,
	      image
	    } = zoom;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    if (image.isTouched) return;
	    if (Device.android) e.preventDefault();
	    image.isTouched = true;
	    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  },
	  onTouchMove(e) {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const {
	      gesture,
	      image,
	      velocity
	    } = zoom;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    swiper.allowClick = false;
	    if (!image.isTouched || !gesture.$slideEl) return;
	    if (!image.isMoved) {
	      image.width = gesture.$imageEl[0].offsetWidth;
	      image.height = gesture.$imageEl[0].offsetHeight;
	      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
	      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
	      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
	      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
	      gesture.$imageWrapEl.transition(0);
	      if (swiper.rtl) {
	        image.startX = -image.startX;
	        image.startY = -image.startY;
	      }
	    }
	    // Define if we need image drag
	    const scaledWidth = image.width * zoom.scale;
	    const scaledHeight = image.height * zoom.scale;
	    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
	    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
	    image.maxY = -image.minY;
	    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (!image.isMoved && !zoom.isScaling) {
	      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
	        image.isTouched = false;
	        return;
	      }
	      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
	        image.isTouched = false;
	        return;
	      }
	    }
	    e.preventDefault();
	    e.stopPropagation();
	    image.isMoved = true;
	    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
	    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
	    if (image.currentX < image.minX) {
	      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
	    }
	    if (image.currentX > image.maxX) {
	      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
	    }
	    if (image.currentY < image.minY) {
	      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
	    }
	    if (image.currentY > image.maxY) {
	      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
	    }

	    // Velocity
	    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
	    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
	    if (!velocity.prevTime) velocity.prevTime = Date.now();
	    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
	    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
	    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
	    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
	    velocity.prevPositionX = image.touchesCurrent.x;
	    velocity.prevPositionY = image.touchesCurrent.y;
	    velocity.prevTime = Date.now();
	    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
	  },
	  onTouchEnd() {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const {
	      gesture,
	      image,
	      velocity
	    } = zoom;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    if (!image.isTouched || !image.isMoved) {
	      image.isTouched = false;
	      image.isMoved = false;
	      return;
	    }
	    image.isTouched = false;
	    image.isMoved = false;
	    let momentumDurationX = 300;
	    let momentumDurationY = 300;
	    const momentumDistanceX = velocity.x * momentumDurationX;
	    const newPositionX = image.currentX + momentumDistanceX;
	    const momentumDistanceY = velocity.y * momentumDurationY;
	    const newPositionY = image.currentY + momentumDistanceY;

	    // Fix duration
	    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
	    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
	    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
	    image.currentX = newPositionX;
	    image.currentY = newPositionY;

	    // Define if we need image drag
	    const scaledWidth = image.width * zoom.scale;
	    const scaledHeight = image.height * zoom.scale;
	    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
	    image.maxY = -image.minY;
	    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
	    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
	    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
	  },
	  onTransitionEnd() {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const {
	      gesture
	    } = zoom;
	    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
	      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
	      gesture.$imageWrapEl.transform('translate3d(0,0,0)');
	      zoom.scale = 1;
	      zoom.currentScale = 1;
	      gesture.$slideEl = undefined;
	      gesture.$imageEl = undefined;
	      gesture.$imageWrapEl = undefined;
	    }
	  },
	  // Toggle Zoom
	  toggle(e) {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    if (zoom.scale && zoom.scale !== 1) {
	      // Zoom Out
	      zoom.out();
	    } else {
	      // Zoom In
	      zoom.in(e);
	    }
	  },
	  in(e) {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const params = swiper.params.zoom;
	    const {
	      gesture,
	      image
	    } = zoom;
	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
	    let touchX;
	    let touchY;
	    let offsetX;
	    let offsetY;
	    let diffX;
	    let diffY;
	    let translateX;
	    let translateY;
	    let imageWidth;
	    let imageHeight;
	    let scaledWidth;
	    let scaledHeight;
	    let translateMinX;
	    let translateMinY;
	    let translateMaxX;
	    let translateMaxY;
	    let slideWidth;
	    let slideHeight;
	    if (typeof image.touchesStart.x === 'undefined' && e) {
	      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
	      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
	    } else {
	      touchX = image.touchesStart.x;
	      touchY = image.touchesStart.y;
	    }
	    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    if (e) {
	      slideWidth = gesture.$slideEl[0].offsetWidth;
	      slideHeight = gesture.$slideEl[0].offsetHeight;
	      offsetX = gesture.$slideEl.offset().left;
	      offsetY = gesture.$slideEl.offset().top;
	      diffX = offsetX + slideWidth / 2 - touchX;
	      diffY = offsetY + slideHeight / 2 - touchY;
	      imageWidth = gesture.$imageEl[0].offsetWidth;
	      imageHeight = gesture.$imageEl[0].offsetHeight;
	      scaledWidth = imageWidth * zoom.scale;
	      scaledHeight = imageHeight * zoom.scale;
	      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
	      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
	      translateMaxX = -translateMinX;
	      translateMaxY = -translateMinY;
	      translateX = diffX * zoom.scale;
	      translateY = diffY * zoom.scale;
	      if (translateX < translateMinX) {
	        translateX = translateMinX;
	      }
	      if (translateX > translateMaxX) {
	        translateX = translateMaxX;
	      }
	      if (translateY < translateMinY) {
	        translateY = translateMinY;
	      }
	      if (translateY > translateMaxY) {
	        translateY = translateMaxY;
	      }
	    } else {
	      translateX = 0;
	      translateY = 0;
	    }
	    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
	    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
	  },
	  out() {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    const params = swiper.params.zoom;
	    const {
	      gesture
	    } = zoom;
	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
	    zoom.scale = 1;
	    zoom.currentScale = 1;
	    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
	    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
	    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
	    gesture.$slideEl = undefined;
	  },
	  // Attach/Detach Events
	  enable() {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    if (zoom.enabled) return;
	    zoom.enabled = true;
	    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
	      passive: true,
	      capture: false
	    } : false;

	    // Scale image
	    if (Support.gestures) {
	      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
	  },
	  disable() {
	    const swiper = this;
	    const zoom = swiper.zoom;
	    if (!zoom.enabled) return;
	    swiper.zoom.enabled = false;
	    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
	      passive: true,
	      capture: false
	    } : false;

	    // Scale image
	    if (Support.gestures) {
	      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
	  }
	};
	var Zoom$1 = {
	  name: 'zoom',
	  params: {
	    zoom: {
	      enabled: false,
	      maxRatio: 3,
	      minRatio: 1,
	      toggle: true,
	      containerClass: 'swiper-zoom-container',
	      zoomedSlideClass: 'swiper-slide-zoomed'
	    }
	  },
	  create() {
	    const swiper = this;
	    const zoom = {
	      enabled: false,
	      scale: 1,
	      currentScale: 1,
	      isScaling: false,
	      gesture: {
	        $slideEl: undefined,
	        slideWidth: undefined,
	        slideHeight: undefined,
	        $imageEl: undefined,
	        $imageWrapEl: undefined,
	        maxRatio: 3
	      },
	      image: {
	        isTouched: undefined,
	        isMoved: undefined,
	        currentX: undefined,
	        currentY: undefined,
	        minX: undefined,
	        minY: undefined,
	        maxX: undefined,
	        maxY: undefined,
	        width: undefined,
	        height: undefined,
	        startX: undefined,
	        startY: undefined,
	        touchesStart: {},
	        touchesCurrent: {}
	      },
	      velocity: {
	        x: undefined,
	        y: undefined,
	        prevPositionX: undefined,
	        prevPositionY: undefined,
	        prevTime: undefined
	      }
	    };
	    'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(methodName => {
	      zoom[methodName] = Zoom[methodName].bind(swiper);
	    });
	    Utils.extend(swiper, {
	      zoom
	    });
	    let scale = 1;
	    Object.defineProperty(swiper.zoom, 'scale', {
	      get() {
	        return scale;
	      },
	      set(value) {
	        if (scale !== value) {
	          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
	          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
	          swiper.emit('zoomChange', value, imageEl, slideEl);
	        }
	        scale = value;
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.zoom.enabled) {
	        swiper.zoom.enable();
	      }
	    },
	    destroy() {
	      const swiper = this;
	      swiper.zoom.disable();
	    },
	    touchStart(e) {
	      const swiper = this;
	      if (!swiper.zoom.enabled) return;
	      swiper.zoom.onTouchStart(e);
	    },
	    touchEnd(e) {
	      const swiper = this;
	      if (!swiper.zoom.enabled) return;
	      swiper.zoom.onTouchEnd(e);
	    },
	    doubleTap(e) {
	      const swiper = this;
	      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
	        swiper.zoom.toggle(e);
	      }
	    },
	    transitionEnd() {
	      const swiper = this;
	      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
	        swiper.zoom.onTransitionEnd();
	      }
	    }
	  }
	};
	const Lazy = {
	  loadInSlide(index) {
	    let loadInDuplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    const swiper = this;
	    const params = swiper.params.lazy;
	    if (typeof index === 'undefined') return;
	    if (swiper.slides.length === 0) return;
	    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	    const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
	    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
	    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
	      $images = $images.add($slideEl[0]);
	    }
	    if ($images.length === 0) return;
	    $images.each((imageIndex, imageEl) => {
	      const $imageEl = $$1(imageEl);
	      $imageEl.addClass(params.loadingClass);
	      const background = $imageEl.attr('data-background');
	      const src = $imageEl.attr('data-src');
	      const srcset = $imageEl.attr('data-srcset');
	      const sizes = $imageEl.attr('data-sizes');
	      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
	        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
	        if (background) {
	          $imageEl.css('background-image', `url("${background}")`);
	          $imageEl.removeAttr('data-background');
	        } else {
	          if (srcset) {
	            $imageEl.attr('srcset', srcset);
	            $imageEl.removeAttr('data-srcset');
	          }
	          if (sizes) {
	            $imageEl.attr('sizes', sizes);
	            $imageEl.removeAttr('data-sizes');
	          }
	          if (src) {
	            $imageEl.attr('src', src);
	            $imageEl.removeAttr('data-src');
	          }
	        }
	        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
	        $slideEl.find(`.${params.preloaderClass}`).remove();
	        if (swiper.params.loop && loadInDuplicate) {
	          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
	          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
	            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
	            swiper.lazy.loadInSlide(originalSlide.index(), false);
	          } else {
	            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
	            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
	          }
	        }
	        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
	      });
	      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
	    });
	  },
	  load() {
	    const swiper = this;
	    const {
	      $wrapperEl,
	      params: swiperParams,
	      slides,
	      activeIndex
	    } = swiper;
	    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
	    const params = swiperParams.lazy;
	    let slidesPerView = swiperParams.slidesPerView;
	    if (slidesPerView === 'auto') {
	      slidesPerView = 0;
	    }
	    function slideExist(index) {
	      if (isVirtual) {
	        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
	          return true;
	        }
	      } else if (slides[index]) return true;
	      return false;
	    }
	    function slideIndex(slideEl) {
	      if (isVirtual) {
	        return $$1(slideEl).attr('data-swiper-slide-index');
	      }
	      return $$1(slideEl).index();
	    }
	    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
	    if (swiper.params.watchSlidesVisibility) {
	      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
	        const index = isVirtual ? $$1(slideEl).attr('data-swiper-slide-index') : $$1(slideEl).index();
	        swiper.lazy.loadInSlide(index);
	      });
	    } else if (slidesPerView > 1) {
	      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
	        if (slideExist(i)) swiper.lazy.loadInSlide(i);
	      }
	    } else {
	      swiper.lazy.loadInSlide(activeIndex);
	    }
	    if (params.loadPrevNext) {
	      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
	        const amount = params.loadPrevNextAmount;
	        const spv = slidesPerView;
	        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
	        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
	        // Next Slides
	        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
	          if (slideExist(i)) swiper.lazy.loadInSlide(i);
	        }
	        // Prev Slides
	        for (let i = minIndex; i < activeIndex; i += 1) {
	          if (slideExist(i)) swiper.lazy.loadInSlide(i);
	        }
	      } else {
	        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
	        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
	        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
	        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
	      }
	    }
	  }
	};
	var Lazy$1 = {
	  name: 'lazy',
	  params: {
	    lazy: {
	      enabled: false,
	      loadPrevNext: false,
	      loadPrevNextAmount: 1,
	      loadOnTransitionStart: false,
	      elementClass: 'swiper-lazy',
	      loadingClass: 'swiper-lazy-loading',
	      loadedClass: 'swiper-lazy-loaded',
	      preloaderClass: 'swiper-lazy-preloader'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      lazy: {
	        initialImageLoaded: false,
	        load: Lazy.load.bind(swiper),
	        loadInSlide: Lazy.loadInSlide.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
	        swiper.params.preloadImages = false;
	      }
	    },
	    init() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
	        swiper.lazy.load();
	      }
	    },
	    scroll() {
	      const swiper = this;
	      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
	        swiper.lazy.load();
	      }
	    },
	    resize() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    scrollbarDragMove() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    transitionStart() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled) {
	        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
	          swiper.lazy.load();
	        }
	      }
	    },
	    transitionEnd() {
	      const swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
	        swiper.lazy.load();
	      }
	    }
	  }
	};

	/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

	const Controller = {
	  LinearSpline: function LinearSpline(x, y) {
	    const binarySearch = function search() {
	      let maxIndex;
	      let minIndex;
	      let guess;
	      return (array, val) => {
	        minIndex = -1;
	        maxIndex = array.length;
	        while (maxIndex - minIndex > 1) {
	          guess = maxIndex + minIndex >> 1;
	          if (array[guess] <= val) {
	            minIndex = guess;
	          } else {
	            maxIndex = guess;
	          }
	        }
	        return maxIndex;
	      };
	    }();
	    this.x = x;
	    this.y = y;
	    this.lastIndex = x.length - 1;
	    // Given an x value (x2), return the expected y2 value:
	    // (x1,y1) is the known point before given value,
	    // (x3,y3) is the known point after given value.
	    let i1;
	    let i3;
	    this.interpolate = function interpolate(x2) {
	      if (!x2) return 0;

	      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	      i3 = binarySearch(this.x, x2);
	      i1 = i3 - 1;

	      // We have our indexes i1 & i3, so we can calculate already:
	      // y2 := ((x2âx1) Ã (y3ây1)) Ã· (x3âx1) + y1
	      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
	    };
	    return this;
	  },
	  // xxx: for now i will just save one spline function to to
	  getInterpolateFunction(c) {
	    const swiper = this;
	    if (!swiper.controller.spline) {
	      swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
	    }
	  },
	  setTranslate(setTranslate, byController) {
	    const swiper = this;
	    const controlled = swiper.controller.control;
	    let multiplier;
	    let controlledTranslate;
	    function setControlledTranslate(c) {
	      // this will create an Interpolate function based on the snapGrids
	      // x is the Grid of the scrolled scroller and y will be the controlled scroller
	      // it makes sense to create this only once and recall it for the interpolation
	      // the function does a lot of value caching for performance
	      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
	      if (swiper.params.controller.by === 'slide') {
	        swiper.controller.getInterpolateFunction(c);
	        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	        // but it did not work out
	        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
	      }
	      if (!controlledTranslate || swiper.params.controller.by === 'container') {
	        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
	        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
	      }
	      if (swiper.params.controller.inverse) {
	        controlledTranslate = c.maxTranslate() - controlledTranslate;
	      }
	      c.updateProgress(controlledTranslate);
	      c.setTranslate(controlledTranslate, swiper);
	      c.updateActiveIndex();
	      c.updateSlidesClasses();
	    }
	    if (Array.isArray(controlled)) {
	      for (let i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	          setControlledTranslate(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper && byController !== controlled) {
	      setControlledTranslate(controlled);
	    }
	  },
	  setTransition(duration, byController) {
	    const swiper = this;
	    const controlled = swiper.controller.control;
	    let i;
	    function setControlledTransition(c) {
	      c.setTransition(duration, swiper);
	      if (duration !== 0) {
	        c.transitionStart();
	        if (c.params.autoHeight) {
	          Utils.nextTick(() => {
	            c.updateAutoHeight();
	          });
	        }
	        c.$wrapperEl.transitionEnd(() => {
	          if (!controlled) return;
	          if (c.params.loop && swiper.params.controller.by === 'slide') {
	            c.loopFix();
	          }
	          c.transitionEnd();
	        });
	      }
	    }
	    if (Array.isArray(controlled)) {
	      for (i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	          setControlledTransition(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper && byController !== controlled) {
	      setControlledTransition(controlled);
	    }
	  }
	};
	var Controller$1 = {
	  name: 'controller',
	  params: {
	    controller: {
	      control: undefined,
	      inverse: false,
	      by: 'slide' // or 'container'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      controller: {
	        control: swiper.params.controller.control,
	        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
	        setTranslate: Controller.setTranslate.bind(swiper),
	        setTransition: Controller.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    update() {
	      const swiper = this;
	      if (!swiper.controller.control) return;
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    resize() {
	      const swiper = this;
	      if (!swiper.controller.control) return;
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    observerUpdate() {
	      const swiper = this;
	      if (!swiper.controller.control) return;
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    setTranslate(translate, byController) {
	      const swiper = this;
	      if (!swiper.controller.control) return;
	      swiper.controller.setTranslate(translate, byController);
	    },
	    setTransition(duration, byController) {
	      const swiper = this;
	      if (!swiper.controller.control) return;
	      swiper.controller.setTransition(duration, byController);
	    }
	  }
	};
	const a11y = {
	  makeElFocusable($el) {
	    $el.attr('tabIndex', '0');
	    return $el;
	  },
	  addElRole($el, role) {
	    $el.attr('role', role);
	    return $el;
	  },
	  addElLabel($el, label) {
	    $el.attr('aria-label', label);
	    return $el;
	  },
	  disableEl($el) {
	    $el.attr('aria-disabled', true);
	    return $el;
	  },
	  enableEl($el) {
	    $el.attr('aria-disabled', false);
	    return $el;
	  },
	  onEnterKey(e) {
	    const swiper = this;
	    const params = swiper.params.a11y;
	    if (e.keyCode !== 13) return;
	    const $targetEl = $$1(e.target);
	    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
	      if (!(swiper.isEnd && !swiper.params.loop)) {
	        swiper.slideNext();
	      }
	      if (swiper.isEnd) {
	        swiper.a11y.notify(params.lastSlideMessage);
	      } else {
	        swiper.a11y.notify(params.nextSlideMessage);
	      }
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
	      if (!(swiper.isBeginning && !swiper.params.loop)) {
	        swiper.slidePrev();
	      }
	      if (swiper.isBeginning) {
	        swiper.a11y.notify(params.firstSlideMessage);
	      } else {
	        swiper.a11y.notify(params.prevSlideMessage);
	      }
	    }
	    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
	      $targetEl[0].click();
	    }
	  },
	  notify(message) {
	    const swiper = this;
	    const notification = swiper.a11y.liveRegion;
	    if (notification.length === 0) return;
	    notification.html('');
	    notification.html(message);
	  },
	  updateNavigation() {
	    const swiper = this;
	    if (swiper.params.loop) return;
	    const {
	      $nextEl,
	      $prevEl
	    } = swiper.navigation;
	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        swiper.a11y.disableEl($prevEl);
	      } else {
	        swiper.a11y.enableEl($prevEl);
	      }
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        swiper.a11y.disableEl($nextEl);
	      } else {
	        swiper.a11y.enableEl($nextEl);
	      }
	    }
	  },
	  updatePagination() {
	    const swiper = this;
	    const params = swiper.params.a11y;
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
	        const $bulletEl = $$1(bulletEl);
	        swiper.a11y.makeElFocusable($bulletEl);
	        swiper.a11y.addElRole($bulletEl, 'button');
	        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
	      });
	    }
	  },
	  init() {
	    const swiper = this;
	    swiper.$el.append(swiper.a11y.liveRegion);

	    // Navigation
	    const params = swiper.params.a11y;
	    let $nextEl;
	    let $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      swiper.a11y.makeElFocusable($nextEl);
	      swiper.a11y.addElRole($nextEl, 'button');
	      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
	      $nextEl.on('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      swiper.a11y.makeElFocusable($prevEl);
	      swiper.a11y.addElRole($prevEl, 'button');
	      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
	      $prevEl.on('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
	    }
	  },
	  destroy() {
	    const swiper = this;
	    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
	    let $nextEl;
	    let $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      $nextEl.off('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      $prevEl.off('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
	    }
	  }
	};
	var A11y = {
	  name: 'a11y',
	  params: {
	    a11y: {
	      enabled: true,
	      notificationClass: 'swiper-notification',
	      prevSlideMessage: 'Previous slide',
	      nextSlideMessage: 'Next slide',
	      firstSlideMessage: 'This is the first slide',
	      lastSlideMessage: 'This is the last slide',
	      paginationBulletMessage: 'Go to slide {{index}}'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      a11y: {
	        liveRegion: $$1(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
	      }
	    });
	    Object.keys(a11y).forEach(methodName => {
	      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (!swiper.params.a11y.enabled) return;
	      swiper.a11y.init();
	      swiper.a11y.updateNavigation();
	    },
	    toEdge() {
	      const swiper = this;
	      if (!swiper.params.a11y.enabled) return;
	      swiper.a11y.updateNavigation();
	    },
	    fromEdge() {
	      const swiper = this;
	      if (!swiper.params.a11y.enabled) return;
	      swiper.a11y.updateNavigation();
	    },
	    paginationUpdate() {
	      const swiper = this;
	      if (!swiper.params.a11y.enabled) return;
	      swiper.a11y.updatePagination();
	    },
	    destroy() {
	      const swiper = this;
	      if (!swiper.params.a11y.enabled) return;
	      swiper.a11y.destroy();
	    }
	  }
	};
	const History = {
	  init() {
	    const swiper = this;
	    if (!swiper.params.history) return;
	    if (!win.history || !win.history.pushState) {
	      swiper.params.history.enabled = false;
	      swiper.params.hashNavigation.enabled = true;
	      return;
	    }
	    const history = swiper.history;
	    history.initialized = true;
	    history.paths = History.getPathValues();
	    if (!history.paths.key && !history.paths.value) return;
	    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
	    if (!swiper.params.history.replaceState) {
	      win.addEventListener('popstate', swiper.history.setHistoryPopState);
	    }
	  },
	  destroy() {
	    const swiper = this;
	    if (!swiper.params.history.replaceState) {
	      win.removeEventListener('popstate', swiper.history.setHistoryPopState);
	    }
	  },
	  setHistoryPopState() {
	    const swiper = this;
	    swiper.history.paths = History.getPathValues();
	    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
	  },
	  getPathValues() {
	    const pathArray = win.location.pathname.slice(1).split('/').filter(part => part !== '');
	    const total = pathArray.length;
	    const key = pathArray[total - 2];
	    const value = pathArray[total - 1];
	    return {
	      key,
	      value
	    };
	  },
	  setHistory(key, index) {
	    const swiper = this;
	    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
	    const slide = swiper.slides.eq(index);
	    let value = History.slugify(slide.attr('data-history'));
	    if (!win.location.pathname.includes(key)) {
	      value = `${key}/${value}`;
	    }
	    const currentState = win.history.state;
	    if (currentState && currentState.value === value) {
	      return;
	    }
	    if (swiper.params.history.replaceState) {
	      win.history.replaceState({
	        value
	      }, null, value);
	    } else {
	      win.history.pushState({
	        value
	      }, null, value);
	    }
	  },
	  slugify(text) {
	    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
	  },
	  scrollToSlide(speed, value, runCallbacks) {
	    const swiper = this;
	    if (value) {
	      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
	        const slide = swiper.slides.eq(i);
	        const slideHistory = History.slugify(slide.attr('data-history'));
	        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
	          const index = slide.index();
	          swiper.slideTo(index, speed, runCallbacks);
	        }
	      }
	    } else {
	      swiper.slideTo(0, speed, runCallbacks);
	    }
	  }
	};
	var History$1 = {
	  name: 'history',
	  params: {
	    history: {
	      enabled: false,
	      replaceState: false,
	      key: 'slides'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      history: {
	        init: History.init.bind(swiper),
	        setHistory: History.setHistory.bind(swiper),
	        setHistoryPopState: History.setHistoryPopState.bind(swiper),
	        scrollToSlide: History.scrollToSlide.bind(swiper),
	        destroy: History.destroy.bind(swiper)
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.history.enabled) {
	        swiper.history.init();
	      }
	    },
	    destroy() {
	      const swiper = this;
	      if (swiper.params.history.enabled) {
	        swiper.history.destroy();
	      }
	    },
	    transitionEnd() {
	      const swiper = this;
	      if (swiper.history.initialized) {
	        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
	      }
	    }
	  }
	};
	const HashNavigation = {
	  onHashCange() {
	    const swiper = this;
	    const newHash = doc.location.hash.replace('#', '');
	    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
	    if (newHash !== activeSlideHash) {
	      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
	      if (typeof newIndex === 'undefined') return;
	      swiper.slideTo(newIndex);
	    }
	  },
	  setHash() {
	    const swiper = this;
	    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
	    if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
	      win.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
	    } else {
	      const slide = swiper.slides.eq(swiper.activeIndex);
	      const hash = slide.attr('data-hash') || slide.attr('data-history');
	      doc.location.hash = hash || '';
	    }
	  },
	  init() {
	    const swiper = this;
	    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
	    swiper.hashNavigation.initialized = true;
	    const hash = doc.location.hash.replace('#', '');
	    if (hash) {
	      const speed = 0;
	      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
	        const slide = swiper.slides.eq(i);
	        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
	        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
	          const index = slide.index();
	          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
	        }
	      }
	    }
	    if (swiper.params.hashNavigation.watchState) {
	      $$1(win).on('hashchange', swiper.hashNavigation.onHashCange);
	    }
	  },
	  destroy() {
	    const swiper = this;
	    if (swiper.params.hashNavigation.watchState) {
	      $$1(win).off('hashchange', swiper.hashNavigation.onHashCange);
	    }
	  }
	};
	var HashNavigation$1 = {
	  name: 'hash-navigation',
	  params: {
	    hashNavigation: {
	      enabled: false,
	      replaceState: false,
	      watchState: false
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      hashNavigation: {
	        initialized: false,
	        init: HashNavigation.init.bind(swiper),
	        destroy: HashNavigation.destroy.bind(swiper),
	        setHash: HashNavigation.setHash.bind(swiper),
	        onHashCange: HashNavigation.onHashCange.bind(swiper)
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.hashNavigation.enabled) {
	        swiper.hashNavigation.init();
	      }
	    },
	    destroy() {
	      const swiper = this;
	      if (swiper.params.hashNavigation.enabled) {
	        swiper.hashNavigation.destroy();
	      }
	    },
	    transitionEnd() {
	      const swiper = this;
	      if (swiper.hashNavigation.initialized) {
	        swiper.hashNavigation.setHash();
	      }
	    }
	  }
	};

	/* eslint no-underscore-dangle: "off" */

	const Autoplay = {
	  run() {
	    const swiper = this;
	    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
	    let delay = swiper.params.autoplay.delay;
	    if ($activeSlideEl.attr('data-swiper-autoplay')) {
	      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
	    }
	    swiper.autoplay.timeout = Utils.nextTick(() => {
	      if (swiper.params.autoplay.reverseDirection) {
	        if (swiper.params.loop) {
	          swiper.loopFix();
	          swiper.slidePrev(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.isBeginning) {
	          swiper.slidePrev(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.params.autoplay.stopOnLastSlide) {
	          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else {
	          swiper.autoplay.stop();
	        }
	      } else if (swiper.params.loop) {
	        swiper.loopFix();
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.isEnd) {
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.params.autoplay.stopOnLastSlide) {
	        swiper.slideTo(0, swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else {
	        swiper.autoplay.stop();
	      }
	    }, delay);
	  },
	  start() {
	    const swiper = this;
	    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
	    if (swiper.autoplay.running) return false;
	    swiper.autoplay.running = true;
	    swiper.emit('autoplayStart');
	    swiper.autoplay.run();
	    return true;
	  },
	  stop() {
	    const swiper = this;
	    if (!swiper.autoplay.running) return false;
	    if (typeof swiper.autoplay.timeout === 'undefined') return false;
	    if (swiper.autoplay.timeout) {
	      clearTimeout(swiper.autoplay.timeout);
	      swiper.autoplay.timeout = undefined;
	    }
	    swiper.autoplay.running = false;
	    swiper.emit('autoplayStop');
	    return true;
	  },
	  pause(speed) {
	    const swiper = this;
	    if (!swiper.autoplay.running) return;
	    if (swiper.autoplay.paused) return;
	    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
	    swiper.autoplay.paused = true;
	    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
	      swiper.autoplay.paused = false;
	      swiper.autoplay.run();
	    } else {
	      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	    }
	  }
	};
	var Autoplay$1 = {
	  name: 'autoplay',
	  params: {
	    autoplay: {
	      enabled: false,
	      delay: 3000,
	      waitForTransition: true,
	      disableOnInteraction: true,
	      stopOnLastSlide: false,
	      reverseDirection: false
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      autoplay: {
	        running: false,
	        paused: false,
	        run: Autoplay.run.bind(swiper),
	        start: Autoplay.start.bind(swiper),
	        stop: Autoplay.stop.bind(swiper),
	        pause: Autoplay.pause.bind(swiper),
	        onTransitionEnd(e) {
	          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
	          if (e.target !== this) return;
	          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	          swiper.autoplay.paused = false;
	          if (!swiper.autoplay.running) {
	            swiper.autoplay.stop();
	          } else {
	            swiper.autoplay.run();
	          }
	        }
	      }
	    });
	  },
	  on: {
	    init() {
	      const swiper = this;
	      if (swiper.params.autoplay.enabled) {
	        swiper.autoplay.start();
	      }
	    },
	    beforeTransitionStart(speed, internal) {
	      const swiper = this;
	      if (swiper.autoplay.running) {
	        if (internal || !swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.pause(speed);
	        } else {
	          swiper.autoplay.stop();
	        }
	      }
	    },
	    sliderFirstMove() {
	      const swiper = this;
	      if (swiper.autoplay.running) {
	        if (swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.stop();
	        } else {
	          swiper.autoplay.pause();
	        }
	      }
	    },
	    destroy() {
	      const swiper = this;
	      if (swiper.autoplay.running) {
	        swiper.autoplay.stop();
	      }
	    }
	  }
	};
	const Fade = {
	  setTranslate() {
	    const swiper = this;
	    const {
	      slides
	    } = swiper;
	    for (let i = 0; i < slides.length; i += 1) {
	      const $slideEl = swiper.slides.eq(i);
	      const offset = $slideEl[0].swiperSlideOffset;
	      let tx = -offset;
	      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
	      let ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	      }
	      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
	      $slideEl.css({
	        opacity: slideOpacity
	      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
	    }
	  },
	  setTransition(duration) {
	    const swiper = this;
	    const {
	      slides,
	      $wrapperEl
	    } = swiper;
	    slides.transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      let eventTriggered = false;
	      slides.transitionEnd(() => {
	        if (eventTriggered) return;
	        if (!swiper || swiper.destroyed) return;
	        eventTriggered = true;
	        swiper.animating = false;
	        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (let i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  }
	};
	var EffectFade = {
	  name: 'effect-fade',
	  params: {
	    fadeEffect: {
	      crossFade: false
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      fadeEffect: {
	        setTranslate: Fade.setTranslate.bind(swiper),
	        setTransition: Fade.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (swiper.params.effect !== 'fade') return;
	      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
	      const overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate() {
	      const swiper = this;
	      if (swiper.params.effect !== 'fade') return;
	      swiper.fadeEffect.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      if (swiper.params.effect !== 'fade') return;
	      swiper.fadeEffect.setTransition(duration);
	    }
	  }
	};
	const Cube = {
	  setTranslate() {
	    const swiper = this;
	    const {
	      $el,
	      $wrapperEl,
	      slides,
	      width: swiperWidth,
	      height: swiperHeight,
	      rtlTranslate: rtl,
	      size: swiperSize
	    } = swiper;
	    const params = swiper.params.cubeEffect;
	    const isHorizontal = swiper.isHorizontal();
	    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	    let wrapperRotate = 0;
	    let $cubeShadowEl;
	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $$1('<div class="swiper-cube-shadow"></div>');
	          $wrapperEl.append($cubeShadowEl);
	        }
	        $cubeShadowEl.css({
	          height: `${swiperWidth}px`
	        });
	      } else {
	        $cubeShadowEl = $el.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $$1('<div class="swiper-cube-shadow"></div>');
	          $el.append($cubeShadowEl);
	        }
	      }
	    }
	    for (let i = 0; i < slides.length; i += 1) {
	      const $slideEl = slides.eq(i);
	      let slideIndex = i;
	      if (isVirtual) {
	        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
	      }
	      let slideAngle = slideIndex * 90;
	      let round = Math.floor(slideAngle / 360);
	      if (rtl) {
	        slideAngle = -slideAngle;
	        round = Math.floor(-slideAngle / 360);
	      }
	      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      let tx = 0;
	      let ty = 0;
	      let tz = 0;
	      if (slideIndex % 4 === 0) {
	        tx = -round * 4 * swiperSize;
	        tz = 0;
	      } else if ((slideIndex - 1) % 4 === 0) {
	        tx = 0;
	        tz = -round * 4 * swiperSize;
	      } else if ((slideIndex - 2) % 4 === 0) {
	        tx = swiperSize + round * 4 * swiperSize;
	        tz = swiperSize;
	      } else if ((slideIndex - 3) % 4 === 0) {
	        tx = -swiperSize;
	        tz = 3 * swiperSize + swiperSize * 4 * round;
	      }
	      if (rtl) {
	        tx = -tx;
	      }
	      if (!isHorizontal) {
	        ty = tx;
	        tx = 0;
	      }
	      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
	      if (progress <= 1 && progress > -1) {
	        wrapperRotate = slideIndex * 90 + progress * 90;
	        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
	      }
	      $slideEl.transform(transform);
	      if (params.slideShadows) {
	        // Set shadows
	        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
	        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
	      }
	    }
	    $wrapperEl.css({
	      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
	      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
	      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
	      'transform-origin': `50% 50% -${swiperSize / 2}px`
	    });
	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
	      } else {
	        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
	        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
	        const scale1 = params.shadowScale;
	        const scale2 = params.shadowScale / multiplier;
	        const offset = params.shadowOffset;
	        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
	      }
	    }
	    const zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
	    $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
	  },
	  setTransition(duration) {
	    const swiper = this;
	    const {
	      $el,
	      slides
	    } = swiper;
	    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
	      $el.find('.swiper-cube-shadow').transition(duration);
	    }
	  }
	};
	var EffectCube = {
	  name: 'effect-cube',
	  params: {
	    cubeEffect: {
	      slideShadows: true,
	      shadow: true,
	      shadowOffset: 20,
	      shadowScale: 0.94
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      cubeEffect: {
	        setTranslate: Cube.setTranslate.bind(swiper),
	        setTransition: Cube.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (swiper.params.effect !== 'cube') return;
	      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
	      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
	      const overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        resistanceRatio: 0,
	        spaceBetween: 0,
	        centeredSlides: false,
	        virtualTranslate: true
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate() {
	      const swiper = this;
	      if (swiper.params.effect !== 'cube') return;
	      swiper.cubeEffect.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      if (swiper.params.effect !== 'cube') return;
	      swiper.cubeEffect.setTransition(duration);
	    }
	  }
	};
	const Flip = {
	  setTranslate() {
	    const swiper = this;
	    const {
	      slides,
	      rtlTranslate: rtl
	    } = swiper;
	    for (let i = 0; i < slides.length; i += 1) {
	      const $slideEl = slides.eq(i);
	      let progress = $slideEl[0].progress;
	      if (swiper.params.flipEffect.limitRotation) {
	        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      }
	      const offset = $slideEl[0].swiperSlideOffset;
	      const rotate = -180 * progress;
	      let rotateY = rotate;
	      let rotateX = 0;
	      let tx = -offset;
	      let ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	        rotateX = -rotateY;
	        rotateY = 0;
	      } else if (rtl) {
	        rotateY = -rotateY;
	      }
	      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
	      if (swiper.params.flipEffect.slideShadows) {
	        // Set shadows
	        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $$1(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $$1(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
	        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
	      }
	      $slideEl.transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
	    }
	  },
	  setTransition(duration) {
	    const swiper = this;
	    const {
	      slides,
	      activeIndex,
	      $wrapperEl
	    } = swiper;
	    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      let eventTriggered = false;
	      // eslint-disable-next-line
	      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
	        if (eventTriggered) return;
	        if (!swiper || swiper.destroyed) return;
	        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
	        eventTriggered = true;
	        swiper.animating = false;
	        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (let i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  }
	};
	var EffectFlip = {
	  name: 'effect-flip',
	  params: {
	    flipEffect: {
	      slideShadows: true,
	      limitRotation: true
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      flipEffect: {
	        setTranslate: Flip.setTranslate.bind(swiper),
	        setTransition: Flip.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (swiper.params.effect !== 'flip') return;
	      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
	      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
	      const overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate() {
	      const swiper = this;
	      if (swiper.params.effect !== 'flip') return;
	      swiper.flipEffect.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      if (swiper.params.effect !== 'flip') return;
	      swiper.flipEffect.setTransition(duration);
	    }
	  }
	};
	const Coverflow = {
	  setTranslate() {
	    const swiper = this;
	    const {
	      width: swiperWidth,
	      height: swiperHeight,
	      slides,
	      $wrapperEl,
	      slidesSizesGrid
	    } = swiper;
	    const params = swiper.params.coverflowEffect;
	    const isHorizontal = swiper.isHorizontal();
	    const transform = swiper.translate;
	    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
	    const rotate = isHorizontal ? params.rotate : -params.rotate;
	    const translate = params.depth;
	    // Each slide offset from center
	    for (let i = 0, length = slides.length; i < length; i += 1) {
	      const $slideEl = slides.eq(i);
	      const slideSize = slidesSizesGrid[i];
	      const slideOffset = $slideEl[0].swiperSlideOffset;
	      const offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
	      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
	      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
	      // var rotateZ = 0
	      let translateZ = -translate * Math.abs(offsetMultiplier);
	      let translateY = isHorizontal ? 0 : params.stretch * offsetMultiplier;
	      let translateX = isHorizontal ? params.stretch * offsetMultiplier : 0;

	      // Fix for ultra small values
	      if (Math.abs(translateX) < 0.001) translateX = 0;
	      if (Math.abs(translateY) < 0.001) translateY = 0;
	      if (Math.abs(translateZ) < 0.001) translateZ = 0;
	      if (Math.abs(rotateY) < 0.001) rotateY = 0;
	      if (Math.abs(rotateX) < 0.001) rotateX = 0;
	      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
	      $slideEl.transform(slideTransform);
	      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	      if (params.slideShadows) {
	        // Set shadows
	        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if ($shadowBeforeEl.length === 0) {
	          $shadowBeforeEl = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
	          $slideEl.append($shadowBeforeEl);
	        }
	        if ($shadowAfterEl.length === 0) {
	          $shadowAfterEl = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
	          $slideEl.append($shadowAfterEl);
	        }
	        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
	        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
	      }
	    }

	    // Set correct perspective for IE10
	    if (Support.pointerEvents || Support.prefixedPointerEvents) {
	      const ws = $wrapperEl[0].style;
	      ws.perspectiveOrigin = `${center}px 50%`;
	    }
	  },
	  setTransition(duration) {
	    const swiper = this;
	    swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	  }
	};
	var EffectCoverflow = {
	  name: 'effect-coverflow',
	  params: {
	    coverflowEffect: {
	      rotate: 50,
	      stretch: 0,
	      depth: 100,
	      modifier: 1,
	      slideShadows: true
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      coverflowEffect: {
	        setTranslate: Coverflow.setTranslate.bind(swiper),
	        setTransition: Coverflow.setTransition.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      if (swiper.params.effect !== 'coverflow') return;
	      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
	      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
	      swiper.params.watchSlidesProgress = true;
	      swiper.originalParams.watchSlidesProgress = true;
	    },
	    setTranslate() {
	      const swiper = this;
	      if (swiper.params.effect !== 'coverflow') return;
	      swiper.coverflowEffect.setTranslate();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      if (swiper.params.effect !== 'coverflow') return;
	      swiper.coverflowEffect.setTransition(duration);
	    }
	  }
	};
	const Thumbs = {
	  init() {
	    const swiper = this;
	    const {
	      thumbs: thumbsParams
	    } = swiper.params;
	    const SwiperClass = swiper.constructor;
	    if (thumbsParams.swiper instanceof SwiperClass) {
	      swiper.thumbs.swiper = thumbsParams.swiper;
	      Utils.extend(swiper.thumbs.swiper.originalParams, {
	        watchSlidesProgress: true,
	        slideToClickedSlide: false
	      });
	      Utils.extend(swiper.thumbs.swiper.params, {
	        watchSlidesProgress: true,
	        slideToClickedSlide: false
	      });
	    } else if (Utils.isObject(thumbsParams.swiper)) {
	      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
	        watchSlidesVisibility: true,
	        watchSlidesProgress: true,
	        slideToClickedSlide: false
	      }));
	      swiper.thumbs.swiperCreated = true;
	    }
	    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
	    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
	  },
	  onThumbClick() {
	    const swiper = this;
	    const thumbsSwiper = swiper.thumbs.swiper;
	    if (!thumbsSwiper) return;
	    const clickedIndex = thumbsSwiper.clickedIndex;
	    const clickedSlide = thumbsSwiper.clickedSlide;
	    if (clickedSlide && $$1(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
	    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
	    let slideToIndex;
	    if (thumbsSwiper.params.loop) {
	      slideToIndex = parseInt($$1(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	    } else {
	      slideToIndex = clickedIndex;
	    }
	    if (swiper.params.loop) {
	      let currentIndex = swiper.activeIndex;
	      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
	        swiper.loopFix();
	        // eslint-disable-next-line
	        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	        currentIndex = swiper.activeIndex;
	      }
	      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
	      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
	      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
	    }
	    swiper.slideTo(slideToIndex);
	  },
	  update(initial) {
	    const swiper = this;
	    const thumbsSwiper = swiper.thumbs.swiper;
	    if (!thumbsSwiper) return;
	    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
	    if (swiper.realIndex !== thumbsSwiper.realIndex) {
	      let currentThumbsIndex = thumbsSwiper.activeIndex;
	      let newThumbsIndex;
	      if (thumbsSwiper.params.loop) {
	        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
	          thumbsSwiper.loopFix();
	          // eslint-disable-next-line
	          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
	          currentThumbsIndex = thumbsSwiper.activeIndex;
	        }
	        // Find actual thumbs index to slide to
	        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
	        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
	        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;else newThumbsIndex = prevThumbsIndex;
	      } else {
	        newThumbsIndex = swiper.realIndex;
	      }
	      if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
	        if (thumbsSwiper.params.centeredSlides) {
	          if (newThumbsIndex > currentThumbsIndex) {
	            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
	          } else {
	            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
	          }
	        } else if (newThumbsIndex > currentThumbsIndex) {
	          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
	        }
	        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
	      }
	    }

	    // Activate thumbs
	    let thumbsToActivate = 1;
	    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
	    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
	      thumbsToActivate = swiper.params.slidesPerView;
	    }
	    thumbsSwiper.slides.removeClass(thumbActiveClass);
	    if (thumbsSwiper.params.loop) {
	      for (let i = 0; i < thumbsToActivate; i += 1) {
	        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
	      }
	    } else {
	      for (let i = 0; i < thumbsToActivate; i += 1) {
	        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
	      }
	    }
	  }
	};
	var Thumbs$1 = {
	  name: 'thumbs',
	  params: {
	    thumbs: {
	      swiper: null,
	      slideThumbActiveClass: 'swiper-slide-thumb-active',
	      thumbsContainerClass: 'swiper-container-thumbs'
	    }
	  },
	  create() {
	    const swiper = this;
	    Utils.extend(swiper, {
	      thumbs: {
	        swiper: null,
	        init: Thumbs.init.bind(swiper),
	        update: Thumbs.update.bind(swiper),
	        onThumbClick: Thumbs.onThumbClick.bind(swiper)
	      }
	    });
	  },
	  on: {
	    beforeInit() {
	      const swiper = this;
	      const {
	        thumbs
	      } = swiper.params;
	      if (!thumbs || !thumbs.swiper) return;
	      swiper.thumbs.init();
	      swiper.thumbs.update(true);
	    },
	    slideChange() {
	      const swiper = this;
	      if (!swiper.thumbs.swiper) return;
	      swiper.thumbs.update();
	    },
	    update() {
	      const swiper = this;
	      if (!swiper.thumbs.swiper) return;
	      swiper.thumbs.update();
	    },
	    resize() {
	      const swiper = this;
	      if (!swiper.thumbs.swiper) return;
	      swiper.thumbs.update();
	    },
	    observerUpdate() {
	      const swiper = this;
	      if (!swiper.thumbs.swiper) return;
	      swiper.thumbs.update();
	    },
	    setTransition(duration) {
	      const swiper = this;
	      const thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) return;
	      thumbsSwiper.setTransition(duration);
	    },
	    beforeDestroy() {
	      const swiper = this;
	      const thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) return;
	      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
	        thumbsSwiper.destroy();
	      }
	    }
	  }
	};

	// Swiper Class

	const components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1];
	if (typeof Swiper.use === 'undefined') {
	  Swiper.use = Swiper.Class.use;
	  Swiper.installModule = Swiper.Class.installModule;
	}
	Swiper.use(components);

	function getGEO() {
	  const request = new XMLHttpRequest();
	  request.open('GET', 'https://api.ipgeolocation.io/ipgeo?apiKey=6a0601a8b2424c80a751bfd3962a380b', true);
	  request.onload = function () {
	    var data = JSON.parse(this.response);
	    console.log(data);
	    if (data.country_code2 === 'CA') {
	      document.getElementById('popUpCanadaBox').style.display = 'block';
	      document.getElementById('canadaBoxOverlay').style.display = 'block';
	    } else {
	      document.cookie = 'visitedFromCA_NOT=true; expires=Fri, 31 Dec 2038 23:59:59 GMT';
	    }
	  };
	  request.send();
	}
	if (document.cookie.indexOf('visitedFromCA=') <= 0 && document.cookie.indexOf('visitedFromCA_NOT=') <= 0) {
	  document.cookie = 'visitedFromCA=yes;max-age=172800';
	  getGEO();
	}
	function closeBox() {
	  document.getElementById('popUpCanadaBox').style.display = 'none';
	  document.getElementById('canadaBoxOverlay').style.display = 'none';
	}
	document.querySelector('#stayOn4momsUS').addEventListener('click', closeBox);
	$$2('#CanadaLearnMore').click(function () {
	  $$2('#moreCAInfo').toggleClass('collapsed');
	});
	$$2('#CanadaLearnMore').click(function () {
	  $$2('#alcoArrow').toggleClass('rotateArrow');
	});

	$$2(document).ready(function () {
	  $$2('#CartNote').keydown(function (e) {
	    // Allow: backspace, delete, tab, escape and enter
	    if ($$2.inArray(e.keyCode, [46, 8, 9, 27, 13, 110]) !== -1 ||
	    // Allow: Ctrl+A
	    e.keyCode === 65 && e.ctrlKey === true ||
	    // Allow: home, end, left, right
	    e.keyCode >= 35 && e.keyCode <= 39) {
	      // let it happen, don't do anything
	      return;
	    }
	    // Ensure that it is a number and stop the keypress
	    if (e.altKey === true || e.keyCode === 220 || e.keyCode === 191 && e.shiftKey === false) {
	      e.preventDefault();
	    }
	    if (e.keyCode === 192) {
	      return false;
	    }
	  });
	});

	$$2(window);
	$$2(document.body);
	function logKey(e) {
	  //console.log(e);
	  if (e.key === 'Escape') {
	    document.querySelector('.menu-blocks__block').classList.remove('show');
	  }
	}
	document.addEventListener('keydown', logKey);

	$$2(".tscripts-btn").click(function () {
	  $$2(".transcriptbox").toggle(".transcriptbox__show");
	});

	/**
	 * Variant Selection scripts
	 * ------------------------------------------------------------------------------
	 *
	 * Handles change events from the variant inputs in any `cart/add` forms that may
	 * exist. Also updates the master select and triggers updates when the variants
	 * price or image changes.
	 *
	 */
	class Variants {
	  /**
	   * Variant constructor
	   *
	   * @param {object} options - Settings from `product.js`
	   */
	  constructor(options) {
	    this.$container = options.$container;
	    this.product = options.product;
	    this.singleOptionSelector = options.singleOptionSelector;
	    this.originalSelectorId = options.originalSelectorId;
	    this.enableHistoryState = options.enableHistoryState;
	    this.currentVariant = this._getVariantFromOptions();
	    $$2(this.singleOptionSelector, this.$container).on('change', this._onSelectChange.bind(this));
	  }

	  /**
	   * Get the currently selected options from add-to-cart form. Works with all
	   * form input elements.
	   *
	   * @return {array} options - Values of currently selected variants
	   */
	  _getCurrentOptions() {
	    let currentOptions = $$2.map($$2(this.singleOptionSelector, this.$container), element => {
	      const $element = $$2(element);
	      const type = $element.attr('type');
	      const currentOption = {};

	      /* eslint-disable */
	      // Shopify wrote this code...
	      if (type === 'radio' || type === 'checkbox') {
	        if ($element[0].checked) {
	          currentOption.value = $element.val();
	          currentOption.index = $element.data('index');
	          return currentOption;
	        } else {
	          return false;
	        }
	      } else {
	        currentOption.value = $element.val();
	        currentOption.index = $element.data('index');
	        return currentOption;
	      }
	      /* eslint-enable */
	    });

	    // remove any unchecked input values if using radio buttons or checkboxes
	    currentOptions = compact(currentOptions);
	    return currentOptions;
	  }

	  /**
	   * Find variant based on selected values.
	   *
	   * @param  {array} selectedValues - Values of variant inputs
	   * @return {object || undefined} found - Variant object from product.variants
	   */
	  _getVariantFromOptions() {
	    const selectedValues = this._getCurrentOptions();
	    const variants = this.product.variants;
	    let found = false;
	    variants.forEach(variant => {
	      let satisfied = true;
	      selectedValues.forEach(option => {
	        if (satisfied) {
	          satisfied = option.value === variant[option.index];
	        }
	      });
	      if (satisfied) {
	        found = variant;
	      }
	    });
	    return found || null;
	  }

	  /**
	   * Event handler for when a variant input changes.
	   */
	  _onSelectChange() {
	    const variant = this._getVariantFromOptions();
	    this.$container.trigger({
	      type: 'variantChange',
	      variant: variant
	    });
	    if (!variant) {
	      return;
	    }
	    this._updateMasterSelect(variant);
	    this._updateImages(variant);
	    this._updatePrice(variant);
	    this.currentVariant = variant;
	    if (this.enableHistoryState) {
	      this._updateHistoryState(variant);
	    }
	  }

	  /**
	   * Trigger event when variant image changes
	   *
	   * @param  {object} variant - Currently selected variant
	   * @return {event}  variantImageChange
	   */
	  _updateImages(variant) {
	    const variantImage = variant.featured_image || {};
	    const currentVariantImage = this.currentVariant.featured_image || {};
	    if (!variant.featured_image || variantImage.src === currentVariantImage.src) {
	      return;
	    }
	    this.$container.trigger({
	      type: 'variantImageChange',
	      variant: variant
	    });
	  }

	  /**
	   * Trigger event when variant price changes.
	   *
	   * @param  {object} variant - Currently selected variant
	   * @return {event} variantPriceChange
	   */
	  _updatePrice(variant) {
	    if (variant.price === this.currentVariant.price && variant.compare_at_price === this.currentVariant.compare_at_price) {
	      return;
	    }
	    this.$container.trigger({
	      type: 'variantPriceChange',
	      variant: variant
	    });
	  }

	  /**
	   * Update history state for product deeplinking
	   *
	   * @param  {variant} variant - Currently selected variant
	   * @return {k}         [description]
	   */
	  _updateHistoryState(variant) {
	    if (!window.history.replaceState || !variant) {
	      return;
	    }
	    const newurl = window.location.protocol + '//' + window.location.host + window.location.pathname + '?variant=' + variant.id;
	    window.history.replaceState({
	      path: newurl
	    }, '', newurl);
	  }

	  /**
	   * Update hidden master select of variant change
	   *
	   * @param  {variant} variant - Currently selected variant
	   */
	  _updateMasterSelect(variant) {
	    $$2(this.originalSelectorId, this.$container)[0].value = variant.id;
	  }
	}

	const selectors$6 = {
	  addToCart: '[data-add-to-cart]',
	  addToCartText: '[data-add-to-cart-text]',
	  comparePrice: '[data-compare-price]',
	  comparePriceText: '[data-compare-text]',
	  originalSelectorId: '[data-product-select]',
	  priceWrapper: '[data-price-wrapper]',
	  productJson: '[data-product-json]',
	  productPrice: '[data-product-price]',
	  singleOptionSelector: '[data-single-option-selector]',
	  variantOptionValueList: '[data-variant-option-value-list][data-option-position]',
	  variantOptionValue: '[data-variant-option-value]',
	  quantitySelect: '[data-product-quantity-select]',
	  fullDetailsLink: '[data-full-details-link]',
	  variantName: '[data-variant-name]',
	  bvReviewsNumber: '.bv_numReviews_text',
	  reviewsSummary: '#avg-rating-button',
	  reviewFull: '.bv_button_buttonFull',
	  reviewsAccordion: '#review-collapse',
	  bvReviews: '[data-bv-reviews]',
	  drawerItem: '.spec-tabs .collapse'
	};
	const classes$2 = {
	  hide: 'hide',
	  variantOptionValueActive: 'is-active'
	};
	class ProductDetailForm {
	  /**
	   * ProductDetailForm constructor
	   *
	   * @param { Object } config
	   * @param { jQuery } config.$container - Main element, see snippets/product-detail-form.liquid
	   * @param { Function } config.onVariantChange -  Called when a new variant has been selected from the form,
	   * @param { Boolean } config.enableHistoryState - If set to "true", turns on URL updating when switching variant
	   */
	  constructor(config) {
	    this.settings = {};
	    this.name = 'productDetailForm';
	    this.namespace = `.${this.name}`;
	    this.events = {
	      RESIZE: `resize${this.namespace}`,
	      CLICK: `click${this.namespace}`
	    };
	    const defaults = {
	      $container: null,
	      onVariantChange: $$2.noop,
	      enableHistoryState: true
	    };
	    this.settings = $$2.extend({}, defaults, config);
	    if (!this.settings.$container || this.settings.$container.length === 0) {
	      console.warn(`[${this.name}] - config.$container required to initialize`);
	      return;
	    }

	    /* eslint-disable */
	    /* temporarily disable to allow long lines for element descriptions */
	    this.$container = this.settings.$container; // Scoping element for all DOM lookups
	    this.$quantitySelect = $$2(selectors$6.quantitySelect, this.$container); // Quantity dropdown
	    this.$fullDetailsLink = $$2(selectors$6.fullDetailsLink, this.$container); // Inside quickview, link that points back to the full product
	    this.$addToCartBtn = $$2(selectors$6.addToCart, this.$container);
	    this.$addToCartBtnText = $$2(selectors$6.addToCartText, this.$container); // Text inside the add to cart button
	    this.$priceWrapper = $$2(selectors$6.priceWrapper, this.$container); // Contains all price elements
	    this.$productPrice = $$2(selectors$6.productPrice, this.$container);
	    this.$comparePrice = $$2(selectors$6.comparePrice, this.$container);
	    this.$compareEls = this.$comparePrice.add($$2(selectors$6.comparePriceText, this.$container));
	    this.$singleOptionSelectors = $$2(selectors$6.singleOptionSelector, this.$container); // Dropdowns for each variant option containing all values for that option
	    this.$variantOptionValueList = $$2(selectors$6.variantOptionValueList, this.$container); // Alternate UI that takes the place of a single option selector (could be swatches, dots, buttons, whatever..)
	    this.$variantName = $$2(selectors$6.variantName, this.$container);
	    /* eslint-enable */

	    this.productSingleObject = JSON.parse($$2(selectors$6.productJson, this.$container).html());
	    this.variants = new Variants({
	      $container: this.$container,
	      enableHistoryState: this.settings.enableHistoryState,
	      singleOptionSelector: selectors$6.singleOptionSelector,
	      originalSelectorId: selectors$6.originalSelectorId,
	      product: this.productSingleObject
	    });
	    this.$container.on('variantChange', this.onVariantChange.bind(this));
	    this.$container.on(this.events.CLICK, selectors$6.variantOptionValue, this.onVariantOptionValueClick.bind(this));
	    $$2(document).on(this.events.CLICK, selectors$6.bvReviewsNumber, this.openReviewsAccordion.bind(this));
	    $$2(document).on(this.events.CLICK, selectors$6.reviewsSummary, this.openReviewsAccordion.bind(this));
	    $$2(document).on(this.events.CLICK, selectors$6.reviewFull, this.openReviewsAccordion.bind(this));
	    $$2(document).on(this.events.CLICK, selectors$6.reviewFull, this.openReviewsAccordion.bind(this));
	    $$2(selectors$6.drawerItem).on('shown.bs.collapse', this.onDrawerOpen.bind(this));
	    chosenSelects(this.$container);
	  }
	  onDrawerOpen(e) {
	    const $drawer = $$2(e.currentTarget);
	    const offsetTop = $drawer.offset().top - $$2('.header').outerHeight() - $$2('.product-sticky-bar').outerHeight();
	    $$2('html, body').animate({
	      scrollTop: offsetTop
	    }, 300);
	  }
	  openReviewsAccordion() {
	    $$2(selectors$6.reviewsAccordion).collapse('show');
	    $$2(selectors$6.reviewsAccordion).on('shown.bs.collapse', () => {
	      const reviewsTop = $$2(selectors$6.bvReviews).offset().top;
	      let headerPadding = 150;
	      if (getBreakpointMinWidth('lg') < $$2(window).width()) {
	        headerPadding = 300;
	      }
	      $$2('html, body').animate({
	        scrollTop: reviewsTop - headerPadding
	      }, 300);
	    });
	  }
	  onVariantChange(evt) {
	    const variant = evt.variant;
	    this.updateProductPrices(variant);
	    this.updateAddToCartState(variant);
	    this.updateQuantitySelect(variant);
	    this.updateVariantOptionValues(variant);
	    this.updateFullDetailsLink(variant);
	    this.$singleOptionSelectors.trigger('chosen:updated');
	    this.settings.onVariantChange(variant);
	    //extend code
	    window.dispatchEvent(window.Extend.CustomEvent('extendVariantChange', {
	      detail: {
	        event: evt
	      }
	    }));
	  }

	  /**
	   * Updates the DOM state of the add to cart button
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateAddToCartState(variant) {
	    if (variant) {
	      this.$priceWrapper.removeClass(classes$2.hide);
	    } else {
	      this.$addToCartBtn.prop('disabled', true);
	      this.$addToCartBtnText.html(theme.strings.unavailable);
	      this.$priceWrapper.addClass(classes$2.hide);
	      return;
	    }
	    if (variant.available) {
	      this.$addToCartBtn.prop('disabled', false);
	      this.$addToCartBtnText.html(theme.strings.addToCart);
	    } else {
	      this.$addToCartBtn.prop('disabled', true);
	      this.$addToCartBtnText.html(theme.strings.soldOut);
	    }
	  }

	  /**
	   * Updates the disabled property of the quantity select based on the availability of the selected variant
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateQuantitySelect(variant) {
	    // Close the select while we make changes to it
	    this.$quantitySelect.trigger('chosen:close');
	    this.$quantitySelect.prop('disabled', !(variant && variant.available));
	    this.$quantitySelect.trigger('chosen:updated');
	  }

	  /**
	   * Updates the DOM with specified prices
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateProductPrices(variant) {
	    if (variant) {
	      this.$productPrice.html(formatMoney(variant.price, window.theme.moneyFormat));
	      if (variant.compare_at_price > variant.price) {
	        this.$comparePrice.html(formatMoney(variant.compare_at_price, theme.moneyFormat));
	        this.$compareEls.removeClass(classes$2.hide);
	      } else {
	        this.$comparePrice.html('');
	        this.$compareEls.addClass(classes$2.hide);
	      }
	    }
	  }

	  /**
	   * Updates the DOM state of the elements matching the variantOption Value selector based on the currently selected variant
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateVariantOptionValues(variant) {
	    if (variant) {
	      // Loop through all the options and update the option value
	      for (let i = 1; i <= 3; i++) {
	        const variantOptionValue = variant[`option${i}`];
	        if (!variantOptionValue) break; // Break if the product doesn't have an option at this index

	        // Since we are finding the variantOptionValueUI based on the *actual* value, we need to scope to the correct list
	        // As some products can have the same values for different variant options (waist + inseam both use "32", "34", etc..)
	        const $list = this.$variantOptionValueList.filter(`[data-option-position="${i}"]`);
	        const $variantOptionValueUI = $list.find('[data-variant-option-value="' + variantOptionValue + '"]');
	        $variantOptionValueUI.addClass(classes$2.variantOptionValueActive);
	        $variantOptionValueUI.siblings().removeClass(classes$2.variantOptionValueActive);
	      }
	    }
	  }

	  /**
	   * Used on quick view, updates the "view full details" link to point to the currently selected variant
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateFullDetailsLink(variant) {
	    let updatedUrl;
	    if (variant && this.$fullDetailsLink.length) {
	      updatedUrl = getUrlWithUpdatedQueryStringParameter('variant', variant.id, this.$fullDetailsLink.attr('href'));
	      this.$fullDetailsLink.attr('href', updatedUrl);
	    }
	  }

	  /**
	   * Handle variant option value click event.
	   * Update the associated select tag and update the UI for this value
	   *
	   * @param {event} evt
	   */
	  onVariantOptionValueClick(e) {
	    const $option = $$2(e.currentTarget);
	    if ($option.hasClass(classes$2.variantOptionValueActive)) {
	      return;
	    }
	    const value = $option.data('variant-option-value');
	    const title = $option.attr('title');
	    const position = $option.parents(selectors$6.variantOptionValueList).data('option-position');
	    const $selector = this.$singleOptionSelectors.filter(`[data-index="option${position}"]`);
	    const $optionParent = $option.parents('.selector-wrapper.form-group.js');
	    const $variantLabel = $$2(selectors$6.variantName, $optionParent);
	    $selector.val(value);
	    $selector.trigger('change');
	    $option.addClass(classes$2.variantOptionValueActive);
	    $option.siblings().removeClass(classes$2.variantOptionValueActive);
	    $variantLabel.text(title);
	  }
	}

	const selectors$5 = {
	  productGallery: '[data-product-gallery]',
	  productGallerySlideshow: '[data-product-gallery-slideshow]',
	  productGalleryThumbnails: '[data-product-gallery-thumbnails]',
	  productGalleryThumbnailsSlide: '[data-product-gallery-thumbnails-slide]',
	  initialSlide: '[data-initial-slide]'
	};
	const classes$1 = {
	  hide: 'hide',
	  zoomReady: 'is-zoomable',
	  zoomedIn: 'is-zoomed'
	};
	class ProductDetailGallery {
	  /**
	   * Product Detail Gallery Constructor
	   * Handles the interaction between a single gallery and set of thumbnails
	   * See: snippets/product-detail-galleries.liquid
	   *
	   * @param {HTMLElement | jQuery} el - gallery element containing elements matching the slideshow and thumbnails selectors
	   */
	  constructor(el) {
	    this.$el = $$2(el);
	    this.$slideshow = this.$el.find(selectors$5.productGallerySlideshow);
	    this.$thumbnails = this.$el.find(selectors$5.productGalleryThumbnails);
	    this.optionValue = this.$el.data('option-value');
	    $$2.each(this.$thumbnails, function (index, slider) {
	      const $thumbSlider = $$2(slider);
	      if ($thumbSlider.find(selectors$5.productGalleryThumbnailsSlide).length === 1) {
	        $thumbSlider.hide();
	      }
	    });

	    // Look for element with the initialSlide selector.
	    const initialSlide = this.$slideshow.find(selectors$5.initialSlide).length ? this.$slideshow.find(selectors$5.initialSlide).index() : 0;
	    this.thumbnailsSwiper = new Swiper(this.$thumbnails.get(0), {
	      init: false,
	      loop: true,
	      initialSlide: initialSlide,
	      loopedSlides: this.$thumbnails.find('.swiper-slide').length,
	      spaceBetween: 10,
	      slidesPerView: 4,
	      centeredSlides: true,
	      speed: 500,
	      preloadImages: false,
	      slideToClickedSlide: true,
	      lazy: {
	        loadPrevNext: true,
	        loadPrevNextAmount: 1
	      },
	      navigation: {
	        nextEl: this.$thumbnails.find('.arrow--right').get(0),
	        prevEl: this.$thumbnails.find('.arrow--left').get(0)
	      }
	    });
	    this.swiper = new Swiper(this.$slideshow.get(0), {
	      init: false,
	      loop: true,
	      spaceBetween: 10,
	      initialSlide: initialSlide,
	      loopedSlides: this.$thumbnails.find('.swiper-slide').length,
	      speed: 500,
	      preloadImages: false,
	      watchOverflow: true,
	      lazy: {
	        loadPrevNext: true,
	        loadPrevNextAmount: 1
	      },
	      pagination: {
	        el: this.$slideshow.find('.swiper-pagination'),
	        type: 'bullets',
	        clickable: true
	      }
	    });
	    this.thumbnailsSwiper.controller.control = this.swiper;
	    this.swiper.controller.control = this.thumbnailsSwiper;
	    this.thumbnailsSwiper.init();
	    this.swiper.init();
	  }
	}
	class ProductDetailGalleries {
	  /**
	   * ProductDetailGalleries constructor
	   * Initializes all galleries and updates visibility on variant change
	   *
	   * @param {Object} config
	   * @param {jQuery} config.$container - Main element, see snippets/product-detail-galleries.liquid
	   */
	  constructor(config) {
	    this.settings = {};
	    this.name = 'productDetailGalleries';
	    this.namespace = `.${this.name}`;

	    // Kind of pointless to have a defaults object like this
	    // But doing it to keep consistent with productDetailForm
	    const defaults = {
	      $container: null
	    };
	    this.settings = $$2.extend({}, defaults, config);
	    if (!this.settings.$container || this.settings.$container.length === 0) {
	      console.warn(`[${this.name}] - config.$container required to initialize`);
	      return;
	    }
	    this.$container = this.settings.$container; // Scoping element for all DOM lookups
	    this.$galleries = $$2(selectors$5.productGallery, this.$container); // Galleries contain a slideshow + thumbnails

	    this.galleries = this.$galleries.toArray().map(el => new ProductDetailGallery(el));
	  }
	  getProductDetailGalleryForVariantOptionValue(optionValue) {
	    return this.galleries.filter(gallery => gallery.optionValue === optionValue)[0];
	  }

	  /**
	   * Look for a gallery matching one of the selected variant's options and switch to that gallery
	   * If a matching gallery doesn't exist, look for the variant's featured image in the main gallery and switch to that
	   *
	   * @param {Object} variant - Shopify variant object
	   */
	  updateForVariant(variant) {
	    if (!variant) return;
	    if (this.galleries.length > 1) {
	      for (let i = 3; i >= 1; i--) {
	        const gallery = this.getProductDetailGalleryForVariantOptionValue(variant['option' + i]);
	        if (gallery && gallery.$el.hasClass(classes$1.hide)) {
	          this.$galleries.addClass(classes$1.hide);
	          gallery.$el.removeClass(classes$1.hide);

	          // Now that we show a different gallery, make sure it's all ready to go
	          gallery.swiper.update();
	          gallery.thumbnailsSwiper.update();
	        }
	      }
	    } else {
	      // this.$galleries is just a single gallery
	      // Slide to featured image for selected variant but only if we're not already on it.
	      if (variant.featured_image && this.$galleries.find('.swiper-slide-active').data('image') !== variant.featured_image.id) {
	        // eslint-disable-line
	        const $imageSlide = this.$galleries.find(`[data-image="${variant.featured_image.id}"]`).first();
	        if ($imageSlide.length) {
	          this.galleries[0].swiper.slideToLoop($imageSlide.data('swiper-slide-index'));
	        }
	      }
	    }
	  }
	}

	const selectors$4 = {
	  productDetailForm: '[data-product-detail-form]',
	  productDetailGalleries: '[data-product-detail-galleries]',
	  videoUrl: '[data-product-video-url]',
	  descriptionToggle: '[data-description-toggle]',
	  shortDescription: '[data-short-description]',
	  longDescription: '[data-long-description]',
	  playVideo: '[data-product-video-play]',
	  productVideoModal: '[data-product-video-modal]',
	  videoPlayer: '[data-product-video-player]',
	  babyListData: '[data-babylist-info]',
	  addToRegistry: '[data-add-to-registry]',
	  affirmBlock: '[data-affirm-block]',
	  affirmAsLowAs: '.affirm-as-low-as',
	  addToCartBtn: '[data-add-to-cart]',
	  bisButton: '[data-bis-button]'
	};
	class ProductDetail {
	  /**
	   * ProductDetail constructor
	   *
	   *
	   * @param {jQuery | HTMLElement} el - Main element, see snippets/product-detail.liquid
	   * @param {Boolean} enableHistoryState - enables URL history updates on variant change.  See productDetailForm.js
	   */
	  constructor(el) {
	    let enableHistoryState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    this.settings = {};
	    this.name = 'productDetail';
	    const self = this;
	    this.$el = $$2(el);
	    if (!this.$el || this.$el === undefined) {
	      console.warn(`[${this.name}] - $el required to initialize`);
	      return;
	    }
	    this.$pdg = $$2(selectors$4.productDetailGalleries, this.$el);
	    this.$pdf = $$2(selectors$4.productDetailForm, this.$el);
	    this.galleries = new ProductDetailGalleries({
	      $container: this.$pdg
	    });
	    this.form = new ProductDetailForm({
	      $container: this.$pdf,
	      onVariantChange: this.onVariantChange.bind(this),
	      enableHistoryState: enableHistoryState
	    });
	    this.videoUrl = $$2(selectors$4.videoUrl).val() || '';
	    if (this.videoUrl !== '') {
	      $$2.get('https://vimeo.com/api/oembed.json?url=' + this.videoUrl, data => {
	        $$2(selectors$4.videoPlayer, self.$el).data('video-id', data.video_id);
	        self.player = new VideoPlayer($$2(selectors$4.videoPlayer, self.$el));
	      });
	    }
	    this.$productVideoModal = $$2(selectors$4.productVideoModal, this.$el);

	    // Add to registry trigger
	    $$2(selectors$4.addToRegistry, this.$el).on('click', this.addToRegistry.bind(this));

	    // Short-Long description toggle
	    $$2(selectors$4.descriptionToggle, this.$el).on('click', this.toggleDescription.bind(this));

	    // Video toggle and play
	    $$2(selectors$4.playVideo, this.$el).on('click', this.toggleVideoModal.bind(this));
	    this.$productVideoModal.on('show.bs.modal', this.playVideo.bind(this));
	    this.$productVideoModal.on('hide.bs.modal', this.stopVideo.bind(this));
	  }
	  playVideo(el) {
	    this.player.play();
	  }
	  stopVideo() {
	    this.player.pause();
	  }
	  addToRegistry(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    const registryData = JSON.parse($$2(selectors$4.babyListData).html());
	    window.bl.addToRegistry(registryData);
	  }
	  toggleDescription(e) {
	    e.preventDefault();
	    $$2(selectors$4.shortDescription).toggleClass('hide');
	    $$2(selectors$4.longDescription).toggleClass('hide');
	  }
	  toggleVideoModal(e) {
	    e.preventDefault();
	    this.$productVideoModal.modal('toggle');
	  }
	  onVariantChange(variant) {
	    this.galleries.updateForVariant(variant);
	    if (variant.price > 5000) {
	      $$2(selectors$4.affirmAsLowAs).attr('data-amount', variant.price);
	      $$2(selectors$4.affirmBlock).show();
	      window.affirm.ui.refresh();
	    } else {
	      $$2(selectors$4.affirmBlock).hide();
	    }
	    if (variant.available === true) {
	      $$2(selectors$4.addToCartBtn).show();
	      $$2(selectors$4.bisButton).hide();
	    } else {
	      $$2(selectors$4.addToCartBtn).hide();
	      $$2(selectors$4.bisButton).show();
	    }
	  }
	}

	$$2(window);

	// Get a reference to the element that you want to work with
	var preLovePdpCallout = document.querySelector("#pre-love-pdpCallout");
	if (preLovePdpCallout) {
	  preLovePdpCallout.addEventListener('mouseover', changeDefOver);
	  preLovePdpCallout.addEventListener('mouseout', changeDefOut);
	}
	function changeDefOver() {
	  document.getElementById("rebelHoverBox").classList.add('hoverr');
	}
	function changeDefOut() {
	  document.getElementById("rebelHoverBox").classList.remove('hoverr');
	}

	// You shouldn't really be using the template script setup but if you *need* to, extend from this class and put all your
	// eventHandlers in a method called `addEventHandlers`

	class BaseTemplate {
	  constructor(templateBodyClass) {
	    if (templateBodyClass !== undefined && $$2(document.body).hasClass(templateBodyClass)) {
	      this.addEventHandlers();
	    }
	  }
	  addEventHandlers() {
	    //
	  }
	}

	const selectors$3 = {
	  slideupAlertForm: '[data-slideup-alert-form]',
	  tabContainer: '[data-tab-container]',
	  qaSetMax: '[data-qa-set-max]',
	  qaToggleEnabled: '[data-qa-toggle-enabled]',
	  qa: '[data-quantity-adjuster]',
	  newsletterForm: '#newsletter-form',
	  newsletterTriggerSuccess: '[data-newsletter-trigger-success]',
	  newsletterTriggerSubscribed: '[data-newsletter-trigger-subscribed]',
	  newsletterTriggerFail: '[data-newsletter-trigger-fail]'
	};
	class PageComponentsTemplate extends BaseTemplate {
	  constructor() {
	    super('template-page-components');
	  }
	  addEventHandlers() {
	    $$2(selectors$3.slideupAlertForm).on('submit', function (e) {
	      e.preventDefault();
	      new SlideupAlert({
	        title: $$2(this).find('input[name="title"]').val(),
	        text: $$2(this).find('input[name="text"]').val()
	      });
	    });

	    // Tabs
	    new Tabs($$2(selectors$3.tabContainer));

	    // Quantity Adjuster
	    $$2(selectors$3.qaSetMax).on('click', e => {
	      $$2(selectors$3.qa).find('input[type="number"]').attr('max', $$2(e.currentTarget).data('qa-set-max'));
	    });
	    $$2(selectors$3.qaToggleEnabled).on('click', e => {
	      const $qaInput = $$2(selectors$3.qa).find('input[type="number"]');
	      $qaInput.attr('disabled', !$qaInput.is(':disabled'));
	    });

	    // Newsletter Form
	    this.newsletterForm = new NewsletterForm($$2(selectors$3.newsletterForm), {
	      setCookies: false
	    });

	    /* eslint-disable */
	    $$2(selectors$3.newsletterTriggerSuccess).on('click', () => {
	      this.newsletterForm.onSubscribeSuccess({
	        data: {
	          is_subscribed: false
	        }
	      });
	    });
	    $$2(selectors$3.newsletterTriggerSubscribed).on('click', () => {
	      this.newsletterForm.onSubscribeSuccess({
	        data: {
	          is_subscribed: true
	        }
	      });
	    });
	    $$2(selectors$3.newsletterTriggerFail).on('click', () => {
	      this.newsletterForm.onSubscribeFail();
	    });
	    /* eslint-enable */

	    VideoPlayer.refresh();
	    $$2(document).on('click', 'a[href="#"]', e => e.preventDefault());
	  }
	}
	new PageComponentsTemplate();

	const $body = $$2(document.body);
	const selectors$2 = {
	  dot: '.dot'
	};
	class PageStylesTemplate extends BaseTemplate {
	  constructor() {
	    super('template-page-styles');
	  }
	  addEventHandlers() {
	    $body.on('click', selectors$2.dot, function () {
	      $$2(this).siblings().removeClass('is-active');
	      $$2(this).addClass('is-active');
	    });
	    $$2(document).on('click', 'a[href="#"]', e => e.preventDefault());
	  }
	}
	new PageStylesTemplate();

	var imagesloaded = {exports: {}};

	var evEmitter = {exports: {}};

	/**
	 * EvEmitter v2.1.1
	 * Lil' event emitter
	 * MIT License
	 */
	evEmitter.exports;
	var hasRequiredEvEmitter;
	function requireEvEmitter() {
	  if (hasRequiredEvEmitter) return evEmitter.exports;
	  hasRequiredEvEmitter = 1;
	  (function (module) {
	    (function (global, factory) {
	      // universal module definition
	      if (module.exports) {
	        // CommonJS - Browserify, Webpack
	        module.exports = factory();
	      } else {
	        // Browser globals
	        global.EvEmitter = factory();
	      }
	    })(typeof window != 'undefined' ? window : commonjsGlobal$1, function () {
	      function EvEmitter() {}
	      let proto = EvEmitter.prototype;
	      proto.on = function (eventName, listener) {
	        if (!eventName || !listener) return this;

	        // set events hash
	        let events = this._events = this._events || {};
	        // set listeners array
	        let listeners = events[eventName] = events[eventName] || [];
	        // only add once
	        if (!listeners.includes(listener)) {
	          listeners.push(listener);
	        }
	        return this;
	      };
	      proto.once = function (eventName, listener) {
	        if (!eventName || !listener) return this;

	        // add event
	        this.on(eventName, listener);
	        // set once flag
	        // set onceEvents hash
	        let onceEvents = this._onceEvents = this._onceEvents || {};
	        // set onceListeners object
	        let onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
	        // set flag
	        onceListeners[listener] = true;
	        return this;
	      };
	      proto.off = function (eventName, listener) {
	        let listeners = this._events && this._events[eventName];
	        if (!listeners || !listeners.length) return this;
	        let index = listeners.indexOf(listener);
	        if (index != -1) {
	          listeners.splice(index, 1);
	        }
	        return this;
	      };
	      proto.emitEvent = function (eventName, args) {
	        let listeners = this._events && this._events[eventName];
	        if (!listeners || !listeners.length) return this;

	        // copy over to avoid interference if .off() in listener
	        listeners = listeners.slice(0);
	        args = args || [];
	        // once stuff
	        let onceListeners = this._onceEvents && this._onceEvents[eventName];
	        for (let listener of listeners) {
	          let isOnce = onceListeners && onceListeners[listener];
	          if (isOnce) {
	            // remove listener
	            // remove before trigger to prevent recursion
	            this.off(eventName, listener);
	            // unset once flag
	            delete onceListeners[listener];
	          }
	          // trigger listener
	          listener.apply(this, args);
	        }
	        return this;
	      };
	      proto.allOff = function () {
	        delete this._events;
	        delete this._onceEvents;
	        return this;
	      };
	      return EvEmitter;
	    });
	  })(evEmitter);
	  return evEmitter.exports;
	}

	/*!
	 * imagesLoaded v5.0.0
	 * JavaScript is all like "You images are done yet or what?"
	 * MIT License
	 */
	imagesloaded.exports;
	(function (module) {
	  (function (window, factory) {
	    // universal module definition
	    if (module.exports) {
	      // CommonJS
	      module.exports = factory(window, requireEvEmitter());
	    } else {
	      // browser global
	      window.imagesLoaded = factory(window, window.EvEmitter);
	    }
	  })(typeof window !== 'undefined' ? window : commonjsGlobal$1, function factory(window, EvEmitter) {
	    let $ = window.jQuery;
	    let console = window.console;

	    // -------------------------- helpers -------------------------- //

	    // turn element or nodeList into an array
	    function makeArray(obj) {
	      // use object if already an array
	      if (Array.isArray(obj)) return obj;
	      let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
	      // convert nodeList to array
	      if (isArrayLike) return [...obj];

	      // array of single index
	      return [obj];
	    }

	    // -------------------------- imagesLoaded -------------------------- //

	    /**
	     * @param {[Array, Element, NodeList, String]} elem
	     * @param {[Object, Function]} options - if function, use as callback
	     * @param {Function} onAlways - callback function
	     * @returns {ImagesLoaded}
	     */
	    function ImagesLoaded(elem, options, onAlways) {
	      // coerce ImagesLoaded() without new, to be new ImagesLoaded()
	      if (!(this instanceof ImagesLoaded)) {
	        return new ImagesLoaded(elem, options, onAlways);
	      }
	      // use elem as selector string
	      let queryElem = elem;
	      if (typeof elem == 'string') {
	        queryElem = document.querySelectorAll(elem);
	      }
	      // bail if bad element
	      if (!queryElem) {
	        console.error(`Bad element for imagesLoaded ${queryElem || elem}`);
	        return;
	      }
	      this.elements = makeArray(queryElem);
	      this.options = {};
	      // shift arguments if no options set
	      if (typeof options == 'function') {
	        onAlways = options;
	      } else {
	        Object.assign(this.options, options);
	      }
	      if (onAlways) this.on('always', onAlways);
	      this.getImages();
	      // add jQuery Deferred object
	      if ($) this.jqDeferred = new $.Deferred();

	      // HACK check async to allow time to bind listeners
	      setTimeout(this.check.bind(this));
	    }
	    ImagesLoaded.prototype = Object.create(EvEmitter.prototype);
	    ImagesLoaded.prototype.getImages = function () {
	      this.images = [];

	      // filter & find items if we have an item selector
	      this.elements.forEach(this.addElementImages, this);
	    };
	    const elementNodeTypes = [1, 9, 11];

	    /**
	     * @param {Node} elem
	     */
	    ImagesLoaded.prototype.addElementImages = function (elem) {
	      // filter siblings
	      if (elem.nodeName === 'IMG') {
	        this.addImage(elem);
	      }
	      // get background image on element
	      if (this.options.background === true) {
	        this.addElementBackgroundImages(elem);
	      }

	      // find children
	      // no non-element nodes, #143
	      let {
	        nodeType
	      } = elem;
	      if (!nodeType || !elementNodeTypes.includes(nodeType)) return;
	      let childImgs = elem.querySelectorAll('img');
	      // concat childElems to filterFound array
	      for (let img of childImgs) {
	        this.addImage(img);
	      }

	      // get child background images
	      if (typeof this.options.background == 'string') {
	        let children = elem.querySelectorAll(this.options.background);
	        for (let child of children) {
	          this.addElementBackgroundImages(child);
	        }
	      }
	    };
	    const reURL = /url\((['"])?(.*?)\1\)/gi;
	    ImagesLoaded.prototype.addElementBackgroundImages = function (elem) {
	      let style = getComputedStyle(elem);
	      // Firefox returns null if in a hidden iframe https://bugzil.la/548397
	      if (!style) return;

	      // get url inside url("...")
	      let matches = reURL.exec(style.backgroundImage);
	      while (matches !== null) {
	        let url = matches && matches[2];
	        if (url) {
	          this.addBackground(url, elem);
	        }
	        matches = reURL.exec(style.backgroundImage);
	      }
	    };

	    /**
	     * @param {Image} img
	     */
	    ImagesLoaded.prototype.addImage = function (img) {
	      let loadingImage = new LoadingImage(img);
	      this.images.push(loadingImage);
	    };
	    ImagesLoaded.prototype.addBackground = function (url, elem) {
	      let background = new Background(url, elem);
	      this.images.push(background);
	    };
	    ImagesLoaded.prototype.check = function () {
	      this.progressedCount = 0;
	      this.hasAnyBroken = false;
	      // complete if no images
	      if (!this.images.length) {
	        this.complete();
	        return;
	      }

	      /* eslint-disable-next-line func-style */
	      let onProgress = (image, elem, message) => {
	        // HACK - Chrome triggers event before object properties have changed. #83
	        setTimeout(() => {
	          this.progress(image, elem, message);
	        });
	      };
	      this.images.forEach(function (loadingImage) {
	        loadingImage.once('progress', onProgress);
	        loadingImage.check();
	      });
	    };
	    ImagesLoaded.prototype.progress = function (image, elem, message) {
	      this.progressedCount++;
	      this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
	      // progress event
	      this.emitEvent('progress', [this, image, elem]);
	      if (this.jqDeferred && this.jqDeferred.notify) {
	        this.jqDeferred.notify(this, image);
	      }
	      // check if completed
	      if (this.progressedCount === this.images.length) {
	        this.complete();
	      }
	      if (this.options.debug && console) {
	        console.log(`progress: ${message}`, image, elem);
	      }
	    };
	    ImagesLoaded.prototype.complete = function () {
	      let eventName = this.hasAnyBroken ? 'fail' : 'done';
	      this.isComplete = true;
	      this.emitEvent(eventName, [this]);
	      this.emitEvent('always', [this]);
	      if (this.jqDeferred) {
	        let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
	        this.jqDeferred[jqMethod](this);
	      }
	    };

	    // --------------------------  -------------------------- //

	    function LoadingImage(img) {
	      this.img = img;
	    }
	    LoadingImage.prototype = Object.create(EvEmitter.prototype);
	    LoadingImage.prototype.check = function () {
	      // If complete is true and browser supports natural sizes,
	      // try to check for image status manually.
	      let isComplete = this.getIsImageComplete();
	      if (isComplete) {
	        // report based on naturalWidth
	        this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');
	        return;
	      }

	      // If none of the checks above matched, simulate loading on detached element.
	      this.proxyImage = new Image();
	      // add crossOrigin attribute. #204
	      if (this.img.crossOrigin) {
	        this.proxyImage.crossOrigin = this.img.crossOrigin;
	      }
	      this.proxyImage.addEventListener('load', this);
	      this.proxyImage.addEventListener('error', this);
	      // bind to image as well for Firefox. #191
	      this.img.addEventListener('load', this);
	      this.img.addEventListener('error', this);
	      this.proxyImage.src = this.img.currentSrc || this.img.src;
	    };
	    LoadingImage.prototype.getIsImageComplete = function () {
	      // check for non-zero, non-undefined naturalWidth
	      // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
	      return this.img.complete && this.img.naturalWidth;
	    };
	    LoadingImage.prototype.confirm = function (isLoaded, message) {
	      this.isLoaded = isLoaded;
	      let {
	        parentNode
	      } = this.img;
	      // emit progress with parent <picture> or self <img>
	      let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;
	      this.emitEvent('progress', [this, elem, message]);
	    };

	    // ----- events ----- //

	    // trigger specified handler for event type
	    LoadingImage.prototype.handleEvent = function (event) {
	      let method = 'on' + event.type;
	      if (this[method]) {
	        this[method](event);
	      }
	    };
	    LoadingImage.prototype.onload = function () {
	      this.confirm(true, 'onload');
	      this.unbindEvents();
	    };
	    LoadingImage.prototype.onerror = function () {
	      this.confirm(false, 'onerror');
	      this.unbindEvents();
	    };
	    LoadingImage.prototype.unbindEvents = function () {
	      this.proxyImage.removeEventListener('load', this);
	      this.proxyImage.removeEventListener('error', this);
	      this.img.removeEventListener('load', this);
	      this.img.removeEventListener('error', this);
	    };

	    // -------------------------- Background -------------------------- //

	    function Background(url, element) {
	      this.url = url;
	      this.element = element;
	      this.img = new Image();
	    }

	    // inherit LoadingImage prototype
	    Background.prototype = Object.create(LoadingImage.prototype);
	    Background.prototype.check = function () {
	      this.img.addEventListener('load', this);
	      this.img.addEventListener('error', this);
	      this.img.src = this.url;
	      // check if image is already complete
	      let isComplete = this.getIsImageComplete();
	      if (isComplete) {
	        this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');
	        this.unbindEvents();
	      }
	    };
	    Background.prototype.unbindEvents = function () {
	      this.img.removeEventListener('load', this);
	      this.img.removeEventListener('error', this);
	    };
	    Background.prototype.confirm = function (isLoaded, message) {
	      this.isLoaded = isLoaded;
	      this.emitEvent('progress', [this, this.element, message]);
	    };

	    // -------------------------- jQuery -------------------------- //

	    ImagesLoaded.makeJQueryPlugin = function (jQuery) {
	      jQuery = jQuery || window.jQuery;
	      if (!jQuery) return;

	      // set local variable
	      $ = jQuery;
	      // $().imagesLoaded()
	      $.fn.imagesLoaded = function (options, onAlways) {
	        let instance = new ImagesLoaded(this, options, onAlways);
	        return instance.jqDeferred.promise($(this));
	      };
	    };
	    // try making plugin
	    ImagesLoaded.makeJQueryPlugin();

	    // --------------------------  -------------------------- //

	    return ImagesLoaded;
	  });
	})(imagesloaded);
	var imagesloadedExports = imagesloaded.exports;
	var imagesLoaded = /*@__PURE__*/getDefaultExportFromCjs(imagesloadedExports);

	const selectors$1 = {
	  quickView: '[data-quick-view]',
	  quickViewContentsBody: '[data-quick-view-contents-body]',
	  quickViewClose: '[data-quick-view-close]',
	  productCardContents: '[data-product-card-contents]',
	  productDetail: '[data-product-detail]'
	};
	const classes = {
	  quickViewIsOpen: 'is-open',
	  productCardHasOpenQuickView: 'has-open-quick-view'
	};

	/**
	 * QuickView
	 * -------------------------------------------------------------------------------
	 * QuickView is a version of the product detail form
	 * that we pull down via AJAX and append to a product card.
	 *
	 * @namespace quickView
	 */

	class QuickView {
	  /**
	   * QuickView constructor
	   *
	   * @param { Object } settings
	   * @param { HTMLElement | jQuery } settings.$productCard
	   * @param { String } settings.url - URL pointing to the quick view of the product
	   * @param { Function } settings.onProductDetailReady - Called after the product form is initialized.  `this` references the QuickView instance
	   * @param { Number } settings.transitionDuration - ms
	   * @param { String } settings.transitionTimingFunction - string matching a jQuery easing equation.  see core/animations
	   */
	  constructor(options) {
	    this.name = 'quickView';
	    this.namespace = `.${this.name}`;
	    const defaults = {
	      onProductDetailReady: $$2.noop,
	      transitionDuration: 800,
	      transitionTimingFunction: 'ease-in-out'
	    };
	    this.settings = $$2.extend({}, defaults, options);
	    if (this.settings.$productCard === undefined) {
	      console.warn('[' + this.name + '] - $productCard element required to initialize');
	      return;
	    }
	    if (typeof this.settings.url !== 'string' || this.settings.url.length === 0 || this.settings.url.indexOf('quick-view') === -1) {
	      console.warn(`[${this.name}] - valid URL required to initialize`);
	      return;
	    }

	    // Elements we'll need for everything to work
	    this.$productCard = this.settings.$productCard;
	    this.$productCardContents = this.$productCard.find(selectors$1.productCardContents);
	    this.$productDetail = null;
	    this.$quickView = null;
	    this.$quickViewContentsBody = null;
	    this.$close = null;
	    this.stateIsOpen = false;
	    this.supportsCssTransitions = !!Modernizr.csstransitions;
	    this.productDetailInstance = null;
	    this.events = {
	      OPEN: 'open' + this.namespace,
	      OPENED: 'opened' + this.namespace,
	      CLOSE: 'close' + this.namespace,
	      CLOSED: 'closed' + this.namespace,
	      LOADED: 'loaded' + this.namespace
	    };
	    this.$productCard.on('click', selectors$1.quickViewClose, this.onCloseClick.bind(this));
	    this.$productCard.height(this.$productCardContents.outerHeight(true));

	    // Initial ajax request to get the quick view content
	    $$2.get(this.settings.url, this._onAjaxSuccess.bind(this));
	  }

	  /**
	   * Initial AJAX Call callback
	   * Gets the returned HTML, adds it to the DOM, sets the instance's dom element variables, initializes the product detail form
	   *
	   */
	  _onAjaxSuccess(ajaxResponse) {
	    this.$productCard.append($$2(ajaxResponse));
	    this.$productDetail = this.$productCard.find(selectors$1.productDetail);
	    this.$quickView = this.$productCard.find(selectors$1.quickView);
	    this.$quickViewContentsBody = this.$productCard.find(selectors$1.quickViewContentsBody);
	    this.$close = this.$quickView.find(selectors$1.quickViewClose);
	    this.productDetailInstance = new ProductDetail(this.$productDetail, false);
	    this.settings.onProductDetailReady.call(this);

	    // Fire off the loaded event once all the images in the quick view are loaded
	    imagesLoaded(this.$quickView.get(0), () => {
	      const e = $$2.Event(this.events.LOADED);
	      this.$productCard.trigger(e);
	    });
	  }
	  open() {
	    this.onOpen();
	    if (this.isOpen()) {
	      return;
	    }
	    this.stateIsOpen = true;
	    this.doOpenAnimation();
	  }
	  close() {
	    this.onClose();
	    if (this.isClosed()) {
	      return;
	    }
	    this.stateIsOpen = false;
	    this.doCloseAnimation();
	  }
	  isOpen() {
	    return this.stateIsOpen;
	  }
	  isClosed() {
	    return !this.isOpen();
	  }

	  /**
	   * Called after this.open is called but before any opening animation has run
	   */
	  onOpen() {
	    this.$productCard.addClass(classes.productCardHasOpenQuickView);
	    const e = $$2.Event(this.events.OPEN);
	    this.$productCard.trigger(e);
	  }

	  /**
	   * Called after this.close is called but before any closing animation has run
	   */
	  onClose() {
	    this.$productCard.removeClass(classes.productCardHasOpenQuickView);
	    const e = $$2.Event(this.events.CLOSE);
	    this.$productCard.trigger(e);
	  }

	  /**
	   * Called after the opening animation has run
	   */
	  onOpened() {
	    const e = $$2.Event(this.events.OPENED);
	    this.$productCard.trigger(e);
	  }

	  /**
	   * Called after the closing animation has run
	   */
	  onClosed() {
	    const e = $$2.Event(this.events.CLOSED);
	    this.$productCard.trigger(e);
	    this.$quickView.removeClass(classes.quickViewIsOpen);
	  }
	  doOpenAnimation() {
	    this.$quickView.addClass(classes.quickViewIsOpen);
	    const productCardContentsHeight = this.$productCardContents.outerHeight(true);
	    const qvHeight = this.$quickViewContentsBody.outerHeight(true);
	    this.$productCard.height(productCardContentsHeight);
	    this.$quickView.height(0);
	    this.setTransitions();
	    this.$productCard.height(productCardContentsHeight + qvHeight);
	    this.$quickView.height(qvHeight);
	    if (this.supportsCssTransitions) {
	      this.$quickView.one(whichTransitionEnd(), this.onOpened.bind(this));
	    } else {
	      this.onOpened();
	    }
	  }
	  doCloseAnimation() {
	    this.stateIsOpen = false;
	    const productCardContentsHeight = this.$productCardContents.outerHeight(true);
	    this.$productCard.height(productCardContentsHeight);
	    this.$quickView.height(0);
	    if (this.supportsCssTransitions) {
	      this.$quickView.one(whichTransitionEnd(), this.onClosed.bind(this));
	    } else {
	      this.onClosed();
	    }
	  }
	  onResize() {
	    const qvHeight = this.$quickViewContentsBody.outerHeight(true);
	    const pccHeight = this.$productCardContents.outerHeight(true);
	    if (this.isClosed()) {
	      this.$productCard.height(pccHeight);
	    } else {
	      this.$productCard.height(pccHeight + qvHeight);
	      this.$quickView.height(qvHeight);
	    }
	  }
	  setTransitions() {
	    const trans = `height ${this.settings.transitionDuration}ms ${this.settings.transitionTimingFunction}`;
	    this.$quickView.css('transition', trans);
	    this.$productCard.css('transition', trans);
	  }
	  scrollToProductCard() {
	    $$2('html, body').animate({
	      scrollTop: this.$productCard.offset().top - 100
	    });
	  }
	  scrollToQuickView() {
	    $$2('html, body').animate({
	      scrollTop: this.$quickView.offset().top
	    });
	  }
	  onCloseClick(e) {
	    e.preventDefault();
	    this.close();
	  }
	}

	class DropdownManager {
	  constructor() {
	    this.closeDropdownTimeout = null;
	    this.closeDropdownTimeoutDuration = 80;
	    this.dropdowns = [];
	    this.activeDropdown = undefined;
	    this.touchDevice = Modernizr && Modernizr.touchevents;
	  }
	  register($trigger) {
	    const dd = new Dropdown($trigger);
	    if (this.touchDevice) {
	      dd.$trigger.on('click', this.onTriggerTouchClick.bind(this, dd));
	    } else {
	      dd.$trigger.on('mouseenter', this.onTriggerMouseEnter.bind(this, dd));
	      dd.$trigger.on('mouseleave', this.onTriggerMouseLeave.bind(this, dd));
	      dd.$el.on('mouseleave', this.onDropdownMouseLeave.bind(this, dd));
	      dd.$el.on('mouseenter', this.onDropdownMouseEnter.bind(this, dd));
	    }
	    this.dropdowns.push(dd);
	  }
	  getDropdownByBlockId(id) {
	    return find$1(this.dropdowns, 'blockId', id);
	  }
	  onTriggerMouseEnter(dd, e) {
	    this.stopCloseTimeout();
	    this.openDropdown(dd);
	  }
	  onTriggerMouseLeave(dd, e) {
	    this.startCloseTimeout(dd);
	  }
	  onTriggerTouchClick(dd, e) {
	    e.preventDefault();
	    e.stopPropagation();
	    this.toggleDropdown(dd);
	  }
	  onDropdownMouseEnter(dd, e) {
	    this.stopCloseTimeout();
	  }
	  onDropdownMouseLeave(dd, e) {
	    this.startCloseTimeout(dd);
	  }
	  toggleDropdown(dd) {
	    return this.activeDropdown === dd ? this.closeDropdown(dd) : this.openDropdown(dd);
	  }
	  openDropdown(dd) {
	    if (this.activeDropdown !== dd) {
	      this.closeAllDropdowns();
	      dd.open();
	      this.activeDropdown = dd;
	    }
	  }
	  closeDropdown(dd) {
	    dd.close();
	    if (this.activeDropdown === dd) {
	      this.activeDropdown = undefined;
	    }
	  }
	  closeAllDropdowns() {
	    $$2.each(this.dropdowns, (i, dd) => {
	      if (dd.isOpen()) {
	        dd.close();
	      }
	    });
	    this.activeDropdown = undefined;
	  }
	  startCloseTimeout(dd) {
	    this.closeDropdownTimeout = setTimeout(this.closeDropdown.bind(this, dd), this.closeDropdownTimeoutDuration);
	  }
	  stopCloseTimeout() {
	    clearTimeout(this.closeDropdownTimeout);
	  }
	}
	new DropdownManager();

	const $window = $$2(window);
	const selectors = {
	  productCard: '[data-product-card]'
	};
	class QuickViewManager {
	  constructor() {
	    this.name = 'quickViewManager';
	    this.quickViews = [];
	    this.loading = false;
	    $window.on('resize', throttle(50, this.onResize.bind(this)));
	  }
	  register(qv) {
	    if (!(qv instanceof QuickView)) {
	      console.warn('[' + this.name + '] - instance of QuickView required when calling register');
	      return;
	    }
	    this.quickViews.push(qv);
	  }
	  getQuickViewByProductCard($productCard) {
	    let foundQV;
	    $$2.each(this.quickViews, (i, qv) => {
	      // eslint-disable-line
	      if (qv.$productCard.is($productCard)) {
	        foundQV = qv;
	        return false;
	      }
	    });
	    return foundQV;
	  }
	  onResize() {
	    $$2.each(this.quickViews, (i, qv) => {
	      qv.onResize();
	    });
	  }
	  getOpenQuickViews() {
	    const opens = [];
	    $$2.each(this.quickViews, (i, qv) => {
	      qv.isOpen() && opens.push(qv);
	    });
	    return opens;
	  }
	  closeOpenQuickViews(cb) {
	    const opens = this.getOpenQuickViews();
	    if (opens.length === 0) {
	      cb();
	    } else {
	      $$2.each(opens, (i, qv) => {
	        if (i === 0) {
	          qv.$productCard.one('closed.quickView', cb);
	        }
	        qv.close();
	      });
	    }
	  }
	  onQuickViewTriggerClick($trigger) {
	    if ($trigger === undefined) {
	      return;
	    }
	    const $productCard = $trigger.parents(selectors.productCard);
	    let quickView = this.getQuickViewByProductCard($productCard);
	    const triggerText = $trigger.text(); // Cache this text so we can set it as loading

	    if (quickView === undefined) {
	      if (this.loading) return; // Return early, we're already fetching a quick view, sorry!

	      this.loading = true;
	      $trigger.text('Loading');

	      // generate a new QV
	      quickView = new QuickView({
	        $productCard: $productCard,
	        url: $trigger.attr('href'),
	        transitionDuration: getTransitionTimingDuration('slow'),
	        transitionTimingFunction: getTransitionTimingFunction('inOutUI')
	      });
	      $productCard.one('loaded.quickView', () => {
	        this.loading = false;
	        $trigger.text(triggerText); // Return the button to it's original state
	        this.closeOpenQuickViews(quickView.open.bind(quickView)); // Make sure all the QVs are closed before opening this new one
	      });
	      this.register(quickView);
	    } else if (!quickView.isOpen()) {
	      this.closeOpenQuickViews(quickView.open.bind(quickView));
	    }
	  }
	}
	new QuickViewManager();

})(require$$2);
